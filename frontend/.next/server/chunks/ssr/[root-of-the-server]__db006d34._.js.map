{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/shared/lib/hash.js"],"sourcesContent":["// http://www.cse.yorku.ca/~oz/hash.html\n// More specifically, 32-bit hash via djbxor\n// (ref: https://gist.github.com/eplawless/52813b1d8ad9af510d85?permalink_comment_id=3367765#gistcomment-3367765)\n// This is due to number type differences between rust for turbopack to js number types,\n// where rust does not have easy way to repreesnt js's 53-bit float number type for the matching\n// overflow behavior. This is more `correct` in terms of having canonical hash across different runtime / implementation\n// as can gaurantee determinstic output from 32bit hash.\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    djb2Hash: null,\n    hexHash: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    djb2Hash: function() {\n        return djb2Hash;\n    },\n    hexHash: function() {\n        return hexHash;\n    }\n});\nfunction djb2Hash(str) {\n    let hash = 5381;\n    for(let i = 0; i < str.length; i++){\n        const char = str.charCodeAt(i);\n        hash = (hash << 5) + hash + char & 0xffffffff;\n    }\n    return hash >>> 0;\n}\nfunction hexHash(str) {\n    return djb2Hash(str).toString(36).slice(0, 5);\n}\n\n//# sourceMappingURL=hash.js.map"],"names":[],"mappings":"AAAA,wCAAwC;AACxC,4CAA4C;AAC5C,iHAAiH;AACjH,wFAAwF;AACxF,gGAAgG;AAChG,wHAAwH;AACxH,wDAAwD;AAExD,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,UAAU;IACV,SAAS;AACb,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,UAAU;QACN,OAAO;IACX;IACA,SAAS;QACL,OAAO;IACX;AACJ;AACA,SAAS,SAAS,GAAG;IACjB,IAAI,OAAO;IACX,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,IAAI;QAC/B,MAAM,OAAO,IAAI,UAAU,CAAC;QAC5B,OAAO,CAAC,QAAQ,CAAC,IAAI,OAAO,OAAO;IACvC;IACA,OAAO,SAAS;AACpB;AACA,SAAS,QAAQ,GAAG;IAChB,OAAO,SAAS,KAAK,QAAQ,CAAC,IAAI,KAAK,CAAC,GAAG;AAC/C,EAEA,gCAAgC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 59, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js"],"sourcesContent":["/**\n * For a given page path, this function ensures that there is a leading slash.\n * If there is not a leading slash, one is added, otherwise it is noop.\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"ensureLeadingSlash\", {\n    enumerable: true,\n    get: function() {\n        return ensureLeadingSlash;\n    }\n});\nfunction ensureLeadingSlash(path) {\n    return path.startsWith('/') ? path : \"/\" + path;\n}\n\n//# sourceMappingURL=ensure-leading-slash.js.map"],"names":[],"mappings":"AAAA;;;CAGC,GACD,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,OAAO,cAAc,CAAC,SAAS,sBAAsB;IACjD,YAAY;IACZ,KAAK;QACD,OAAO;IACX;AACJ;AACA,SAAS,mBAAmB,IAAI;IAC5B,OAAO,KAAK,UAAU,CAAC,OAAO,OAAO,MAAM;AAC/C,EAEA,gDAAgD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 78, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/shared/lib/router/utils/app-paths.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    normalizeAppPath: null,\n    normalizeRscURL: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    normalizeAppPath: function() {\n        return normalizeAppPath;\n    },\n    normalizeRscURL: function() {\n        return normalizeRscURL;\n    }\n});\nconst _ensureleadingslash = require(\"../../page-path/ensure-leading-slash\");\nconst _segment = require(\"../../segment\");\nfunction normalizeAppPath(route) {\n    return (0, _ensureleadingslash.ensureLeadingSlash)(route.split('/').reduce((pathname, segment, index, segments)=>{\n        // Empty segments are ignored.\n        if (!segment) {\n            return pathname;\n        }\n        // Groups are ignored.\n        if ((0, _segment.isGroupSegment)(segment)) {\n            return pathname;\n        }\n        // Parallel segments are ignored.\n        if (segment[0] === '@') {\n            return pathname;\n        }\n        // The last segment (if it's a leaf) should be ignored.\n        if ((segment === 'page' || segment === 'route') && index === segments.length - 1) {\n            return pathname;\n        }\n        return pathname + \"/\" + segment;\n    }, ''));\n}\nfunction normalizeRscURL(url) {\n    return url.replace(/\\.rsc($|\\?)/, // $1 ensures `?` is preserved\n    '$1');\n}\n\n//# sourceMappingURL=app-paths.js.map"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IACzC,OAAO;AACX;AACA,KAAK,CAAC,OAAO,OAAO,GAAG;IACnB,kBAAkB;IAClB,iBAAiB;AACrB,CAAC;AACD,SAAS,QAAQ,MAAM,EAAE,GAAG;IACxB,IAAI,IAAI,QAAQ,IAAI,OAAO,cAAc,CAAC,QAAQ,MAAM;QACpD,YAAY;QACZ,KAAK,GAAG,CAAC,KAAK;IAClB;AACJ;AACA,QAAQ,SAAS;IACb,kBAAkB;QACd,OAAO;IACX;IACA,iBAAiB;QACb,OAAO;IACX;AACJ;AACA,MAAM;AACN,MAAM;;;;;AACN,SAAS,iBAAiB,KAAK;IAC3B,OAAO,CAAC,GAAG,oBAAoB,kBAAkB,EAAE,MAAM,KAAK,CAAC,KAAK,MAAM,CAAC,CAAC,UAAU,SAAS,OAAO;QAClG,8BAA8B;QAC9B,IAAI,CAAC,SAAS;YACV,OAAO;QACX;QACA,sBAAsB;QACtB,IAAI,CAAC,GAAG,SAAS,cAAc,EAAE,UAAU;YACvC,OAAO;QACX;QACA,iCAAiC;QACjC,IAAI,OAAO,CAAC,EAAE,KAAK,KAAK;YACpB,OAAO;QACX;QACA,uDAAuD;QACvD,IAAI,CAAC,YAAY,UAAU,YAAY,OAAO,KAAK,UAAU,SAAS,MAAM,GAAG,GAAG;YAC9E,OAAO;QACX;QACA,OAAO,WAAW,MAAM;IAC5B,GAAG;AACP;AACA,SAAS,gBAAgB,GAAG;IACxB,OAAO,IAAI,OAAO,CAAC,eACnB;AACJ,EAEA,qCAAqC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 133, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/lib/metadata/get-metadata-route.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    fillMetadataSegment: null,\n    normalizeMetadataPageToRoute: null,\n    normalizeMetadataRoute: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    fillMetadataSegment: function() {\n        return fillMetadataSegment;\n    },\n    normalizeMetadataPageToRoute: function() {\n        return normalizeMetadataPageToRoute;\n    },\n    normalizeMetadataRoute: function() {\n        return normalizeMetadataRoute;\n    }\n});\nconst _ismetadataroute = require(\"./is-metadata-route\");\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"../../shared/lib/isomorphic/path\"));\nconst _serverutils = require(\"../../server/server-utils\");\nconst _routeregex = require(\"../../shared/lib/router/utils/route-regex\");\nconst _hash = require(\"../../shared/lib/hash\");\nconst _apppaths = require(\"../../shared/lib/router/utils/app-paths\");\nconst _normalizepathsep = require(\"../../shared/lib/page-path/normalize-path-sep\");\nconst _segment = require(\"../../shared/lib/segment\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n/*\n * If there's special convention like (...) or @ in the page path,\n * Give it a unique hash suffix to avoid conflicts\n *\n * e.g.\n * /opengraph-image -> /opengraph-image\n * /(post)/opengraph-image.tsx -> /opengraph-image-[0-9a-z]{6}\n *\n * Sitemap is an exception, it should not have a suffix.\n * Each sitemap contains all the urls of sub routes, we don't have the case of duplicates `/(group)/sitemap.[ext]` and `/sitemap.[ext]` since they should be the same.\n * Hence we always normalize the urls for sitemap and do not append hash suffix, and ensure user-land only contains one sitemap per pathname.\n *\n * /sitemap -> /sitemap\n * /(post)/sitemap -> /sitemap\n */ function getMetadataRouteSuffix(page) {\n    // Remove the last segment and get the parent pathname\n    // e.g. /parent/a/b/c -> /parent/a/b\n    // e.g. /parent/opengraph-image -> /parent\n    const parentPathname = _path.default.dirname(page);\n    // Only apply suffix to metadata routes except for sitemaps\n    if (page.endsWith('/sitemap')) {\n        return '';\n    }\n    // Calculate the hash suffix based on the parent path\n    let suffix = '';\n    // Check if there's any special characters in the parent pathname.\n    const segments = parentPathname.split('/');\n    if (segments.some((seg)=>(0, _segment.isGroupSegment)(seg) || (0, _segment.isParallelRouteSegment)(seg))) {\n        // Hash the parent path to get a unique suffix\n        suffix = (0, _hash.djb2Hash)(parentPathname).toString(36).slice(0, 6);\n    }\n    return suffix;\n}\nfunction fillMetadataSegment(segment, params, lastSegment) {\n    const pathname = (0, _apppaths.normalizeAppPath)(segment);\n    const routeRegex = (0, _routeregex.getNamedRouteRegex)(pathname, {\n        prefixRouteKeys: false\n    });\n    const route = (0, _serverutils.interpolateDynamicPath)(pathname, params, routeRegex);\n    const { name, ext } = _path.default.parse(lastSegment);\n    const pagePath = _path.default.posix.join(segment, name);\n    const suffix = getMetadataRouteSuffix(pagePath);\n    const routeSuffix = suffix ? `-${suffix}` : '';\n    return (0, _normalizepathsep.normalizePathSep)(_path.default.join(route, `${name}${routeSuffix}${ext}`));\n}\nfunction normalizeMetadataRoute(page) {\n    if (!(0, _ismetadataroute.isMetadataPage)(page)) {\n        return page;\n    }\n    let route = page;\n    let suffix = '';\n    if (page === '/robots') {\n        route += '.txt';\n    } else if (page === '/manifest') {\n        route += '.webmanifest';\n    } else {\n        suffix = getMetadataRouteSuffix(page);\n    }\n    // Support both /<metadata-route.ext> and custom routes /<metadata-route>/route.ts.\n    // If it's a metadata file route, we need to append /[id]/route to the page.\n    if (!route.endsWith('/route')) {\n        const { dir, name: baseName, ext } = _path.default.parse(route);\n        route = _path.default.posix.join(dir, `${baseName}${suffix ? `-${suffix}` : ''}${ext}`, 'route');\n    }\n    return route;\n}\nfunction normalizeMetadataPageToRoute(page, isDynamic) {\n    const isRoute = page.endsWith('/route');\n    const routePagePath = isRoute ? page.slice(0, -'/route'.length) : page;\n    const metadataRouteExtension = routePagePath.endsWith('/sitemap') ? '.xml' : '';\n    const mapped = isDynamic ? `${routePagePath}/[__metadata_id__]` : `${routePagePath}${metadataRouteExtension}`;\n    return mapped + (isRoute ? '/route' : '');\n}\n\n//# sourceMappingURL=get-metadata-route.js.map"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 272, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/dist/src/server/route-kind.ts"],"sourcesContent":["export const enum RouteKind {\n  /**\n   * `PAGES` represents all the React pages that are under `pages/`.\n   */\n  PAGES = 'PAGES',\n  /**\n   * `PAGES_API` represents all the API routes under `pages/api/`.\n   */\n  PAGES_API = 'PAGES_API',\n  /**\n   * `APP_PAGE` represents all the React pages that are under `app/` with the\n   * filename of `page.{j,t}s{,x}`.\n   */\n  APP_PAGE = 'APP_PAGE',\n  /**\n   * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the\n   * filename of `route.{j,t}s{,x}`.\n   */\n  APP_ROUTE = 'APP_ROUTE',\n\n  /**\n   * `IMAGE` represents all the images that are generated by `next/image`.\n   */\n  IMAGE = 'IMAGE',\n}\n"],"names":["RouteKind"],"mappings":";;;;AAAO,IAAWA,YAAAA,WAAAA,GAAAA,SAAAA,SAAAA;IAChB;;GAEC,GAAA,SAAA,CAAA,QAAA,GAAA;IAED;;GAEC,GAAA,SAAA,CAAA,YAAA,GAAA;IAED;;;GAGC,GAAA,SAAA,CAAA,WAAA,GAAA;IAED;;;GAGC,GAAA,SAAA,CAAA,YAAA,GAAA;IAGD;;GAEC,GAAA,SAAA,CAAA,QAAA,GAAA;WAtBeA;MAwBjB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 300, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/server/route-modules/app-page/module.compiled.js"],"sourcesContent":["if (process.env.NEXT_RUNTIME === 'edge') {\n  module.exports = require('next/dist/server/route-modules/app-page/module.js')\n} else {\n  if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.prod.js')\n      }\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.prod.js')\n      }\n    }\n  }\n}\n"],"names":["process","env","NEXT_RUNTIME","module","exports","require","__NEXT_EXPERIMENTAL_REACT","NODE_ENV","TURBOPACK"],"mappings":"AAAA,IAAIA,QAAQC,GAAG,CAACC,YAAY,KAAK,QAAQ;;KAElC;IACL,IAAIF,QAAQC,GAAG,CAACK,yBAAyB,EAAE;;SAcpC;QACL,IAAIN,QAAQC,GAAG,CAACM,QAAQ,KAAK,WAAe;YAC1C,IAAIP,QAAQC,GAAG,CAACO,SAAS,eAAE;gBACzBL,OAAOC,OAAO,GAAGC,QAAQ;YAC3B,OAAO;;QAGT,OAAO;;IAOT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 319, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.ts"],"sourcesContent":["module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-rsc']!.ReactServerDOMTurbopackServer\n"],"names":["module","exports","require","vendored","ReactServerDOMTurbopackServer"],"mappings":"AAAAA,OAAOC,OAAO,GACZC,QAAQ,sKACRC,QAAQ,CAAC,YAAY,CAAEC,6BAA6B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 324, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-static.ts"],"sourcesContent":["module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-rsc']!.ReactServerDOMTurbopackStatic\n"],"names":["module","exports","require","vendored","ReactServerDOMTurbopackStatic"],"mappings":"AAAAA,OAAOC,OAAO,GACZC,QAAQ,sKACRC,QAAQ,CAAC,YAAY,CAAEC,6BAA6B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 329, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/server/route-modules/app-page/vendored/rsc/react.ts"],"sourcesContent":["module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-rsc']!.React\n"],"names":["module","exports","require","vendored","React"],"mappings":"AAAAA,OAAOC,OAAO,GACZC,QAAQ,sKACRC,QAAQ,CAAC,YAAY,CAAEC,KAAK","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 333, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/esm/client/components/client-page.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/esm/client/components/client-page.js <module evaluation>\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 339, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/esm/client/components/client-page.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/esm/client/components/client-page.js\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 346, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 353, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/esm/client/components/client-segment.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/esm/client/components/client-segment.js <module evaluation>\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 359, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/esm/client/components/client-segment.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/esm/client/components/client-segment.js\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 366, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 373, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/esm/client/components/http-access-fallback/error-boundary.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/esm/client/components/http-access-fallback/error-boundary.js <module evaluation>\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 379, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/esm/client/components/http-access-fallback/error-boundary.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/esm/client/components/http-access-fallback/error-boundary.js\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 386, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 393, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/esm/lib/framework/boundary-components.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/esm/lib/framework/boundary-components.js <module evaluation>\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 399, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/esm/lib/framework/boundary-components.js/__nextjs-internal-proxy.cjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/esm/lib/framework/boundary-components.js\"));\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,MAAM,EAAE,uBAAuB,EAAE;AAEjC,sBAAsB,CAAC,CAAC,wBAAwB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 406, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 414, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/server/route-modules/app-page/vendored/rsc/react-jsx-runtime.ts"],"sourcesContent":["module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-rsc']!.ReactJsxRuntime\n"],"names":["module","exports","require","vendored","ReactJsxRuntime"],"mappings":"AAAAA,OAAOC,OAAO,GACZC,QAAQ,sKACRC,QAAQ,CAAC,YAAY,CAAEC,eAAe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 419, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/compiled/react-server-dom-turbopack/client.node.js"],"sourcesContent":["'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-server-dom-turbopack-client.node.production.js');\n} else {\n  module.exports = require('./cjs/react-server-dom-turbopack-client.node.development.js');\n}\n"],"names":[],"mappings":"AAEA;;KAEO;IACL,OAAO,OAAO;;;;;AAChB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 431, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/dist/compiled/string-hash/index.js"],"sourcesContent":["(()=>{\"use strict\";var e={328:e=>{function hash(e){var r=5381,_=e.length;while(_){r=r*33^e.charCodeAt(--_)}return r>>>0}e.exports=hash}};var r={};function __nccwpck_require__(_){var a=r[_];if(a!==undefined){return a.exports}var t=r[_]={exports:{}};var i=true;try{e[_](t,t.exports,__nccwpck_require__);i=false}finally{if(i)delete r[_]}return t.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var _=__nccwpck_require__(328);module.exports=_})();"],"names":[],"mappings":"AAAA,CAAC;IAAK;IAAa,IAAI,IAAE;QAAC,KAAI,CAAA;YAAI,SAAS,KAAK,CAAC;gBAAE,IAAI,IAAE,MAAK,IAAE,EAAE,MAAM;gBAAC,MAAM,EAAE;oBAAC,IAAE,IAAE,KAAG,EAAE,UAAU,CAAC,EAAE;gBAAE;gBAAC,OAAO,MAAI;YAAC;YAAC,EAAE,OAAO,GAAC;QAAI;IAAC;IAAE,IAAI,IAAE,CAAC;IAAE,SAAS,oBAAoB,CAAC;QAAE,IAAI,IAAE,CAAC,CAAC,EAAE;QAAC,IAAG,MAAI,WAAU;YAAC,OAAO,EAAE,OAAO;QAAA;QAAC,IAAI,IAAE,CAAC,CAAC,EAAE,GAAC;YAAC,SAAQ,CAAC;QAAC;QAAE,IAAI,IAAE;QAAK,IAAG;YAAC,CAAC,CAAC,EAAE,CAAC,GAAE,EAAE,OAAO,EAAC;YAAqB,IAAE;QAAK,SAAQ;YAAC,IAAG,GAAE,OAAO,CAAC,CAAC,EAAE;QAAA;QAAC,OAAO,EAAE,OAAO;IAAA;IAAC,IAAG,OAAO,wBAAsB,aAAY,oBAAoB,EAAE,GAAC,kIAAU;IAAI,IAAI,IAAE,oBAAoB;IAAK,OAAO,OAAO,GAAC;AAAC,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 471, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/esm/lib/format-server-error.js"],"sourcesContent":["const invalidServerComponentReactHooks = [\n    'useDeferredValue',\n    'useEffect',\n    'useImperativeHandle',\n    'useInsertionEffect',\n    'useLayoutEffect',\n    'useReducer',\n    'useRef',\n    'useState',\n    'useSyncExternalStore',\n    'useTransition',\n    'experimental_useOptimistic',\n    'useOptimistic'\n];\nfunction setMessage(error, message) {\n    error.message = message;\n    if (error.stack) {\n        const lines = error.stack.split('\\n');\n        lines[0] = message;\n        error.stack = lines.join('\\n');\n    }\n}\n/**\n * Input:\n * Error: Something went wrong\n    at funcName (/path/to/file.js:10:5)\n    at anotherFunc (/path/to/file.js:15:10)\n \n * Output:\n    at funcName (/path/to/file.js:10:5)\n    at anotherFunc (/path/to/file.js:15:10) \n */ export function getStackWithoutErrorMessage(error) {\n    const stack = error.stack;\n    if (!stack) return '';\n    return stack.replace(/^[^\\n]*\\n/, '');\n}\nexport function formatServerError(error) {\n    if (typeof (error == null ? void 0 : error.message) !== 'string') return;\n    if (error.message.includes('Class extends value undefined is not a constructor or null')) {\n        const addedMessage = 'This might be caused by a React Class Component being rendered in a Server Component, React Class Components only works in Client Components. Read more: https://nextjs.org/docs/messages/class-component-in-server-component';\n        // If this error instance already has the message, don't add it again\n        if (error.message.includes(addedMessage)) return;\n        setMessage(error, `${error.message}\n\n${addedMessage}`);\n        return;\n    }\n    if (error.message.includes('createContext is not a function')) {\n        setMessage(error, 'createContext only works in Client Components. Add the \"use client\" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/context-in-server-component');\n        return;\n    }\n    for (const clientHook of invalidServerComponentReactHooks){\n        const regex = new RegExp(`\\\\b${clientHook}\\\\b.*is not a function`);\n        if (regex.test(error.message)) {\n            setMessage(error, `${clientHook} only works in Client Components. Add the \"use client\" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/react-client-hook-in-server-component`);\n            return;\n        }\n    }\n}\n\n//# sourceMappingURL=format-server-error.js.map"],"names":[],"mappings":";;;;;;AAAA,MAAM,mCAAmC;IACrC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACH;AACD,SAAS,WAAW,KAAK,EAAE,OAAO;IAC9B,MAAM,OAAO,GAAG;IAChB,IAAI,MAAM,KAAK,EAAE;QACb,MAAM,QAAQ,MAAM,KAAK,CAAC,KAAK,CAAC;QAChC,KAAK,CAAC,EAAE,GAAG;QACX,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC;IAC7B;AACJ;AAUW,SAAS,4BAA4B,KAAK;IACjD,MAAM,QAAQ,MAAM,KAAK;IACzB,IAAI,CAAC,OAAO,OAAO;IACnB,OAAO,MAAM,OAAO,CAAC,aAAa;AACtC;AACO,SAAS,kBAAkB,KAAK;IACnC,IAAI,OAAO,CAAC,SAAS,OAAO,KAAK,IAAI,MAAM,OAAO,MAAM,UAAU;IAClE,IAAI,MAAM,OAAO,CAAC,QAAQ,CAAC,+DAA+D;QACtF,MAAM,eAAe;QACrB,qEAAqE;QACrE,IAAI,MAAM,OAAO,CAAC,QAAQ,CAAC,eAAe;QAC1C,WAAW,OAAO,GAAG,MAAM,OAAO,CAAC;;AAE3C,EAAE,cAAc;QACR;IACJ;IACA,IAAI,MAAM,OAAO,CAAC,QAAQ,CAAC,oCAAoC;QAC3D,WAAW,OAAO;QAClB;IACJ;IACA,KAAK,MAAM,cAAc,iCAAiC;QACtD,MAAM,QAAQ,IAAI,OAAO,CAAC,GAAG,EAAE,WAAW,sBAAsB,CAAC;QACjE,IAAI,MAAM,IAAI,CAAC,MAAM,OAAO,GAAG;YAC3B,WAAW,OAAO,GAAG,WAAW,oLAAoL,CAAC;YACrN;QACJ;IACJ;AACJ,EAEA,+CAA+C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 531, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/esm/shared/lib/lazy-dynamic/bailout-to-csr.js"],"sourcesContent":["// This has to be a shared module which is shared between client component error boundary and dynamic component\nconst BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING';\n/** An error that should be thrown when we want to bail out to client-side rendering. */ export class BailoutToCSRError extends Error {\n    constructor(reason){\n        super(\"Bail out to client-side rendering: \" + reason), this.reason = reason, this.digest = BAILOUT_TO_CSR;\n    }\n}\n/** Checks if a passed argument is an error that is thrown if we want to bail out to client-side rendering. */ export function isBailoutToCSRError(err) {\n    if (typeof err !== 'object' || err === null || !('digest' in err)) {\n        return false;\n    }\n    return err.digest === BAILOUT_TO_CSR;\n}\n\n//# sourceMappingURL=bailout-to-csr.js.map"],"names":[],"mappings":"AAAA,+GAA+G;;;;;;;AAC/G,MAAM,iBAAiB;AACyE,MAAM,0BAA0B;IAC5H,YAAY,MAAM,CAAC;QACf,KAAK,CAAC,wCAAwC,SAAS,IAAI,CAAC,MAAM,GAAG,QAAQ,IAAI,CAAC,MAAM,GAAG;IAC/F;AACJ;AACsH,SAAS,oBAAoB,GAAG;IAClJ,IAAI,OAAO,QAAQ,YAAY,QAAQ,QAAQ,CAAC,CAAC,YAAY,GAAG,GAAG;QAC/D,OAAO;IACX;IACA,OAAO,IAAI,MAAM,KAAK;AAC1B,EAEA,0CAA0C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 554, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/esm/server/dynamic-rendering-utils.js"],"sourcesContent":["export function isHangingPromiseRejectionError(err) {\n    if (typeof err !== 'object' || err === null || !('digest' in err)) {\n        return false;\n    }\n    return err.digest === HANGING_PROMISE_REJECTION;\n}\nconst HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION';\nclass HangingPromiseRejectionError extends Error {\n    constructor(route, expression){\n        super(`During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`after\\`, or similar functions you may observe this error and you should handle it in that context. This occurred at route \"${route}\".`), this.route = route, this.expression = expression, this.digest = HANGING_PROMISE_REJECTION;\n    }\n}\nconst abortListenersBySignal = new WeakMap();\n/**\n * This function constructs a promise that will never resolve. This is primarily\n * useful for cacheComponents where we use promise resolution timing to determine which\n * parts of a render can be included in a prerender.\n *\n * @internal\n */ export function makeHangingPromise(signal, route, expression) {\n    if (signal.aborted) {\n        return Promise.reject(new HangingPromiseRejectionError(route, expression));\n    } else {\n        const hangingPromise = new Promise((_, reject)=>{\n            const boundRejection = reject.bind(null, new HangingPromiseRejectionError(route, expression));\n            let currentListeners = abortListenersBySignal.get(signal);\n            if (currentListeners) {\n                currentListeners.push(boundRejection);\n            } else {\n                const listeners = [\n                    boundRejection\n                ];\n                abortListenersBySignal.set(signal, listeners);\n                signal.addEventListener('abort', ()=>{\n                    for(let i = 0; i < listeners.length; i++){\n                        listeners[i]();\n                    }\n                }, {\n                    once: true\n                });\n            }\n        });\n        // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n        // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n        // your own promise out of it you'll need to ensure you handle the error when it rejects.\n        hangingPromise.catch(ignoreReject);\n        return hangingPromise;\n    }\n}\nfunction ignoreReject() {}\nexport function makeDevtoolsIOAwarePromise(underlying) {\n    // in React DevTools if we resolve in a setTimeout we will observe\n    // the promise resolution as something that can suspend a boundary or root.\n    return new Promise((resolve)=>{\n        // Must use setTimeout to be considered IO React DevTools. setImmediate will not work.\n        setTimeout(()=>{\n            resolve(underlying);\n        }, 0);\n    });\n}\n\n//# sourceMappingURL=dynamic-rendering-utils.js.map"],"names":[],"mappings":";;;;;;;;AAAO,SAAS,+BAA+B,GAAG;IAC9C,IAAI,OAAO,QAAQ,YAAY,QAAQ,QAAQ,CAAC,CAAC,YAAY,GAAG,GAAG;QAC/D,OAAO;IACX;IACA,OAAO,IAAI,MAAM,KAAK;AAC1B;AACA,MAAM,4BAA4B;AAClC,MAAM,qCAAqC;IACvC,YAAY,KAAK,EAAE,UAAU,CAAC;QAC1B,KAAK,CAAC,CAAC,qBAAqB,EAAE,WAAW,qGAAqG,EAAE,WAAW,8KAA8K,EAAE,MAAM,EAAE,CAAC,GAAG,IAAI,CAAC,KAAK,GAAG,OAAO,IAAI,CAAC,UAAU,GAAG,YAAY,IAAI,CAAC,MAAM,GAAG;IAC3Z;AACJ;AACA,MAAM,yBAAyB,IAAI;AAOxB,SAAS,mBAAmB,MAAM,EAAE,KAAK,EAAE,UAAU;IAC5D,IAAI,OAAO,OAAO,EAAE;QAChB,OAAO,QAAQ,MAAM,CAAC,IAAI,6BAA6B,OAAO;IAClE,OAAO;QACH,MAAM,iBAAiB,IAAI,QAAQ,CAAC,GAAG;YACnC,MAAM,iBAAiB,OAAO,IAAI,CAAC,MAAM,IAAI,6BAA6B,OAAO;YACjF,IAAI,mBAAmB,uBAAuB,GAAG,CAAC;YAClD,IAAI,kBAAkB;gBAClB,iBAAiB,IAAI,CAAC;YAC1B,OAAO;gBACH,MAAM,YAAY;oBACd;iBACH;gBACD,uBAAuB,GAAG,CAAC,QAAQ;gBACnC,OAAO,gBAAgB,CAAC,SAAS;oBAC7B,IAAI,IAAI,IAAI,GAAG,IAAI,UAAU,MAAM,EAAE,IAAI;wBACrC,SAAS,CAAC,EAAE;oBAChB;gBACJ,GAAG;oBACC,MAAM;gBACV;YACJ;QACJ;QACA,2GAA2G;QAC3G,6GAA6G;QAC7G,yFAAyF;QACzF,eAAe,KAAK,CAAC;QACrB,OAAO;IACX;AACJ;AACA,SAAS,gBAAgB;AAClB,SAAS,2BAA2B,UAAU;IACjD,kEAAkE;IAClE,2EAA2E;IAC3E,OAAO,IAAI,QAAQ,CAAC;QAChB,sFAAsF;QACtF,WAAW;YACP,QAAQ;QACZ,GAAG;IACP;AACJ,EAEA,mDAAmD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 620, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/esm/lib/framework/boundary-constants.js"],"sourcesContent":["export const METADATA_BOUNDARY_NAME = '__next_metadata_boundary__';\nexport const VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__';\nexport const OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__';\nexport const ROOT_LAYOUT_BOUNDARY_NAME = '__next_root_layout_boundary__';\n\n//# sourceMappingURL=boundary-constants.js.map"],"names":[],"mappings":";;;;;;;;;;AAAO,MAAM,yBAAyB;AAC/B,MAAM,yBAAyB;AAC/B,MAAM,uBAAuB;AAC7B,MAAM,4BAA4B,iCAEzC,8CAA8C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 638, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/esm/server/app-render/dynamic-rendering.js"],"sourcesContent":["/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */ // Once postpone is in stable we should switch to importing the postpone export directly\nimport React from 'react';\nimport { DynamicServerError } from '../../client/components/hooks-server-context';\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout';\nimport { getRuntimeStagePromise, workUnitAsyncStorage } from './work-unit-async-storage.external';\nimport { workAsyncStorage } from '../app-render/work-async-storage.external';\nimport { makeHangingPromise } from '../dynamic-rendering-utils';\nimport { METADATA_BOUNDARY_NAME, VIEWPORT_BOUNDARY_NAME, OUTLET_BOUNDARY_NAME, ROOT_LAYOUT_BOUNDARY_NAME } from '../../lib/framework/boundary-constants';\nimport { scheduleOnNextTick } from '../../lib/scheduler';\nimport { BailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr';\nimport { InvariantError } from '../../shared/lib/invariant-error';\nconst hasPostpone = typeof React.unstable_postpone === 'function';\nexport function createDynamicTrackingState(isDebugDynamicAccesses) {\n    return {\n        isDebugDynamicAccesses,\n        dynamicAccesses: [],\n        syncDynamicErrorWithStack: null\n    };\n}\nexport function createDynamicValidationState() {\n    return {\n        hasSuspenseAboveBody: false,\n        hasDynamicMetadata: false,\n        hasDynamicViewport: false,\n        hasAllowedDynamic: false,\n        dynamicErrors: []\n    };\n}\nexport function getFirstDynamicReason(trackingState) {\n    var _trackingState_dynamicAccesses_;\n    return (_trackingState_dynamicAccesses_ = trackingState.dynamicAccesses[0]) == null ? void 0 : _trackingState_dynamicAccesses_.expression;\n}\n/**\n * This function communicates that the current scope should be treated as dynamic.\n *\n * In most cases this function is a no-op but if called during\n * a PPR prerender it will postpone the current sub-tree and calling\n * it during a normal prerender will cause the entire prerender to abort\n */ export function markCurrentScopeAsDynamic(store, workUnitStore, expression) {\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'cache':\n            case 'unstable-cache':\n                // Inside cache scopes, marking a scope as dynamic has no effect,\n                // because the outer cache scope creates a cache boundary. This is\n                // subtly different from reading a dynamic data source, which is\n                // forbidden inside a cache scope.\n                return;\n            case 'private-cache':\n                // A private cache scope is already dynamic by definition.\n                return;\n            case 'prerender-legacy':\n            case 'prerender-ppr':\n            case 'request':\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n    // If we're forcing dynamic rendering or we're forcing static rendering, we\n    // don't need to do anything here because the entire page is already dynamic\n    // or it's static and it should not throw or postpone here.\n    if (store.forceDynamic || store.forceStatic) return;\n    if (store.dynamicShouldError) {\n        throw Object.defineProperty(new StaticGenBailoutError(`Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n            value: \"E553\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender-ppr':\n                return postponeWithTracking(store.route, expression, workUnitStore.dynamicTracking);\n            case 'prerender-legacy':\n                workUnitStore.revalidate = 0;\n                // We aren't prerendering, but we are generating a static page. We need\n                // to bail out of static generation.\n                const err = Object.defineProperty(new DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E550\",\n                    enumerable: false,\n                    configurable: true\n                });\n                store.dynamicUsageDescription = expression;\n                store.dynamicUsageStack = err.stack;\n                throw err;\n            case 'request':\n                if (process.env.NODE_ENV !== 'production') {\n                    workUnitStore.usedDynamic = true;\n                }\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n}\n/**\n * This function is meant to be used when prerendering without cacheComponents or PPR.\n * When called during a build it will cause Next.js to consider the route as dynamic.\n *\n * @internal\n */ export function throwToInterruptStaticGeneration(expression, store, prerenderStore) {\n    // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n    const err = Object.defineProperty(new DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), \"__NEXT_ERROR_CODE\", {\n        value: \"E558\",\n        enumerable: false,\n        configurable: true\n    });\n    prerenderStore.revalidate = 0;\n    store.dynamicUsageDescription = expression;\n    store.dynamicUsageStack = err.stack;\n    throw err;\n}\n/**\n * This function should be used to track whether something dynamic happened even when\n * we are in a dynamic render. This is useful for Dev where all renders are dynamic but\n * we still track whether dynamic APIs were accessed for helpful messaging\n *\n * @internal\n */ export function trackDynamicDataInDynamicRender(workUnitStore) {\n    switch(workUnitStore.type){\n        case 'cache':\n        case 'unstable-cache':\n            // Inside cache scopes, marking a scope as dynamic has no effect,\n            // because the outer cache scope creates a cache boundary. This is\n            // subtly different from reading a dynamic data source, which is\n            // forbidden inside a cache scope.\n            return;\n        case 'private-cache':\n            // A private cache scope is already dynamic by definition.\n            return;\n        case 'prerender':\n        case 'prerender-runtime':\n        case 'prerender-legacy':\n        case 'prerender-ppr':\n        case 'prerender-client':\n            break;\n        case 'request':\n            if (process.env.NODE_ENV !== 'production') {\n                workUnitStore.usedDynamic = true;\n            }\n            break;\n        default:\n            workUnitStore;\n    }\n}\nfunction abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore) {\n    const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`;\n    const error = createPrerenderInterruptedError(reason);\n    prerenderStore.controller.abort(error);\n    const dynamicTracking = prerenderStore.dynamicTracking;\n    if (dynamicTracking) {\n        dynamicTracking.dynamicAccesses.push({\n            // When we aren't debugging, we don't need to create another error for the\n            // stack trace.\n            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,\n            expression\n        });\n    }\n}\nexport function abortOnSynchronousPlatformIOAccess(route, expression, errorWithStack, prerenderStore) {\n    const dynamicTracking = prerenderStore.dynamicTracking;\n    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);\n    // It is important that we set this tracking value after aborting. Aborts are executed\n    // synchronously except for the case where you abort during render itself. By setting this\n    // value late we can use it to determine if any of the aborted tasks are the task that\n    // called the sync IO expression in the first place.\n    if (dynamicTracking) {\n        if (dynamicTracking.syncDynamicErrorWithStack === null) {\n            dynamicTracking.syncDynamicErrorWithStack = errorWithStack;\n        }\n    }\n}\nexport function trackSynchronousPlatformIOAccessInDev(requestStore) {\n    // We don't actually have a controller to abort but we do the semantic equivalent by\n    // advancing the request store out of prerender mode\n    requestStore.prerenderPhase = false;\n}\n/**\n * use this function when prerendering with cacheComponents. If we are doing a\n * prospective prerender we don't actually abort because we want to discover\n * all caches for the shell. If this is the actual prerender we do abort.\n *\n * This function accepts a prerenderStore but the caller should ensure we're\n * actually running in cacheComponents mode.\n *\n * @internal\n */ export function abortAndThrowOnSynchronousRequestDataAccess(route, expression, errorWithStack, prerenderStore) {\n    const prerenderSignal = prerenderStore.controller.signal;\n    if (prerenderSignal.aborted === false) {\n        // TODO it would be better to move this aborted check into the callsite so we can avoid making\n        // the error object when it isn't relevant to the aborting of the prerender however\n        // since we need the throw semantics regardless of whether we abort it is easier to land\n        // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer\n        // to ideal implementation\n        abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);\n        // It is important that we set this tracking value after aborting. Aborts are executed\n        // synchronously except for the case where you abort during render itself. By setting this\n        // value late we can use it to determine if any of the aborted tasks are the task that\n        // called the sync IO expression in the first place.\n        const dynamicTracking = prerenderStore.dynamicTracking;\n        if (dynamicTracking) {\n            if (dynamicTracking.syncDynamicErrorWithStack === null) {\n                dynamicTracking.syncDynamicErrorWithStack = errorWithStack;\n            }\n        }\n    }\n    throw createPrerenderInterruptedError(`Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`);\n}\n/**\n * Use this function when dynamically prerendering with dynamicIO.\n * We don't want to error, because it's better to return something\n * (and we've already aborted the render at the point where the sync dynamic error occured),\n * but we should log an error server-side.\n * @internal\n */ export function warnOnSyncDynamicError(dynamicTracking) {\n    if (dynamicTracking.syncDynamicErrorWithStack) {\n        // the server did something sync dynamic, likely\n        // leading to an early termination of the prerender.\n        console.error(dynamicTracking.syncDynamicErrorWithStack);\n    }\n}\n// For now these implementations are the same so we just reexport\nexport const trackSynchronousRequestDataAccessInDev = trackSynchronousPlatformIOAccessInDev;\nexport function Postpone({ reason, route }) {\n    const prerenderStore = workUnitAsyncStorage.getStore();\n    const dynamicTracking = prerenderStore && prerenderStore.type === 'prerender-ppr' ? prerenderStore.dynamicTracking : null;\n    postponeWithTracking(route, reason, dynamicTracking);\n}\nexport function postponeWithTracking(route, expression, dynamicTracking) {\n    assertPostpone();\n    if (dynamicTracking) {\n        dynamicTracking.dynamicAccesses.push({\n            // When we aren't debugging, we don't need to create another error for the\n            // stack trace.\n            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,\n            expression\n        });\n    }\n    React.unstable_postpone(createPostponeReason(route, expression));\n}\nfunction createPostponeReason(route, expression) {\n    return `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` + `React throws this special object to indicate where. It should not be caught by ` + `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`;\n}\nexport function isDynamicPostpone(err) {\n    if (typeof err === 'object' && err !== null && typeof err.message === 'string') {\n        return isDynamicPostponeReason(err.message);\n    }\n    return false;\n}\nfunction isDynamicPostponeReason(reason) {\n    return reason.includes('needs to bail out of prerendering at this point because it used') && reason.includes('Learn more: https://nextjs.org/docs/messages/ppr-caught-error');\n}\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\n    throw Object.defineProperty(new Error('Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'), \"__NEXT_ERROR_CODE\", {\n        value: \"E296\",\n        enumerable: false,\n        configurable: true\n    });\n}\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED';\nfunction createPrerenderInterruptedError(message) {\n    const error = Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    error.digest = NEXT_PRERENDER_INTERRUPTED;\n    return error;\n}\nexport function isPrerenderInterruptedError(error) {\n    return typeof error === 'object' && error !== null && error.digest === NEXT_PRERENDER_INTERRUPTED && 'name' in error && 'message' in error && error instanceof Error;\n}\nexport function accessedDynamicData(dynamicAccesses) {\n    return dynamicAccesses.length > 0;\n}\nexport function consumeDynamicAccess(serverDynamic, clientDynamic) {\n    // We mutate because we only call this once we are no longer writing\n    // to the dynamicTrackingState and it's more efficient than creating a new\n    // array.\n    serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses);\n    return serverDynamic.dynamicAccesses;\n}\nexport function formatDynamicAPIAccesses(dynamicAccesses) {\n    return dynamicAccesses.filter((access)=>typeof access.stack === 'string' && access.stack.length > 0).map(({ expression, stack })=>{\n        stack = stack.split('\\n')// Remove the \"Error: \" prefix from the first line of the stack trace as\n        // well as the first 4 lines of the stack trace which is the distance\n        // from the user code and the `new Error().stack` call.\n        .slice(4).filter((line)=>{\n            // Exclude Next.js internals from the stack trace.\n            if (line.includes('node_modules/next/')) {\n                return false;\n            }\n            // Exclude anonymous functions from the stack trace.\n            if (line.includes(' (<anonymous>)')) {\n                return false;\n            }\n            // Exclude Node.js internals from the stack trace.\n            if (line.includes(' (node:')) {\n                return false;\n            }\n            return true;\n        }).join('\\n');\n        return `Dynamic API Usage Debug - ${expression}:\\n${stack}`;\n    });\n}\nfunction assertPostpone() {\n    if (!hasPostpone) {\n        throw Object.defineProperty(new Error(`Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`), \"__NEXT_ERROR_CODE\", {\n            value: \"E224\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n}\n/**\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\n * abort semantics slightly.\n */ export function createRenderInBrowserAbortSignal() {\n    const controller = new AbortController();\n    controller.abort(Object.defineProperty(new BailoutToCSRError('Render in Browser'), \"__NEXT_ERROR_CODE\", {\n        value: \"E721\",\n        enumerable: false,\n        configurable: true\n    }));\n    return controller.signal;\n}\n/**\n * In a prerender, we may end up with hanging Promises as inputs due them\n * stalling on connection() or because they're loading dynamic data. In that\n * case we need to abort the encoding of arguments since they'll never complete.\n */ export function createHangingInputAbortSignal(workUnitStore) {\n    switch(workUnitStore.type){\n        case 'prerender':\n        case 'prerender-runtime':\n            const controller = new AbortController();\n            if (workUnitStore.cacheSignal) {\n                // If we have a cacheSignal it means we're in a prospective render. If\n                // the input we're waiting on is coming from another cache, we do want\n                // to wait for it so that we can resolve this cache entry too.\n                workUnitStore.cacheSignal.inputReady().then(()=>{\n                    controller.abort();\n                });\n            } else {\n                // Otherwise we're in the final render and we should already have all\n                // our caches filled.\n                // If the prerender uses stages, we have wait until the runtime stage,\n                // at which point all runtime inputs will be resolved.\n                // (otherwise, a runtime prerender might consider `cookies()` hanging\n                //  even though they'd resolve in the next task.)\n                //\n                // We might still be waiting on some microtasks so we\n                // wait one tick before giving up. When we give up, we still want to\n                // render the content of this cache as deeply as we can so that we can\n                // suspend as deeply as possible in the tree or not at all if we don't\n                // end up waiting for the input.\n                const runtimeStagePromise = getRuntimeStagePromise(workUnitStore);\n                if (runtimeStagePromise) {\n                    runtimeStagePromise.then(()=>scheduleOnNextTick(()=>controller.abort()));\n                } else {\n                    scheduleOnNextTick(()=>controller.abort());\n                }\n            }\n            return controller.signal;\n        case 'prerender-client':\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n        case 'request':\n        case 'cache':\n        case 'private-cache':\n        case 'unstable-cache':\n            return undefined;\n        default:\n            workUnitStore;\n    }\n}\nexport function annotateDynamicAccess(expression, prerenderStore) {\n    const dynamicTracking = prerenderStore.dynamicTracking;\n    if (dynamicTracking) {\n        dynamicTracking.dynamicAccesses.push({\n            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,\n            expression\n        });\n    }\n}\nexport function useDynamicRouteParams(expression) {\n    const workStore = workAsyncStorage.getStore();\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workStore && workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender-client':\n            case 'prerender':\n                {\n                    const fallbackParams = workUnitStore.fallbackRouteParams;\n                    if (fallbackParams && fallbackParams.size > 0) {\n                        // We are in a prerender with cacheComponents semantics. We are going to\n                        // hang here and never resolve. This will cause the currently\n                        // rendering component to effectively be a dynamic hole.\n                        React.use(makeHangingPromise(workUnitStore.renderSignal, workStore.route, expression));\n                    }\n                    break;\n                }\n            case 'prerender-ppr':\n                {\n                    const fallbackParams = workUnitStore.fallbackRouteParams;\n                    if (fallbackParams && fallbackParams.size > 0) {\n                        return postponeWithTracking(workStore.route, expression, workUnitStore.dynamicTracking);\n                    }\n                    break;\n                }\n            case 'prerender-runtime':\n                throw Object.defineProperty(new InvariantError(`\\`${expression}\\` was called during a runtime prerender. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E771\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'cache':\n            case 'private-cache':\n                throw Object.defineProperty(new InvariantError(`\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E745\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'prerender-legacy':\n            case 'request':\n            case 'unstable-cache':\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n}\nconst hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/;\n// Common implicit body tags that React will treat as body when placed directly in html\nconst bodyAndImplicitTags = 'body|div|main|section|article|aside|header|footer|nav|form|p|span|h1|h2|h3|h4|h5|h6';\n// Detects when RootLayoutBoundary (our framework marker component) appears\n// after Suspense in the component stack, indicating the root layout is wrapped\n// within a Suspense boundary. Ensures no body/html/implicit-body components are in between.\n//\n// Example matches:\n//   at Suspense (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\n//\n// Or with other components in between (but not body/html/implicit-body):\n//   at Suspense (<anonymous>)\n//   at SomeComponent (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\nconst hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex = new RegExp(`\\\\n\\\\s+at Suspense \\\\(<anonymous>\\\\)(?:(?!\\\\n\\\\s+at (?:${bodyAndImplicitTags}) \\\\(<anonymous>\\\\))[\\\\s\\\\S])*?\\\\n\\\\s+at ${ROOT_LAYOUT_BOUNDARY_NAME} \\\\([^\\\\n]*\\\\)`);\nconst hasMetadataRegex = new RegExp(`\\\\n\\\\s+at ${METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`);\nconst hasViewportRegex = new RegExp(`\\\\n\\\\s+at ${VIEWPORT_BOUNDARY_NAME}[\\\\n\\\\s]`);\nconst hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`);\nexport function trackAllowedDynamicAccess(workStore, componentStack, dynamicValidation, clientDynamic) {\n    if (hasOutletRegex.test(componentStack)) {\n        // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n        return;\n    } else if (hasMetadataRegex.test(componentStack)) {\n        dynamicValidation.hasDynamicMetadata = true;\n        return;\n    } else if (hasViewportRegex.test(componentStack)) {\n        dynamicValidation.hasDynamicViewport = true;\n        return;\n    } else if (hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(componentStack)) {\n        // For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.\n        // But if you have Suspense above body, the prelude is empty but we allow that because having Suspense\n        // is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.\n        dynamicValidation.hasAllowedDynamic = true;\n        dynamicValidation.hasSuspenseAboveBody = true;\n        return;\n    } else if (hasSuspenseRegex.test(componentStack)) {\n        // this error had a Suspense boundary above it so we don't need to report it as a source\n        // of disallowed\n        dynamicValidation.hasAllowedDynamic = true;\n        return;\n    } else if (clientDynamic.syncDynamicErrorWithStack) {\n        // This task was the task that called the sync error.\n        dynamicValidation.dynamicErrors.push(clientDynamic.syncDynamicErrorWithStack);\n        return;\n    } else {\n        const message = `Route \"${workStore.route}\": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a \"use cache\" above it. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`;\n        const error = createErrorWithComponentOrOwnerStack(message, componentStack);\n        dynamicValidation.dynamicErrors.push(error);\n        return;\n    }\n}\n/**\n * In dev mode, we prefer using the owner stack, otherwise the provided\n * component stack is used.\n */ function createErrorWithComponentOrOwnerStack(message, componentStack) {\n    const ownerStack = process.env.NODE_ENV !== 'production' && React.captureOwnerStack ? React.captureOwnerStack() : null;\n    const error = Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    error.stack = error.name + ': ' + message + (ownerStack ?? componentStack);\n    return error;\n}\nexport var PreludeState = /*#__PURE__*/ function(PreludeState) {\n    PreludeState[PreludeState[\"Full\"] = 0] = \"Full\";\n    PreludeState[PreludeState[\"Empty\"] = 1] = \"Empty\";\n    PreludeState[PreludeState[\"Errored\"] = 2] = \"Errored\";\n    return PreludeState;\n}({});\nexport function logDisallowedDynamicError(workStore, error) {\n    console.error(error);\n    if (!workStore.dev) {\n        if (workStore.hasReadableErrorStacks) {\n            console.error(`To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.`);\n        } else {\n            console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:\n  - Start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.\n  - Rerun the production build with \\`next build --debug-prerender\\` to generate better stack traces.`);\n        }\n    }\n}\nexport function throwIfDisallowedDynamic(workStore, prelude, dynamicValidation, serverDynamic) {\n    if (prelude !== 0) {\n        if (dynamicValidation.hasSuspenseAboveBody) {\n            // This route has opted into allowing fully dynamic rendering\n            // by including a Suspense boundary above the body. In this case\n            // a lack of a shell is not considered disallowed so we simply return\n            return;\n        }\n        if (serverDynamic.syncDynamicErrorWithStack) {\n            // There is no shell and the server did something sync dynamic likely\n            // leading to an early termination of the prerender before the shell\n            // could be completed. We terminate the build/validating render.\n            logDisallowedDynamicError(workStore, serverDynamic.syncDynamicErrorWithStack);\n            throw new StaticGenBailoutError();\n        }\n        // We didn't have any sync bailouts but there may be user code which\n        // blocked the root. We would have captured these during the prerender\n        // and can log them here and then terminate the build/validating render\n        const dynamicErrors = dynamicValidation.dynamicErrors;\n        if (dynamicErrors.length > 0) {\n            for(let i = 0; i < dynamicErrors.length; i++){\n                logDisallowedDynamicError(workStore, dynamicErrors[i]);\n            }\n            throw new StaticGenBailoutError();\n        }\n        // If we got this far then the only other thing that could be blocking\n        // the root is dynamic Viewport. If this is dynamic then\n        // you need to opt into that by adding a Suspense boundary above the body\n        // to indicate your are ok with fully dynamic rendering.\n        if (dynamicValidation.hasDynamicViewport) {\n            console.error(`Route \"${workStore.route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`);\n            throw new StaticGenBailoutError();\n        }\n        if (prelude === 1) {\n            // If we ever get this far then we messed up the tracking of invalid dynamic.\n            // We still adhere to the constraint that you must produce a shell but invite the\n            // user to report this as a bug in Next.js.\n            console.error(`Route \"${workStore.route}\" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`);\n            throw new StaticGenBailoutError();\n        }\n    } else {\n        if (dynamicValidation.hasAllowedDynamic === false && dynamicValidation.hasDynamicMetadata) {\n            console.error(`Route \"${workStore.route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`);\n            throw new StaticGenBailoutError();\n        }\n    }\n}\nexport function delayUntilRuntimeStage(prerenderStore, result) {\n    if (prerenderStore.runtimeStagePromise) {\n        return prerenderStore.runtimeStagePromise.then(()=>result);\n    }\n    return result;\n}\n\n//# sourceMappingURL=dynamic-rendering.js.map"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;CAoBC,GAAG,wFAAwF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAC5F;;;;;;;;;;;;;;;;;;;;;AAKA;AACA;;;;;;AAEA;;;;;;;;;;;;;;;;AAEA,MAAM,cAAc,OAAO,wQAAK,CAAC,iBAAiB,KAAK;AAChD,SAAS,2BAA2B,sBAAsB;IAC7D,OAAO;QACH;QACA,iBAAiB,EAAE;QACnB,2BAA2B;IAC/B;AACJ;AACO,SAAS;IACZ,OAAO;QACH,sBAAsB;QACtB,oBAAoB;QACpB,oBAAoB;QACpB,mBAAmB;QACnB,eAAe,EAAE;IACrB;AACJ;AACO,SAAS,sBAAsB,aAAa;IAC/C,IAAI;IACJ,OAAO,CAAC,kCAAkC,cAAc,eAAe,CAAC,EAAE,KAAK,OAAO,KAAK,IAAI,gCAAgC,UAAU;AAC7I;AAOW,SAAS,0BAA0B,KAAK,EAAE,aAAa,EAAE,UAAU;IAC1E,IAAI,eAAe;QACf,OAAO,cAAc,IAAI;YACrB,KAAK;YACL,KAAK;gBACD,iEAAiE;gBACjE,kEAAkE;gBAClE,gEAAgE;gBAChE,kCAAkC;gBAClC;YACJ,KAAK;gBACD,0DAA0D;gBAC1D;YACJ,KAAK;YACL,KAAK;YACL,KAAK;gBACD;YACJ;gBACI;QACR;IACJ;IACA,2EAA2E;IAC3E,4EAA4E;IAC5E,2DAA2D;IAC3D,IAAI,MAAM,YAAY,IAAI,MAAM,WAAW,EAAE;IAC7C,IAAI,MAAM,kBAAkB,EAAE;QAC1B,MAAM,OAAO,cAAc,CAAC,IAAI,sBAAsB,CAAC,MAAM,EAAE,MAAM,KAAK,CAAC,8EAA8E,EAAE,WAAW,4HAA4H,CAAC,GAAG,qBAAqB;YACvT,OAAO;YACP,YAAY;YACZ,cAAc;QAClB;IACJ;IACA,IAAI,eAAe;QACf,OAAO,cAAc,IAAI;YACrB,KAAK;gBACD,OAAO,qBAAqB,MAAM,KAAK,EAAE,YAAY,cAAc,eAAe;YACtF,KAAK;gBACD,cAAc,UAAU,GAAG;gBAC3B,uEAAuE;gBACvE,oCAAoC;gBACpC,MAAM,MAAM,OAAO,cAAc,CAAC,IAAI,mBAAmB,CAAC,MAAM,EAAE,MAAM,KAAK,CAAC,iDAAiD,EAAE,WAAW,2EAA2E,CAAC,GAAG,qBAAqB;oBAC5O,OAAO;oBACP,YAAY;oBACZ,cAAc;gBAClB;gBACA,MAAM,uBAAuB,GAAG;gBAChC,MAAM,iBAAiB,GAAG,IAAI,KAAK;gBACnC,MAAM;YACV,KAAK;gBACD,wCAA2C;oBACvC,cAAc,WAAW,GAAG;gBAChC;gBACA;YACJ;gBACI;QACR;IACJ;AACJ;AAMW,SAAS,iCAAiC,UAAU,EAAE,KAAK,EAAE,cAAc;IAClF,uGAAuG;IACvG,MAAM,MAAM,OAAO,cAAc,CAAC,IAAI,mBAAmB,CAAC,MAAM,EAAE,MAAM,KAAK,CAAC,mDAAmD,EAAE,WAAW,6EAA6E,CAAC,GAAG,qBAAqB;QAChP,OAAO;QACP,YAAY;QACZ,cAAc;IAClB;IACA,eAAe,UAAU,GAAG;IAC5B,MAAM,uBAAuB,GAAG;IAChC,MAAM,iBAAiB,GAAG,IAAI,KAAK;IACnC,MAAM;AACV;AAOW,SAAS,gCAAgC,aAAa;IAC7D,OAAO,cAAc,IAAI;QACrB,KAAK;QACL,KAAK;YACD,iEAAiE;YACjE,kEAAkE;YAClE,gEAAgE;YAChE,kCAAkC;YAClC;QACJ,KAAK;YACD,0DAA0D;YAC1D;QACJ,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACD;QACJ,KAAK;YACD,wCAA2C;gBACvC,cAAc,WAAW,GAAG;YAChC;YACA;QACJ;YACI;IACR;AACJ;AACA,SAAS,oCAAoC,KAAK,EAAE,UAAU,EAAE,cAAc;IAC1E,MAAM,SAAS,CAAC,MAAM,EAAE,MAAM,iEAAiE,EAAE,WAAW,CAAC,CAAC;IAC9G,MAAM,QAAQ,gCAAgC;IAC9C,eAAe,UAAU,CAAC,KAAK,CAAC;IAChC,MAAM,kBAAkB,eAAe,eAAe;IACtD,IAAI,iBAAiB;QACjB,gBAAgB,eAAe,CAAC,IAAI,CAAC;YACjC,0EAA0E;YAC1E,eAAe;YACf,OAAO,gBAAgB,sBAAsB,GAAG,IAAI,QAAQ,KAAK,GAAG;YACpE;QACJ;IACJ;AACJ;AACO,SAAS,mCAAmC,KAAK,EAAE,UAAU,EAAE,cAAc,EAAE,cAAc;IAChG,MAAM,kBAAkB,eAAe,eAAe;IACtD,oCAAoC,OAAO,YAAY;IACvD,sFAAsF;IACtF,0FAA0F;IAC1F,sFAAsF;IACtF,oDAAoD;IACpD,IAAI,iBAAiB;QACjB,IAAI,gBAAgB,yBAAyB,KAAK,MAAM;YACpD,gBAAgB,yBAAyB,GAAG;QAChD;IACJ;AACJ;AACO,SAAS,sCAAsC,YAAY;IAC9D,oFAAoF;IACpF,oDAAoD;IACpD,aAAa,cAAc,GAAG;AAClC;AAUW,SAAS,4CAA4C,KAAK,EAAE,UAAU,EAAE,cAAc,EAAE,cAAc;IAC7G,MAAM,kBAAkB,eAAe,UAAU,CAAC,MAAM;IACxD,IAAI,gBAAgB,OAAO,KAAK,OAAO;QACnC,8FAA8F;QAC9F,mFAAmF;QACnF,wFAAwF;QACxF,4FAA4F;QAC5F,0BAA0B;QAC1B,oCAAoC,OAAO,YAAY;QACvD,sFAAsF;QACtF,0FAA0F;QAC1F,sFAAsF;QACtF,oDAAoD;QACpD,MAAM,kBAAkB,eAAe,eAAe;QACtD,IAAI,iBAAiB;YACjB,IAAI,gBAAgB,yBAAyB,KAAK,MAAM;gBACpD,gBAAgB,yBAAyB,GAAG;YAChD;QACJ;IACJ;IACA,MAAM,gCAAgC,CAAC,MAAM,EAAE,MAAM,iEAAiE,EAAE,WAAW,CAAC,CAAC;AACzI;AAOW,SAAS,uBAAuB,eAAe;IACtD,IAAI,gBAAgB,yBAAyB,EAAE;QAC3C,gDAAgD;QAChD,oDAAoD;QACpD,QAAQ,KAAK,CAAC,gBAAgB,yBAAyB;IAC3D;AACJ;AAEO,MAAM,yCAAyC;AAC/C,SAAS,SAAS,EAAE,MAAM,EAAE,KAAK,EAAE;IACtC,MAAM,iBAAiB,qBAAqB,QAAQ;IACpD,MAAM,kBAAkB,kBAAkB,eAAe,IAAI,KAAK,kBAAkB,eAAe,eAAe,GAAG;IACrH,qBAAqB,OAAO,QAAQ;AACxC;AACO,SAAS,qBAAqB,KAAK,EAAE,UAAU,EAAE,eAAe;IACnE;IACA,IAAI,iBAAiB;QACjB,gBAAgB,eAAe,CAAC,IAAI,CAAC;YACjC,0EAA0E;YAC1E,eAAe;YACf,OAAO,gBAAgB,sBAAsB,GAAG,IAAI,QAAQ,KAAK,GAAG;YACpE;QACJ;IACJ;IACA,wQAAK,CAAC,iBAAiB,CAAC,qBAAqB,OAAO;AACxD;AACA,SAAS,qBAAqB,KAAK,EAAE,UAAU;IAC3C,OAAO,CAAC,MAAM,EAAE,MAAM,iEAAiE,EAAE,WAAW,EAAE,CAAC,GAAG,CAAC,+EAA+E,CAAC,GAAG,CAAC,iFAAiF,CAAC;AACrR;AACO,SAAS,kBAAkB,GAAG;IACjC,IAAI,OAAO,QAAQ,YAAY,QAAQ,QAAQ,OAAO,IAAI,OAAO,KAAK,UAAU;QAC5E,OAAO,wBAAwB,IAAI,OAAO;IAC9C;IACA,OAAO;AACX;AACA,SAAS,wBAAwB,MAAM;IACnC,OAAO,OAAO,QAAQ,CAAC,sEAAsE,OAAO,QAAQ,CAAC;AACjH;AACA,IAAI,wBAAwB,qBAAqB,OAAO,YAAY,OAAO;IACvE,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,2FAA2F,qBAAqB;QAClJ,OAAO;QACP,YAAY;QACZ,cAAc;IAClB;AACJ;AACA,MAAM,6BAA6B;AACnC,SAAS,gCAAgC,OAAO;IAC5C,MAAM,QAAQ,OAAO,cAAc,CAAC,IAAI,MAAM,UAAU,qBAAqB;QACzE,OAAO;QACP,YAAY;QACZ,cAAc;IAClB;IACA,MAAM,MAAM,GAAG;IACf,OAAO;AACX;AACO,SAAS,4BAA4B,KAAK;IAC7C,OAAO,OAAO,UAAU,YAAY,UAAU,QAAQ,MAAM,MAAM,KAAK,8BAA8B,UAAU,SAAS,aAAa,SAAS,iBAAiB;AACnK;AACO,SAAS,oBAAoB,eAAe;IAC/C,OAAO,gBAAgB,MAAM,GAAG;AACpC;AACO,SAAS,qBAAqB,aAAa,EAAE,aAAa;IAC7D,oEAAoE;IACpE,0EAA0E;IAC1E,SAAS;IACT,cAAc,eAAe,CAAC,IAAI,IAAI,cAAc,eAAe;IACnE,OAAO,cAAc,eAAe;AACxC;AACO,SAAS,yBAAyB,eAAe;IACpD,OAAO,gBAAgB,MAAM,CAAC,CAAC,SAAS,OAAO,OAAO,KAAK,KAAK,YAAY,OAAO,KAAK,CAAC,MAAM,GAAG,GAAG,GAAG,CAAC,CAAC,EAAE,UAAU,EAAE,KAAK,EAAE;QAC3H,QAAQ,MAAM,KAAK,CAAC,MAAK,wEAAwE;QACjG,qEAAqE;QACrE,uDAAuD;SACtD,KAAK,CAAC,GAAG,MAAM,CAAC,CAAC;YACd,kDAAkD;YAClD,IAAI,KAAK,QAAQ,CAAC,uBAAuB;gBACrC,OAAO;YACX;YACA,oDAAoD;YACpD,IAAI,KAAK,QAAQ,CAAC,mBAAmB;gBACjC,OAAO;YACX;YACA,kDAAkD;YAClD,IAAI,KAAK,QAAQ,CAAC,YAAY;gBAC1B,OAAO;YACX;YACA,OAAO;QACX,GAAG,IAAI,CAAC;QACR,OAAO,CAAC,0BAA0B,EAAE,WAAW,GAAG,EAAE,OAAO;IAC/D;AACJ;AACA,SAAS;IACL,IAAI,CAAC,aAAa;QACd,MAAM,OAAO,cAAc,CAAC,IAAI,MAAM,CAAC,gIAAgI,CAAC,GAAG,qBAAqB;YAC5L,OAAO;YACP,YAAY;YACZ,cAAc;QAClB;IACJ;AACJ;AAIW,SAAS;IAChB,MAAM,aAAa,IAAI;IACvB,WAAW,KAAK,CAAC,OAAO,cAAc,CAAC,IAAI,wRAAiB,CAAC,sBAAsB,qBAAqB;QACpG,OAAO;QACP,YAAY;QACZ,cAAc;IAClB;IACA,OAAO,WAAW,MAAM;AAC5B;AAKW,SAAS,8BAA8B,aAAa;IAC3D,OAAO,cAAc,IAAI;QACrB,KAAK;QACL,KAAK;YACD,MAAM,aAAa,IAAI;YACvB,IAAI,cAAc,WAAW,EAAE;gBAC3B,sEAAsE;gBACtE,sEAAsE;gBACtE,8DAA8D;gBAC9D,cAAc,WAAW,CAAC,UAAU,GAAG,IAAI,CAAC;oBACxC,WAAW,KAAK;gBACpB;YACJ,OAAO;gBACH,qEAAqE;gBACrE,qBAAqB;gBACrB,sEAAsE;gBACtE,sDAAsD;gBACtD,qEAAqE;gBACrE,iDAAiD;gBACjD,EAAE;gBACF,qDAAqD;gBACrD,oEAAoE;gBACpE,sEAAsE;gBACtE,sEAAsE;gBACtE,gCAAgC;gBAChC,MAAM,sBAAsB,uBAAuB;gBACnD,IAAI,qBAAqB;oBACrB,oBAAoB,IAAI,CAAC,IAAI,mBAAmB,IAAI,WAAW,KAAK;gBACxE,OAAO;oBACH,mBAAmB,IAAI,WAAW,KAAK;gBAC3C;YACJ;YACA,OAAO,WAAW,MAAM;QAC5B,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACD,OAAO;QACX;YACI;IACR;AACJ;AACO,SAAS,sBAAsB,UAAU,EAAE,cAAc;IAC5D,MAAM,kBAAkB,eAAe,eAAe;IACtD,IAAI,iBAAiB;QACjB,gBAAgB,eAAe,CAAC,IAAI,CAAC;YACjC,OAAO,gBAAgB,sBAAsB,GAAG,IAAI,QAAQ,KAAK,GAAG;YACpE;QACJ;IACJ;AACJ;AACO,SAAS,sBAAsB,UAAU;IAC5C,MAAM,YAAY,iBAAiB,QAAQ;IAC3C,MAAM,gBAAgB,qBAAqB,QAAQ;IACnD,IAAI,aAAa,eAAe;QAC5B,OAAO,cAAc,IAAI;YACrB,KAAK;YACL,KAAK;gBACD;oBACI,MAAM,iBAAiB,cAAc,mBAAmB;oBACxD,IAAI,kBAAkB,eAAe,IAAI,GAAG,GAAG;wBAC3C,wEAAwE;wBACxE,6DAA6D;wBAC7D,wDAAwD;wBACxD,wQAAK,CAAC,GAAG,CAAC,IAAA,wQAAkB,EAAC,cAAc,YAAY,EAAE,UAAU,KAAK,EAAE;oBAC9E;oBACA;gBACJ;YACJ,KAAK;gBACD;oBACI,MAAM,iBAAiB,cAAc,mBAAmB;oBACxD,IAAI,kBAAkB,eAAe,IAAI,GAAG,GAAG;wBAC3C,OAAO,qBAAqB,UAAU,KAAK,EAAE,YAAY,cAAc,eAAe;oBAC1F;oBACA;gBACJ;YACJ,KAAK;gBACD,MAAM,OAAO,cAAc,CAAC,IAAI,eAAe,CAAC,EAAE,EAAE,WAAW,uEAAuE,EAAE,WAAW,+EAA+E,CAAC,GAAG,qBAAqB;oBACvP,OAAO;oBACP,YAAY;oBACZ,cAAc;gBAClB;YACJ,KAAK;YACL,KAAK;gBACD,MAAM,OAAO,cAAc,CAAC,IAAI,eAAe,CAAC,EAAE,EAAE,WAAW,iEAAiE,EAAE,WAAW,+EAA+E,CAAC,GAAG,qBAAqB;oBACjP,OAAO;oBACP,YAAY;oBACZ,cAAc;gBAClB;YACJ,KAAK;YACL,KAAK;YACL,KAAK;gBACD;YACJ;gBACI;QACR;IACJ;AACJ;AACA,MAAM,mBAAmB;AACzB,uFAAuF;AACvF,MAAM,sBAAsB;AAC5B,2EAA2E;AAC3E,+EAA+E;AAC/E,4FAA4F;AAC5F,EAAE;AACF,mBAAmB;AACnB,8BAA8B;AAC9B,mDAAmD;AACnD,EAAE;AACF,yEAAyE;AACzE,8BAA8B;AAC9B,mCAAmC;AACnC,mDAAmD;AACnD,MAAM,4DAA4D,IAAI,OAAO,CAAC,uDAAuD,EAAE,oBAAoB,yCAAyC,EAAE,iRAAyB,CAAC,cAAc,CAAC;AAC/O,MAAM,mBAAmB,IAAI,OAAO,CAAC,UAAU,EAAE,8QAAsB,CAAC,QAAQ,CAAC;AACjF,MAAM,mBAAmB,IAAI,OAAO,CAAC,UAAU,EAAE,8QAAsB,CAAC,QAAQ,CAAC;AACjF,MAAM,iBAAiB,IAAI,OAAO,CAAC,UAAU,EAAE,4QAAoB,CAAC,QAAQ,CAAC;AACtE,SAAS,0BAA0B,SAAS,EAAE,cAAc,EAAE,iBAAiB,EAAE,aAAa;IACjG,IAAI,eAAe,IAAI,CAAC,iBAAiB;QACrC,kGAAkG;QAClG;IACJ,OAAO,IAAI,iBAAiB,IAAI,CAAC,iBAAiB;QAC9C,kBAAkB,kBAAkB,GAAG;QACvC;IACJ,OAAO,IAAI,iBAAiB,IAAI,CAAC,iBAAiB;QAC9C,kBAAkB,kBAAkB,GAAG;QACvC;IACJ,OAAO,IAAI,0DAA0D,IAAI,CAAC,iBAAiB;QACvF,+GAA+G;QAC/G,sGAAsG;QACtG,wGAAwG;QACxG,kBAAkB,iBAAiB,GAAG;QACtC,kBAAkB,oBAAoB,GAAG;QACzC;IACJ,OAAO,IAAI,iBAAiB,IAAI,CAAC,iBAAiB;QAC9C,wFAAwF;QACxF,gBAAgB;QAChB,kBAAkB,iBAAiB,GAAG;QACtC;IACJ,OAAO,IAAI,cAAc,yBAAyB,EAAE;QAChD,qDAAqD;QACrD,kBAAkB,aAAa,CAAC,IAAI,CAAC,cAAc,yBAAyB;QAC5E;IACJ,OAAO;QACH,MAAM,UAAU,CAAC,OAAO,EAAE,UAAU,KAAK,CAAC,2NAA2N,CAAC;QACtQ,MAAM,QAAQ,qCAAqC,SAAS;QAC5D,kBAAkB,aAAa,CAAC,IAAI,CAAC;QACrC;IACJ;AACJ;AACA;;;CAGC,GAAG,SAAS,qCAAqC,OAAO,EAAE,cAAc;IACrE,MAAM,aAAa,oDAAyB,gBAAgB,wQAAK,CAAC,iBAAiB,GAAG,wQAAK,CAAC,iBAAiB,KAAK;IAClH,MAAM,QAAQ,OAAO,cAAc,CAAC,IAAI,MAAM,UAAU,qBAAqB;QACzE,OAAO;QACP,YAAY;QACZ,cAAc;IAClB;IACA,MAAM,KAAK,GAAG,MAAM,IAAI,GAAG,OAAO,UAAU,CAAC,cAAc,cAAc;IACzE,OAAO;AACX;AACO,IAAI,eAAe,WAAW,GAAG,SAAS,YAAY;IACzD,YAAY,CAAC,YAAY,CAAC,OAAO,GAAG,EAAE,GAAG;IACzC,YAAY,CAAC,YAAY,CAAC,QAAQ,GAAG,EAAE,GAAG;IAC1C,YAAY,CAAC,YAAY,CAAC,UAAU,GAAG,EAAE,GAAG;IAC5C,OAAO;AACX,EAAE,CAAC;AACI,SAAS,0BAA0B,SAAS,EAAE,KAAK;IACtD,QAAQ,KAAK,CAAC;IACd,IAAI,CAAC,UAAU,GAAG,EAAE;QAChB,IAAI,UAAU,sBAAsB,EAAE;YAClC,QAAQ,KAAK,CAAC,CAAC,iIAAiI,EAAE,UAAU,KAAK,CAAC,2CAA2C,CAAC;QAClN,OAAO;YACH,QAAQ,KAAK,CAAC,CAAC;0EAC+C,EAAE,UAAU,KAAK,CAAC;qGACS,CAAC;QAC9F;IACJ;AACJ;AACO,SAAS,yBAAyB,SAAS,EAAE,OAAO,EAAE,iBAAiB,EAAE,aAAa;IACzF,IAAI,YAAY,GAAG;QACf,IAAI,kBAAkB,oBAAoB,EAAE;YACxC,6DAA6D;YAC7D,gEAAgE;YAChE,qEAAqE;YACrE;QACJ;QACA,IAAI,cAAc,yBAAyB,EAAE;YACzC,qEAAqE;YACrE,oEAAoE;YACpE,gEAAgE;YAChE,0BAA0B,WAAW,cAAc,yBAAyB;YAC5E,MAAM,IAAI;QACd;QACA,oEAAoE;QACpE,sEAAsE;QACtE,uEAAuE;QACvE,MAAM,gBAAgB,kBAAkB,aAAa;QACrD,IAAI,cAAc,MAAM,GAAG,GAAG;YAC1B,IAAI,IAAI,IAAI,GAAG,IAAI,cAAc,MAAM,EAAE,IAAI;gBACzC,0BAA0B,WAAW,aAAa,CAAC,EAAE;YACzD;YACA,MAAM,IAAI;QACd;QACA,sEAAsE;QACtE,wDAAwD;QACxD,yEAAyE;QACzE,wDAAwD;QACxD,IAAI,kBAAkB,kBAAkB,EAAE;YACtC,QAAQ,KAAK,CAAC,CAAC,OAAO,EAAE,UAAU,KAAK,CAAC,8QAA8Q,CAAC;YACvT,MAAM,IAAI;QACd;QACA,IAAI,YAAY,GAAG;YACf,6EAA6E;YAC7E,iFAAiF;YACjF,2CAA2C;YAC3C,QAAQ,KAAK,CAAC,CAAC,OAAO,EAAE,UAAU,KAAK,CAAC,wGAAwG,CAAC;YACjJ,MAAM,IAAI;QACd;IACJ,OAAO;QACH,IAAI,kBAAkB,iBAAiB,KAAK,SAAS,kBAAkB,kBAAkB,EAAE;YACvF,QAAQ,KAAK,CAAC,CAAC,OAAO,EAAE,UAAU,KAAK,CAAC,8PAA8P,CAAC;YACvS,MAAM,IAAI;QACd;IACJ;AACJ;AACO,SAAS,uBAAuB,cAAc,EAAE,MAAM;IACzD,IAAI,eAAe,mBAAmB,EAAE;QACpC,OAAO,eAAe,mBAAmB,CAAC,IAAI,CAAC,IAAI;IACvD;IACA,OAAO;AACX,EAEA,6CAA6C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1280, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/esm/lib/error-telemetry-utils.js"],"sourcesContent":["const ERROR_CODE_DELIMITER = '@';\n/**\n * Augments the digest field of errors thrown in React Server Components (RSC) with an error code.\n * Since RSC errors can only be serialized through the digest field, this provides a way to include\n * an additional error code that can be extracted client-side via `extractNextErrorCode`.\n *\n * The error code is appended to the digest string with a semicolon separator, allowing it to be\n * parsed out later while preserving the original digest value.\n */ export const createDigestWithErrorCode = (thrownValue, originalDigest)=>{\n    if (typeof thrownValue === 'object' && thrownValue !== null && '__NEXT_ERROR_CODE' in thrownValue) {\n        return `${originalDigest}${ERROR_CODE_DELIMITER}${thrownValue.__NEXT_ERROR_CODE}`;\n    }\n    return originalDigest;\n};\nexport const extractNextErrorCode = (error)=>{\n    if (typeof error === 'object' && error !== null && '__NEXT_ERROR_CODE' in error && typeof error.__NEXT_ERROR_CODE === 'string') {\n        return error.__NEXT_ERROR_CODE;\n    }\n    if (typeof error === 'object' && error !== null && 'digest' in error && typeof error.digest === 'string') {\n        const segments = error.digest.split(ERROR_CODE_DELIMITER);\n        const errorCode = segments.find((segment)=>segment.startsWith('E'));\n        return errorCode;\n    }\n    return undefined;\n};\n\n//# sourceMappingURL=error-telemetry-utils.js.map"],"names":[],"mappings":";;;;;;AAAA,MAAM,uBAAuB;AAQlB,MAAM,4BAA4B,CAAC,aAAa;IACvD,IAAI,OAAO,gBAAgB,YAAY,gBAAgB,QAAQ,uBAAuB,aAAa;QAC/F,OAAO,GAAG,iBAAiB,uBAAuB,YAAY,iBAAiB,EAAE;IACrF;IACA,OAAO;AACX;AACO,MAAM,uBAAuB,CAAC;IACjC,IAAI,OAAO,UAAU,YAAY,UAAU,QAAQ,uBAAuB,SAAS,OAAO,MAAM,iBAAiB,KAAK,UAAU;QAC5H,OAAO,MAAM,iBAAiB;IAClC;IACA,IAAI,OAAO,UAAU,YAAY,UAAU,QAAQ,YAAY,SAAS,OAAO,MAAM,MAAM,KAAK,UAAU;QACtG,MAAM,WAAW,MAAM,MAAM,CAAC,KAAK,CAAC;QACpC,MAAM,YAAY,SAAS,IAAI,CAAC,CAAC,UAAU,QAAQ,UAAU,CAAC;QAC9D,OAAO;IACX;IACA,OAAO;AACX,GAEA,iDAAiD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1308, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/esm/server/app-render/create-error-handler.js"],"sourcesContent":["import stringHash from 'next/dist/compiled/string-hash';\nimport { formatServerError } from '../../lib/format-server-error';\nimport { SpanStatusCode, getTracer } from '../lib/trace/tracer';\nimport { isAbortError } from '../pipe-readable';\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr';\nimport { isDynamicServerError } from '../../client/components/hooks-server-context';\nimport { isNextRouterError } from '../../client/components/is-next-router-error';\nimport { isPrerenderInterruptedError } from './dynamic-rendering';\nimport { getProperError } from '../../lib/is-error';\nimport { createDigestWithErrorCode } from '../../lib/error-telemetry-utils';\nimport { isReactLargeShellError } from './react-large-shell-error';\n/**\n * Returns a digest for well-known Next.js errors, otherwise `undefined`. If a\n * digest is returned this also means that the error does not need to be\n * reported.\n */ export function getDigestForWellKnownError(error) {\n    // If we're bailing out to CSR, we don't need to log the error.\n    if (isBailoutToCSRError(error)) return error.digest;\n    // If this is a navigation error, we don't need to log the error.\n    if (isNextRouterError(error)) return error.digest;\n    // If this error occurs, we know that we should be stopping the static\n    // render. This is only thrown in static generation when PPR is not enabled,\n    // which causes the whole page to be marked as dynamic. We don't need to\n    // tell the user about this error, as it's not actionable.\n    if (isDynamicServerError(error)) return error.digest;\n    // If this is a prerender interrupted error, we don't need to log the error.\n    if (isPrerenderInterruptedError(error)) return error.digest;\n    return undefined;\n}\nexport function createFlightReactServerErrorHandler(shouldFormatError, onReactServerRenderError) {\n    return (thrownValue)=>{\n        if (typeof thrownValue === 'string') {\n            // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n            return stringHash(thrownValue).toString();\n        }\n        // If the response was closed, we don't need to log the error.\n        if (isAbortError(thrownValue)) return;\n        const digest = getDigestForWellKnownError(thrownValue);\n        if (digest) {\n            return digest;\n        }\n        if (isReactLargeShellError(thrownValue)) {\n            // TODO: Aggregate\n            console.error(thrownValue);\n            return undefined;\n        }\n        const err = getProperError(thrownValue);\n        // If the error already has a digest, respect the original digest,\n        // so it won't get re-generated into another new error.\n        if (!err.digest) {\n            // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n            err.digest = stringHash(err.message + err.stack || '').toString();\n        }\n        // Format server errors in development to add more helpful error messages\n        if (shouldFormatError) {\n            formatServerError(err);\n        }\n        // Record exception in an active span, if available.\n        const span = getTracer().getActiveScopeSpan();\n        if (span) {\n            span.recordException(err);\n            span.setAttribute('error.type', err.name);\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: err.message\n            });\n        }\n        onReactServerRenderError(err);\n        return createDigestWithErrorCode(thrownValue, err.digest);\n    };\n}\nexport function createHTMLReactServerErrorHandler(shouldFormatError, isNextExport, reactServerErrors, silenceLogger, onReactServerRenderError) {\n    return (thrownValue)=>{\n        var _err_message;\n        if (typeof thrownValue === 'string') {\n            // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n            return stringHash(thrownValue).toString();\n        }\n        // If the response was closed, we don't need to log the error.\n        if (isAbortError(thrownValue)) return;\n        const digest = getDigestForWellKnownError(thrownValue);\n        if (digest) {\n            return digest;\n        }\n        if (isReactLargeShellError(thrownValue)) {\n            // TODO: Aggregate\n            console.error(thrownValue);\n            return undefined;\n        }\n        const err = getProperError(thrownValue);\n        // If the error already has a digest, respect the original digest,\n        // so it won't get re-generated into another new error.\n        if (!err.digest) {\n            // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n            err.digest = stringHash(err.message + (err.stack || '')).toString();\n        }\n        // @TODO by putting this here and not at the top it is possible that\n        // we don't error the build in places we actually expect to\n        if (!reactServerErrors.has(err.digest)) {\n            reactServerErrors.set(err.digest, err);\n        }\n        // Format server errors in development to add more helpful error messages\n        if (shouldFormatError) {\n            formatServerError(err);\n        }\n        // Don't log the suppressed error during export\n        if (!(isNextExport && (err == null ? void 0 : (_err_message = err.message) == null ? void 0 : _err_message.includes('The specific message is omitted in production builds to avoid leaking sensitive details.')))) {\n            // Record exception in an active span, if available.\n            const span = getTracer().getActiveScopeSpan();\n            if (span) {\n                span.recordException(err);\n                span.setAttribute('error.type', err.name);\n                span.setStatus({\n                    code: SpanStatusCode.ERROR,\n                    message: err.message\n                });\n            }\n            if (!silenceLogger) {\n                onReactServerRenderError == null ? void 0 : onReactServerRenderError(err);\n            }\n        }\n        return createDigestWithErrorCode(thrownValue, err.digest);\n    };\n}\nexport function createHTMLErrorHandler(shouldFormatError, isNextExport, reactServerErrors, allCapturedErrors, silenceLogger, onHTMLRenderSSRError) {\n    return (thrownValue, errorInfo)=>{\n        var _err_message;\n        if (isReactLargeShellError(thrownValue)) {\n            // TODO: Aggregate\n            console.error(thrownValue);\n            return undefined;\n        }\n        let isSSRError = true;\n        allCapturedErrors.push(thrownValue);\n        // If the response was closed, we don't need to log the error.\n        if (isAbortError(thrownValue)) return;\n        const digest = getDigestForWellKnownError(thrownValue);\n        if (digest) {\n            return digest;\n        }\n        const err = getProperError(thrownValue);\n        // If the error already has a digest, respect the original digest,\n        // so it won't get re-generated into another new error.\n        if (err.digest) {\n            if (reactServerErrors.has(err.digest)) {\n                // This error is likely an obfuscated error from react-server.\n                // We recover the original error here.\n                thrownValue = reactServerErrors.get(err.digest);\n                isSSRError = false;\n            } else {\n            // The error is not from react-server but has a digest\n            // from other means so we don't need to produce a new one\n            }\n        } else {\n            err.digest = stringHash(err.message + ((errorInfo == null ? void 0 : errorInfo.componentStack) || err.stack || '')).toString();\n        }\n        // Format server errors in development to add more helpful error messages\n        if (shouldFormatError) {\n            formatServerError(err);\n        }\n        // Don't log the suppressed error during export\n        if (!(isNextExport && (err == null ? void 0 : (_err_message = err.message) == null ? void 0 : _err_message.includes('The specific message is omitted in production builds to avoid leaking sensitive details.')))) {\n            // Record exception in an active span, if available.\n            const span = getTracer().getActiveScopeSpan();\n            if (span) {\n                span.recordException(err);\n                span.setAttribute('error.type', err.name);\n                span.setStatus({\n                    code: SpanStatusCode.ERROR,\n                    message: err.message\n                });\n            }\n            if (!silenceLogger && // HTML errors contain RSC errors as well, filter them out before reporting\n            isSSRError) {\n                onHTMLRenderSSRError(err, errorInfo);\n            }\n        }\n        return createDigestWithErrorCode(thrownValue, err.digest);\n    };\n}\nexport function isUserLandError(err) {\n    return !isAbortError(err) && !isBailoutToCSRError(err) && !isNextRouterError(err);\n}\n\n//# sourceMappingURL=create-error-handler.js.map"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1538, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/esm/server/app-render/collect-segment-data.js"],"sourcesContent":["import { jsx as _jsx } from \"react/jsx-runtime\";\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { createFromReadableStream } from 'react-server-dom-webpack/client';\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { unstable_prerender as prerender } from 'react-server-dom-webpack/static';\nimport { streamFromBuffer, streamToBuffer } from '../stream-utils/node-web-streams-helper';\nimport { waitAtLeastOneReactRenderTask } from '../../lib/scheduler';\nimport { createSegmentRequestKeyPart, appendSegmentRequestKeyPart, ROOT_SEGMENT_REQUEST_KEY } from '../../shared/lib/segment-cache/segment-value-encoding';\nimport { getDigestForWellKnownError } from './create-error-handler';\nconst filterStackFrame = process.env.NODE_ENV !== 'production' ? require('../lib/source-maps').filterStackFrameDEV : undefined;\nconst findSourceMapURL = process.env.NODE_ENV !== 'production' ? require('../lib/source-maps').findSourceMapURLDEV : undefined;\nfunction onSegmentPrerenderError(error) {\n    const digest = getDigestForWellKnownError(error);\n    if (digest) {\n        return digest;\n    }\n// We don't need to log the errors because we would have already done that\n// when generating the original Flight stream for the whole page.\n}\nexport async function collectSegmentData(isClientParamParsingEnabled, fullPageDataBuffer, staleTime, clientModules, serverConsumerManifest) {\n    // Traverse the router tree and generate a prefetch response for each segment.\n    // A mutable map to collect the results as we traverse the route tree.\n    const resultMap = new Map();\n    // Before we start, warm up the module cache by decoding the page data once.\n    // Then we can assume that any remaining async tasks that occur the next time\n    // are due to hanging promises caused by dynamic data access. Note we only\n    // have to do this once per page, not per individual segment.\n    //\n    try {\n        await createFromReadableStream(streamFromBuffer(fullPageDataBuffer), {\n            findSourceMapURL,\n            serverConsumerManifest\n        });\n        await waitAtLeastOneReactRenderTask();\n    } catch  {}\n    // Create an abort controller that we'll use to stop the stream.\n    const abortController = new AbortController();\n    const onCompletedProcessingRouteTree = async ()=>{\n        // Since all we're doing is decoding and re-encoding a cached prerender, if\n        // serializing the stream takes longer than a microtask, it must because of\n        // hanging promises caused by dynamic data.\n        await waitAtLeastOneReactRenderTask();\n        abortController.abort();\n    };\n    // Generate a stream for the route tree prefetch. While we're walking the\n    // tree, we'll also spawn additional tasks to generate the segment prefetches.\n    // The promises for these tasks are pushed to a mutable array that we will\n    // await once the route tree is fully rendered.\n    const segmentTasks = [];\n    const { prelude: treeStream } = await prerender(// RootTreePrefetch is not a valid return type for a React component, but\n    // we need to use a component so that when we decode the original stream\n    // inside of it, the side effects are transferred to the new stream.\n    // @ts-expect-error\n    /*#__PURE__*/ _jsx(PrefetchTreeData, {\n        isClientParamParsingEnabled: isClientParamParsingEnabled,\n        fullPageDataBuffer: fullPageDataBuffer,\n        serverConsumerManifest: serverConsumerManifest,\n        clientModules: clientModules,\n        staleTime: staleTime,\n        segmentTasks: segmentTasks,\n        onCompletedProcessingRouteTree: onCompletedProcessingRouteTree\n    }), clientModules, {\n        filterStackFrame,\n        signal: abortController.signal,\n        onError: onSegmentPrerenderError\n    });\n    // Write the route tree to a special `/_tree` segment.\n    const treeBuffer = await streamToBuffer(treeStream);\n    resultMap.set('/_tree', treeBuffer);\n    // Now that we've finished rendering the route tree, all the segment tasks\n    // should have been spawned. Await them in parallel and write the segment\n    // prefetches to the result map.\n    for (const [segmentPath, buffer] of (await Promise.all(segmentTasks))){\n        resultMap.set(segmentPath, buffer);\n    }\n    return resultMap;\n}\nasync function PrefetchTreeData({ isClientParamParsingEnabled, fullPageDataBuffer, serverConsumerManifest, clientModules, staleTime, segmentTasks, onCompletedProcessingRouteTree }) {\n    // We're currently rendering a Flight response for the route tree prefetch.\n    // Inside this component, decode the Flight stream for the whole page. This is\n    // a hack to transfer the side effects from the original Flight stream (e.g.\n    // Float preloads) onto the Flight stream for the tree prefetch.\n    // TODO: React needs a better way to do this. Needed for Server Actions, too.\n    const initialRSCPayload = await createFromReadableStream(createUnclosingPrefetchStream(streamFromBuffer(fullPageDataBuffer)), {\n        findSourceMapURL,\n        serverConsumerManifest\n    });\n    const buildId = initialRSCPayload.b;\n    // FlightDataPath is an unsound type, hence the additional checks.\n    const flightDataPaths = initialRSCPayload.f;\n    if (flightDataPaths.length !== 1 && flightDataPaths[0].length !== 3) {\n        console.error('Internal Next.js error: InitialRSCPayload does not match the expected ' + 'shape for a prerendered page during segment prefetch generation.');\n        return null;\n    }\n    const flightRouterState = flightDataPaths[0][0];\n    const seedData = flightDataPaths[0][1];\n    const head = flightDataPaths[0][2];\n    // Compute the route metadata tree by traversing the FlightRouterState. As we\n    // walk the tree, we will also spawn a task to produce a prefetch response for\n    // each segment.\n    const tree = collectSegmentDataImpl(isClientParamParsingEnabled, flightRouterState, buildId, seedData, clientModules, ROOT_SEGMENT_REQUEST_KEY, segmentTasks);\n    const isHeadPartial = await isPartialRSCData(head, clientModules);\n    // Notify the abort controller that we're done processing the route tree.\n    // Anything async that happens after this point must be due to hanging\n    // promises in the original stream.\n    onCompletedProcessingRouteTree();\n    // Render the route tree to a special `/_tree` segment.\n    const treePrefetch = {\n        buildId,\n        tree,\n        head,\n        isHeadPartial,\n        staleTime\n    };\n    return treePrefetch;\n}\nfunction collectSegmentDataImpl(isClientParamParsingEnabled, route, buildId, seedData, clientModules, requestKey, segmentTasks) {\n    // Metadata about the segment. Sent as part of the tree prefetch. Null if\n    // there are no children.\n    let slotMetadata = null;\n    const children = route[1];\n    const seedDataChildren = seedData !== null ? seedData[2] : null;\n    for(const parallelRouteKey in children){\n        const childRoute = children[parallelRouteKey];\n        const childSegment = childRoute[0];\n        const childSeedData = seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null;\n        const childRequestKey = appendSegmentRequestKeyPart(requestKey, parallelRouteKey, createSegmentRequestKeyPart(childSegment));\n        const childTree = collectSegmentDataImpl(isClientParamParsingEnabled, childRoute, buildId, childSeedData, clientModules, childRequestKey, segmentTasks);\n        if (slotMetadata === null) {\n            slotMetadata = {};\n        }\n        slotMetadata[parallelRouteKey] = childTree;\n    }\n    if (seedData !== null) {\n        // Spawn a task to write the segment data to a new Flight stream.\n        segmentTasks.push(// Since we're already in the middle of a render, wait until after the\n        // current task to escape the current rendering context.\n        waitAtLeastOneReactRenderTask().then(()=>renderSegmentPrefetch(buildId, seedData, requestKey, clientModules)));\n    } else {\n    // This segment does not have any seed data. Skip generating a prefetch\n    // response for it. We'll still include it in the route tree, though.\n    // TODO: We should encode in the route tree whether a segment is missing\n    // so we don't attempt to fetch it for no reason. As of now this shouldn't\n    // ever happen in practice, though.\n    }\n    const segment = route[0];\n    let name;\n    let paramType = null;\n    let paramKey = null;\n    if (typeof segment === 'string') {\n        name = segment;\n        paramKey = segment;\n        paramType = null;\n    } else {\n        name = segment[0];\n        paramKey = segment[1];\n        paramType = segment[2];\n    }\n    // Metadata about the segment. Sent to the client as part of the\n    // tree prefetch.\n    return {\n        name,\n        paramType,\n        // This value is ommitted from the prefetch response when clientParamParsing\n        // is enabled. The flag only exists while we're testing the feature, in\n        // case there's a bug and we need to revert.\n        // TODO: Remove once clientParamParsing is enabled everywhere.\n        paramKey: isClientParamParsingEnabled ? null : paramKey,\n        slots: slotMetadata,\n        isRootLayout: route[4] === true\n    };\n}\nasync function renderSegmentPrefetch(buildId, seedData, requestKey, clientModules) {\n    // Render the segment data to a stream.\n    // In the future, this is where we can include additional metadata, like the\n    // stale time and cache tags.\n    const rsc = seedData[1];\n    const loading = seedData[3];\n    const segmentPrefetch = {\n        buildId,\n        rsc,\n        loading,\n        isPartial: await isPartialRSCData(rsc, clientModules)\n    };\n    // Since all we're doing is decoding and re-encoding a cached prerender, if\n    // it takes longer than a microtask, it must because of hanging promises\n    // caused by dynamic data. Abort the stream at the end of the current task.\n    const abortController = new AbortController();\n    waitAtLeastOneReactRenderTask().then(()=>abortController.abort());\n    const { prelude: segmentStream } = await prerender(segmentPrefetch, clientModules, {\n        filterStackFrame,\n        signal: abortController.signal,\n        onError: onSegmentPrerenderError\n    });\n    const segmentBuffer = await streamToBuffer(segmentStream);\n    if (requestKey === ROOT_SEGMENT_REQUEST_KEY) {\n        return [\n            '/_index',\n            segmentBuffer\n        ];\n    } else {\n        return [\n            requestKey,\n            segmentBuffer\n        ];\n    }\n}\nasync function isPartialRSCData(rsc, clientModules) {\n    // We can determine if a segment contains only partial data if it takes longer\n    // than a task to encode, because dynamic data is encoded as an infinite\n    // promise. We must do this in a separate Flight prerender from the one that\n    // actually generates the prefetch stream because we need to include\n    // `isPartial` in the stream itself.\n    let isPartial = false;\n    const abortController = new AbortController();\n    waitAtLeastOneReactRenderTask().then(()=>{\n        // If we haven't yet finished the outer task, then it must be because we\n        // accessed dynamic data.\n        isPartial = true;\n        abortController.abort();\n    });\n    await prerender(rsc, clientModules, {\n        filterStackFrame,\n        signal: abortController.signal,\n        onError () {},\n        onPostpone () {\n            // If something postponed, i.e. when Cache Components is not enabled, we can\n            // infer that the RSC data is partial.\n            isPartial = true;\n        }\n    });\n    return isPartial;\n}\nfunction createUnclosingPrefetchStream(originalFlightStream) {\n    // When PPR is enabled, prefetch streams may contain references that never\n    // resolve, because that's how we encode dynamic data access. In the decoded\n    // object returned by the Flight client, these are reified into hanging\n    // promises that suspend during render, which is effectively what we want.\n    // The UI resolves when it switches to the dynamic data stream\n    // (via useDeferredValue(dynamic, static)).\n    //\n    // However, the Flight implementation currently errors if the server closes\n    // the response before all the references are resolved. As a cheat to work\n    // around this, we wrap the original stream in a new stream that never closes,\n    // and therefore doesn't error.\n    const reader = originalFlightStream.getReader();\n    return new ReadableStream({\n        async pull (controller) {\n            while(true){\n                const { done, value } = await reader.read();\n                if (!done) {\n                    // Pass to the target stream and keep consuming the Flight response\n                    // from the server.\n                    controller.enqueue(value);\n                    continue;\n                }\n                // The server stream has closed. Exit, but intentionally do not close\n                // the target stream.\n                return;\n            }\n        }\n    });\n}\n\n//# sourceMappingURL=collect-segment-data.js.map"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1834, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/frontend/node_modules/next/dist/esm/server/app-render/entry-base.js"],"sourcesContent":["// eslint-disable-next-line import/no-extraneous-dependencies\nexport { createTemporaryReferenceSet, renderToReadableStream, decodeReply, decodeAction, decodeFormState } from 'react-server-dom-webpack/server';\n// eslint-disable-next-line import/no-extraneous-dependencies\nexport { unstable_prerender as prerender } from 'react-server-dom-webpack/static';\n// eslint-disable-next-line import/no-extraneous-dependencies\nexport { captureOwnerStack } from 'react';\nexport { default as LayoutRouter } from '../../client/components/layout-router';\nexport { default as RenderFromTemplateContext } from '../../client/components/render-from-template-context';\nexport { workAsyncStorage } from '../app-render/work-async-storage.external';\nexport { workUnitAsyncStorage } from './work-unit-async-storage.external';\nexport { actionAsyncStorage } from '../app-render/action-async-storage.external';\nexport { ClientPageRoot } from '../../client/components/client-page';\nexport { ClientSegmentRoot } from '../../client/components/client-segment';\nexport { createServerSearchParamsForServerPage, createPrerenderSearchParamsForClientPage } from '../request/search-params';\nexport { createServerParamsForServerSegment, createPrerenderParamsForClientSegment } from '../request/params';\nexport * as serverHooks from '../../client/components/hooks-server-context';\nexport { HTTPAccessFallbackBoundary } from '../../client/components/http-access-fallback/error-boundary';\nexport { createMetadataComponents } from '../../lib/metadata/metadata';\nexport { MetadataBoundary, ViewportBoundary, OutletBoundary, RootLayoutBoundary } from '../../lib/framework/boundary-components';\nexport { preloadStyle, preloadFont, preconnect } from './rsc/preloads';\nexport { Postpone } from './rsc/postpone';\nexport { taintObjectReference } from './rsc/taint';\nexport { collectSegmentData } from './collect-segment-data';\nimport { workAsyncStorage } from '../app-render/work-async-storage.external';\nimport { workUnitAsyncStorage } from './work-unit-async-storage.external';\nimport { patchFetch as _patchFetch } from '../lib/patch-fetch';\nlet SegmentViewNode = ()=>null;\nlet SegmentViewStateNode = ()=>null;\nif (process.env.NODE_ENV === 'development') {\n    const mod = require('../../next-devtools/userspace/app/segment-explorer-node');\n    SegmentViewNode = mod.SegmentViewNode;\n    SegmentViewStateNode = mod.SegmentViewStateNode;\n}\n// hot-reloader modules are not bundled so we need to inject `__next__clear_chunk_cache__`\n// into globalThis from this file which is bundled.\nif (process.env.TURBOPACK) {\n    globalThis.__next__clear_chunk_cache__ = __turbopack_clear_chunk_cache__;\n} else {\n    // Webpack does not have chunks on the server\n    globalThis.__next__clear_chunk_cache__ = null;\n}\n// patchFetch makes use of APIs such as `React.unstable_postpone` which are only available\n// in the experimental channel of React, so export it from here so that it comes from the bundled runtime\nexport function patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\n// Development only\nexport { SegmentViewNode, SegmentViewStateNode };\n\n//# sourceMappingURL=entry-base.js.map"],"names":[],"mappings":"AAAA,6DAA6D;;;;;;;;;AAC7D;AACA,6DAA6D;AAC7D;AACA,6DAA6D;AAC7D;;;;;;;;;;;;;;;;;;;;;AAKA;AACA;AACA;;;;;;;;;;;;;;;;AAIA;;;;;;AAEA;;;;;;;;;;;;;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA,IAAI,kBAAkB,IAAI;AAC1B,IAAI,uBAAuB,IAAI;AAC/B,wCAA4C;IACxC,MAAM;;;;;IACN,kBAAkB,IAAI,eAAe;IACrC,uBAAuB,IAAI,oBAAoB;AACnD;AACA,0FAA0F;AAC1F,mDAAmD;AACnD,wCAA2B;IACvB,WAAW,2BAA2B;AAC1C;;AAMO,SAAS;IACZ,OAAO,YAAY;QACf;QACA;IACJ;AACJ;;CAIA,sCAAsC","ignoreList":[0],"debugId":null}}]
}