{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/router-reducer/router-reducer-types.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../server/app-render/types'\nimport type { FetchServerResponseResult } from './fetch-server-response'\n\nexport const ACTION_REFRESH = 'refresh'\nexport const ACTION_NAVIGATE = 'navigate'\nexport const ACTION_RESTORE = 'restore'\nexport const ACTION_SERVER_PATCH = 'server-patch'\nexport const ACTION_PREFETCH = 'prefetch'\nexport const ACTION_HMR_REFRESH = 'hmr-refresh'\nexport const ACTION_SERVER_ACTION = 'server-action'\n\nexport type RouterChangeByServerResponse = ({\n  navigatedAt,\n  previousTree,\n  serverResponse,\n}: {\n  navigatedAt: number\n  previousTree: FlightRouterState\n  serverResponse: FetchServerResponseResult\n}) => void\n\nexport interface Mutable {\n  mpaNavigation?: boolean\n  patchedTree?: FlightRouterState\n  canonicalUrl?: string\n  scrollableSegments?: FlightSegmentPath[]\n  pendingPush?: boolean\n  cache?: CacheNode\n  prefetchCache?: AppRouterState['prefetchCache']\n  hashFragment?: string\n  shouldScroll?: boolean\n  preserveCustomHistoryState?: boolean\n  onlyHashChange?: boolean\n}\n\nexport interface ServerActionMutable extends Mutable {\n  inFlightServerAction?: Promise<any> | null\n}\n\n/**\n * Refresh triggers a refresh of the full page data.\n * - fetches the Flight data and fills rsc at the root of the cache.\n * - The router state is updated at the root.\n */\nexport interface RefreshAction {\n  type: typeof ACTION_REFRESH\n  origin: Location['origin']\n}\n\nexport interface HmrRefreshAction {\n  type: typeof ACTION_HMR_REFRESH\n  origin: Location['origin']\n}\n\nexport type ServerActionDispatcher = (\n  args: Omit<\n    ServerActionAction,\n    'type' | 'mutable' | 'navigate' | 'changeByServerResponse' | 'cache'\n  >\n) => void\n\nexport interface ServerActionAction {\n  type: typeof ACTION_SERVER_ACTION\n  actionId: string\n  actionArgs: any[]\n  resolve: (value: any) => void\n  reject: (reason?: any) => void\n}\n\n/**\n * Navigate triggers a navigation to the provided url. It supports two types: `push` and `replace`.\n *\n * `navigateType`:\n * - `push` - pushes a new history entry in the browser history\n * - `replace` - replaces the current history entry in the browser history\n *\n * Navigate has multiple cache heuristics:\n * - page was prefetched\n *  - Apply router state tree from prefetch\n *  - Apply Flight data from prefetch to the cache\n *  - If Flight data is a string, it's a redirect and the state is updated to trigger a redirect\n *  - Check if hard navigation is needed\n *    - Hard navigation happens when a dynamic parameter below the common layout changed\n *    - When hard navigation is needed the cache is invalidated below the flightSegmentPath\n *    - The missing cache nodes of the page will be fetched in layout-router and trigger the SERVER_PATCH action\n *  - If hard navigation is not needed\n *    - The cache is reused\n *    - If any cache nodes are missing they'll be fetched in layout-router and trigger the SERVER_PATCH action\n * - page was not prefetched\n *  - The navigate was called from `next/router` (`router.push()` / `router.replace()`) / `next/link` without prefetched data available (e.g. the prefetch didn't come back from the server before clicking the link)\n *    - Flight data is fetched in the reducer (suspends the reducer)\n *    - Router state tree is created based on Flight data\n *    - Cache is filled based on the Flight data\n *\n * Above steps explain 3 cases:\n * - `soft` - Reuses the existing cache and fetches missing nodes in layout-router.\n * - `hard` - Creates a new cache where cache nodes are removed below the common layout and fetches missing nodes in layout-router.\n * - `optimistic` (explicit no prefetch) - Creates a new cache and kicks off the data fetch in the reducer. The data fetch is awaited in the layout-router.\n */\nexport interface NavigateAction {\n  type: typeof ACTION_NAVIGATE\n  url: URL\n  isExternalUrl: boolean\n  locationSearch: Location['search']\n  navigateType: 'push' | 'replace'\n  shouldScroll: boolean\n  allowAliasing: boolean\n}\n\n/**\n * Restore applies the provided router state.\n * - Used for `popstate` (back/forward navigation) where a known router state has to be applied.\n * - Also used when syncing the router state with `pushState`/`replaceState` calls.\n * - Router state is applied as-is from the history state, if available.\n * - If the history state does not contain the router state, the existing router state is used.\n * - If any cache node is missing it will be fetched in layout-router during rendering and the server-patch case.\n * - If existing cache nodes match these are used.\n */\nexport interface RestoreAction {\n  type: typeof ACTION_RESTORE\n  url: URL\n  tree: FlightRouterState | undefined\n}\n\n/**\n * Server-patch applies the provided Flight data to the cache and router tree.\n * - Only triggered in layout-router.\n * - Creates a new cache and router state with the Flight data applied.\n */\nexport interface ServerPatchAction {\n  type: typeof ACTION_SERVER_PATCH\n  navigatedAt: number\n  serverResponse: FetchServerResponseResult\n  previousTree: FlightRouterState\n}\n\n/**\n * PrefetchKind defines the type of prefetching that should be done.\n * - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.\n * - `full` - prefetch the page data fully.\n * - `temporary` - a temporary prefetch entry is added to the cache, this is used when prefetch={false} is used in next/link or when you push a route programmatically.\n */\n\nexport enum PrefetchKind {\n  AUTO = 'auto',\n  FULL = 'full',\n  TEMPORARY = 'temporary',\n}\n\n/**\n * Prefetch adds the provided FlightData to the prefetch cache\n * - Creates the router state tree based on the patch in FlightData\n * - Adds the FlightData to the prefetch cache\n * - In ACTION_NAVIGATE the prefetch cache is checked and the router state tree and FlightData are applied.\n */\nexport interface PrefetchAction {\n  type: typeof ACTION_PREFETCH\n  url: URL\n  kind: PrefetchKind\n}\n\nexport interface PushRef {\n  /**\n   * If the app-router should push a new history entry in app-router's useEffect()\n   */\n  pendingPush: boolean\n  /**\n   * Multi-page navigation through location.href.\n   */\n  mpaNavigation: boolean\n  /**\n   * Skip applying the router state to the browser history state.\n   */\n  preserveCustomHistoryState: boolean\n}\n\nexport type FocusAndScrollRef = {\n  /**\n   * If focus and scroll should be set in the layout-router's useEffect()\n   */\n  apply: boolean\n  /**\n   * The hash fragment that should be scrolled to.\n   */\n  hashFragment: string | null\n  /**\n   * The paths of the segments that should be focused.\n   */\n  segmentPaths: FlightSegmentPath[]\n  /**\n   * If only the URLs hash fragment changed\n   */\n  onlyHashChange: boolean\n}\n\nexport type PrefetchCacheEntry = {\n  treeAtTimeOfPrefetch: FlightRouterState\n  data: Promise<FetchServerResponseResult>\n  kind: PrefetchKind\n  prefetchTime: number\n  staleTime: number\n  lastUsedTime: number | null\n  key: string\n  status: PrefetchCacheEntryStatus\n  url: URL\n}\n\nexport enum PrefetchCacheEntryStatus {\n  fresh = 'fresh',\n  reusable = 'reusable',\n  expired = 'expired',\n  stale = 'stale',\n}\n\n/**\n * Handles keeping the state of app-router.\n */\nexport type AppRouterState = {\n  /**\n   * The router state, this is written into the history state in app-router using replaceState/pushState.\n   * - Has to be serializable as it is written into the history state.\n   * - Holds which segments and parallel routes are shown on the screen.\n   */\n  tree: FlightRouterState\n  /**\n   * The cache holds React nodes for every segment that is shown on screen as well as previously shown segments.\n   * It also holds in-progress data requests.\n   * Prefetched data is stored separately in `prefetchCache`, that is applied during ACTION_NAVIGATE.\n   */\n  cache: CacheNode\n  /**\n   * Cache that holds prefetched Flight responses keyed by url.\n   */\n  prefetchCache: Map<string, PrefetchCacheEntry>\n  /**\n   * Decides if the update should create a new history entry and if the navigation has to trigger a browser navigation.\n   */\n  pushRef: PushRef\n  /**\n   * Decides if the update should apply scroll and focus management.\n   */\n  focusAndScrollRef: FocusAndScrollRef\n  /**\n   * The canonical url that is pushed/replaced.\n   * - This is the url you see in the browser.\n   */\n  canonicalUrl: string\n  /**\n   * The underlying \"url\" representing the UI state, which is used for intercepting routes.\n   */\n  nextUrl: string | null\n}\n\nexport type ReadonlyReducerState = Readonly<AppRouterState>\nexport type ReducerState = Promise<AppRouterState> | AppRouterState\nexport type ReducerActions = Readonly<\n  | RefreshAction\n  | NavigateAction\n  | RestoreAction\n  | ServerPatchAction\n  | PrefetchAction\n  | HmrRefreshAction\n  | ServerActionAction\n>\n"],"names":["ACTION_HMR_REFRESH","ACTION_NAVIGATE","ACTION_PREFETCH","ACTION_REFRESH","ACTION_RESTORE","ACTION_SERVER_ACTION","ACTION_SERVER_PATCH","PrefetchCacheEntryStatus","PrefetchKind"],"mappings":";;;;;;;;;;;;;;;;;;;;;IAYaA,kBAAkB,EAAA;eAAlBA;;IAJAC,eAAe,EAAA;eAAfA;;IAGAC,eAAe,EAAA;eAAfA;;IAJAC,cAAc,EAAA;eAAdA;;IAEAC,cAAc,EAAA;eAAdA;;IAIAC,oBAAoB,EAAA;eAApBA;;IAHAC,mBAAmB,EAAA;eAAnBA;;IAyMDC,wBAAwB,EAAA;eAAxBA;;IAhEAC,YAAY,EAAA;eAAZA;;;AA5IL,MAAML,iBAAiB;AACvB,MAAMF,kBAAkB;AACxB,MAAMG,iBAAiB;AACvB,MAAME,sBAAsB;AAC5B,MAAMJ,kBAAkB;AACxB,MAAMF,qBAAqB;AAC3B,MAAMK,uBAAuB;AAsI7B,IAAKG,eAAAA,WAAAA,GAAAA,SAAAA,YAAAA;;;;WAAAA;;AAgEL,IAAKD,2BAAAA,WAAAA,GAAAA,SAAAA,wBAAAA;;;;;WAAAA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 84, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/shared/lib/app-router-context.shared-runtime.ts"],"sourcesContent":["'use client'\n\nimport type { FetchServerResponseResult } from '../../client/components/router-reducer/fetch-server-response'\nimport type {\n  FocusAndScrollRef,\n  PrefetchKind,\n} from '../../client/components/router-reducer/router-reducer-types'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../server/app-render/types'\nimport React from 'react'\n\nexport type ChildSegmentMap = Map<string, CacheNode>\n\n/**\n * Cache node used in app-router / layout-router.\n */\nexport type CacheNode = ReadyCacheNode | LazyCacheNode\n\nexport type LoadingModuleData =\n  | [React.JSX.Element, React.ReactNode, React.ReactNode]\n  | null\n\n/** viewport metadata node */\nexport type HeadData = React.ReactNode\n\nexport type LazyCacheNode = {\n  /**\n   * When rsc is null, this is a lazily-initialized cache node.\n   *\n   * If the app attempts to render it, it triggers a lazy data fetch,\n   * postpones the render, and schedules an update to a new tree.\n   *\n   * TODO: This mechanism should not be used when PPR is enabled, though it\n   * currently is in some cases until we've implemented partial\n   * segment fetching.\n   */\n  rsc: null\n\n  /**\n   * A prefetched version of the segment data. See explanation in corresponding\n   * field of ReadyCacheNode (below).\n   *\n   * Since LazyCacheNode mostly only exists in the non-PPR implementation, this\n   * will usually be null, but it could have been cloned from a previous\n   * CacheNode that was created by the PPR implementation. Eventually we want\n   * to migrate everything away from LazyCacheNode entirely.\n   */\n  prefetchRsc: React.ReactNode\n\n  /**\n   * A pending response for the lazy data fetch. If this is not present\n   * during render, it is lazily created.\n   */\n  lazyData: Promise<FetchServerResponseResult> | null\n\n  prefetchHead: HeadData | null\n\n  head: HeadData\n\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n\n  /**\n   * Child parallel routes.\n   */\n  parallelRoutes: Map<string, ChildSegmentMap>\n\n  /**\n   * The timestamp of the navigation that last updated the CacheNode's data. If\n   * a CacheNode is reused from a previous navigation, this value is not\n   * updated. Used to track the staleness of the data.\n   */\n  navigatedAt: number\n}\n\nexport type ReadyCacheNode = {\n  /**\n   * When rsc is not null, it represents the RSC data for the\n   * corresponding segment.\n   *\n   * `null` is a valid React Node but because segment data is always a\n   * <LayoutRouter> component, we can use `null` to represent empty.\n   *\n   * TODO: For additional type safety, update this type to\n   * Exclude<React.ReactNode, null>. Need to update createEmptyCacheNode to\n   * accept rsc as an argument, or just inline the callers.\n   */\n  rsc: React.ReactNode\n\n  /**\n   * Represents a static version of the segment that can be shown immediately,\n   * and may or may not contain dynamic holes. It's prefetched before a\n   * navigation occurs.\n   *\n   * During rendering, we will choose whether to render `rsc` or `prefetchRsc`\n   * with `useDeferredValue`. As with the `rsc` field, a value of `null` means\n   * no value was provided. In this case, the LayoutRouter will go straight to\n   * rendering the `rsc` value; if that one is also missing, it will suspend and\n   * trigger a lazy fetch.\n   */\n  prefetchRsc: React.ReactNode\n\n  /**\n   * There should never be a lazy data request in this case.\n   */\n  lazyData: null\n  prefetchHead: HeadData | null\n\n  head: HeadData\n\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n\n  parallelRoutes: Map<string, ChildSegmentMap>\n\n  navigatedAt: number\n}\n\nexport interface NavigateOptions {\n  scroll?: boolean\n}\n\nexport interface PrefetchOptions {\n  kind: PrefetchKind\n  onInvalidate?: () => void\n}\n\nexport interface AppRouterInstance {\n  /**\n   * Navigate to the previous history entry.\n   */\n  back(): void\n  /**\n   * Navigate to the next history entry.\n   */\n  forward(): void\n  /**\n   * Refresh the current page.\n   */\n  refresh(): void\n  /**\n   * Refresh the current page. Use in development only.\n   * @internal\n   */\n  hmrRefresh(): void\n  /**\n   * Navigate to the provided href.\n   * Pushes a new history entry.\n   */\n  push(href: string, options?: NavigateOptions): void\n  /**\n   * Navigate to the provided href.\n   * Replaces the current history entry.\n   */\n  replace(href: string, options?: NavigateOptions): void\n  /**\n   * Prefetch the provided href.\n   */\n  prefetch(href: string, options?: PrefetchOptions): void\n}\n\nexport const AppRouterContext = React.createContext<AppRouterInstance | null>(\n  null\n)\nexport const LayoutRouterContext = React.createContext<{\n  parentTree: FlightRouterState\n  parentCacheNode: CacheNode\n  parentSegmentPath: FlightSegmentPath | null\n  url: string\n} | null>(null)\n\nexport const GlobalLayoutRouterContext = React.createContext<{\n  tree: FlightRouterState\n  focusAndScrollRef: FocusAndScrollRef\n  nextUrl: string | null\n}>(null as any)\n\nexport const TemplateContext = React.createContext<React.ReactNode>(null as any)\n\nif (process.env.NODE_ENV !== 'production') {\n  AppRouterContext.displayName = 'AppRouterContext'\n  LayoutRouterContext.displayName = 'LayoutRouterContext'\n  GlobalLayoutRouterContext.displayName = 'GlobalLayoutRouterContext'\n  TemplateContext.displayName = 'TemplateContext'\n}\n\nexport const MissingSlotContext = React.createContext<Set<string>>(new Set())\n"],"names":["AppRouterContext","GlobalLayoutRouterContext","LayoutRouterContext","MissingSlotContext","TemplateContext","React","createContext","process","env","NODE_ENV","displayName","Set"],"mappings":"AAmLIO,QAAQC,GAAG,CAACC,QAAQ,KAAK;AAnL7B;;;;;;;;;;;;;;;;;;;IAiKaT,gBAAgB,EAAA;eAAhBA;;IAUAC,yBAAyB,EAAA;eAAzBA;;IAPAC,mBAAmB,EAAA;eAAnBA;;IAsBAC,kBAAkB,EAAA;eAAlBA;;IATAC,eAAe,EAAA;eAAfA;;;;gEAtKK;AAsJX,MAAMJ,mBAAmBK,OAAAA,OAAK,CAACC,aAAa,CACjD;AAEK,MAAMJ,sBAAsBG,OAAAA,OAAK,CAACC,aAAa,CAK5C;AAEH,MAAML,4BAA4BI,OAAAA,OAAK,CAACC,aAAa,CAIzD;AAEI,MAAMF,kBAAkBC,OAAAA,OAAK,CAACC,aAAa,CAAkB;AAEpE,wCAA2C;IACzCN,iBAAiBU,WAAW,GAAG;IAC/BR,oBAAoBQ,WAAW,GAAG;IAClCT,0BAA0BS,WAAW,GAAG;IACxCN,gBAAgBM,WAAW,GAAG;AAChC;AAEO,MAAMP,qBAAqBE,OAAAA,OAAK,CAACC,aAAa,CAAc,IAAIK","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 137, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/app-router-headers.ts"],"sourcesContent":["export const RSC_HEADER = 'rsc' as const\nexport const ACTION_HEADER = 'next-action' as const\n// TODO: Instead of sending the full router state, we only need to send the\n// segment path. Saves bytes. Then we could also use this field for segment\n// prefetches, which also need to specify a particular segment.\nexport const NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree' as const\nexport const NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch' as const\n// This contains the path to the segment being prefetched.\n// TODO: If we change next-router-state-tree to be a segment path, we can use\n// that instead. Then next-router-prefetch and next-router-segment-prefetch can\n// be merged into a single enum.\nexport const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER =\n  'next-router-segment-prefetch' as const\nexport const NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh' as const\nexport const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__' as const\nexport const NEXT_URL = 'next-url' as const\nexport const RSC_CONTENT_TYPE_HEADER = 'text/x-component' as const\n\nexport const FLIGHT_HEADERS = [\n  RSC_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n] as const\n\nexport const NEXT_RSC_UNION_QUERY = '_rsc' as const\n\nexport const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time' as const\nexport const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed' as const\nexport const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path' as const\nexport const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query' as const\nexport const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender' as const\nexport const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found' as const\n"],"names":["ACTION_HEADER","FLIGHT_HEADERS","NEXT_ACTION_NOT_FOUND_HEADER","NEXT_DID_POSTPONE_HEADER","NEXT_HMR_REFRESH_HASH_COOKIE","NEXT_HMR_REFRESH_HEADER","NEXT_IS_PRERENDER_HEADER","NEXT_REWRITTEN_PATH_HEADER","NEXT_REWRITTEN_QUERY_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STALE_TIME_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_RSC_UNION_QUERY","NEXT_URL","RSC_CONTENT_TYPE_HEADER","RSC_HEADER"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;IACaA,aAAa,EAAA;eAAbA;;IAiBAC,cAAc,EAAA;eAAdA;;IAeAC,4BAA4B,EAAA;eAA5BA;;IAJAC,wBAAwB,EAAA;eAAxBA;;IAfAC,4BAA4B,EAAA;eAA5BA;;IADAC,uBAAuB,EAAA;eAAvBA;;IAmBAC,wBAAwB,EAAA;eAAxBA;;IAFAC,0BAA0B,EAAA;eAA1BA;;IACAC,2BAA2B,EAAA;eAA3BA;;IAzBAC,2BAA2B,EAAA;eAA3BA;;IAKAC,mCAAmC,EAAA;eAAnCA;;IAiBAC,6BAA6B,EAAA;eAA7BA;;IAvBAC,6BAA6B,EAAA;eAA7BA;;IAqBAC,oBAAoB,EAAA;eAApBA;;IAXAC,QAAQ,EAAA;eAARA;;IACAC,uBAAuB,EAAA;eAAvBA;;IAhBAC,UAAU,EAAA;eAAVA;;;AAAN,MAAMA,aAAa;AACnB,MAAMhB,gBAAgB;AAItB,MAAMY,gCAAgC;AACtC,MAAMH,8BAA8B;AAKpC,MAAMC,sCACX;AACK,MAAML,0BAA0B;AAChC,MAAMD,+BAA+B;AACrC,MAAMU,WAAW;AACjB,MAAMC,0BAA0B;AAEhC,MAAMd,iBAAiB;IAC5Be;IACAJ;IACAH;IACAJ;IACAK;CACD;AAEM,MAAMG,uBAAuB;AAE7B,MAAMF,gCAAgC;AACtC,MAAMR,2BAA2B;AACjC,MAAMI,6BAA6B;AACnC,MAAMC,8BAA8B;AACpC,MAAMF,2BAA2B;AACjC,MAAMJ,+BAA+B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 252, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/shared/lib/is-thenable.ts"],"sourcesContent":["/**\n * Check to see if a value is Thenable.\n *\n * @param promise the maybe-thenable value\n * @returns true if the value is thenable\n */\nexport function isThenable<T = unknown>(\n  promise: Promise<T> | T\n): promise is Promise<T> {\n  return (\n    promise !== null &&\n    typeof promise === 'object' &&\n    'then' in promise &&\n    typeof promise.then === 'function'\n  )\n}\n"],"names":["isThenable","promise","then"],"mappings":"AAAA;;;;;CAKC;;;+BACeA,cAAAA;;;eAAAA;;;AAAT,SAASA,WACdC,OAAuB;IAEvB,OACEA,YAAY,QACZ,OAAOA,YAAY,YACnB,UAAUA,WACV,OAAOA,QAAQC,IAAI,KAAK;AAE5B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 273, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/next-devtools/userspace/use-app-dev-rendering-indicator.tsx"],"sourcesContent":["'use client'\n\nimport { useEffect, useTransition } from 'react'\nimport { dispatcher } from 'next/dist/compiled/next-devtools'\n\nexport const useAppDevRenderingIndicator = () => {\n  const [isPending, startTransition] = useTransition()\n\n  useEffect(() => {\n    if (isPending) {\n      dispatcher.renderingIndicatorShow()\n    } else {\n      dispatcher.renderingIndicatorHide()\n    }\n  }, [isPending])\n\n  return startTransition\n}\n"],"names":["useAppDevRenderingIndicator","isPending","startTransition","useTransition","useEffect","dispatcher","renderingIndicatorShow","renderingIndicatorHide"],"mappings":";;;+BAKaA,+BAAAA;;;eAAAA;;;uBAH4B;8BACd;AAEpB,MAAMA,8BAA8B;IACzC,MAAM,CAACC,WAAWC,gBAAgB,GAAGC,CAAAA,GAAAA,OAAAA,aAAa;IAElDC,CAAAA,GAAAA,OAAAA,SAAS,EAAC;QACR,IAAIH,WAAW;YACbI,cAAAA,UAAU,CAACC,sBAAsB;QACnC,OAAO;YACLD,cAAAA,UAAU,CAACE,sBAAsB;QACnC;IACF,GAAG;QAACN;KAAU;IAEd,OAAOC;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 308, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/use-action-queue.ts"],"sourcesContent":["import type { Dispatch } from 'react'\nimport React, { use } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport type { AppRouterActionQueue } from './app-router-instance'\nimport type {\n  AppRouterState,\n  ReducerActions,\n  ReducerState,\n} from './router-reducer/router-reducer-types'\n\n// The app router state lives outside of React, so we can import the dispatch\n// method directly wherever we need it, rather than passing it around via props\n// or context.\nlet dispatch: Dispatch<ReducerActions> | null = null\n\nexport function dispatchAppRouterAction(action: ReducerActions) {\n  if (dispatch === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  dispatch(action)\n}\n\nexport function useActionQueue(\n  actionQueue: AppRouterActionQueue\n): AppRouterState {\n  const [state, setState] = React.useState<ReducerState>(actionQueue.state)\n\n  // Because of a known issue that requires to decode Flight streams inside the\n  // render phase, we have to be a bit clever and assign the dispatch method to\n  // a module-level variable upon initialization. The useState hook in this\n  // module only exists to synchronize state that lives outside of React.\n  // Ideally, what we'd do instead is pass the state as a prop to root.render;\n  // this is conceptually how we're modeling the app router state, despite the\n  // weird implementation details.\n  if (process.env.NODE_ENV !== 'production') {\n    const { useAppDevRenderingIndicator } =\n      require('../../next-devtools/userspace/use-app-dev-rendering-indicator') as typeof import('../../next-devtools/userspace/use-app-dev-rendering-indicator')\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const appDevRenderingIndicator = useAppDevRenderingIndicator()\n\n    dispatch = (action: ReducerActions) => {\n      appDevRenderingIndicator(() => {\n        actionQueue.dispatch(action, setState)\n      })\n    }\n  } else {\n    dispatch = (action: ReducerActions) =>\n      actionQueue.dispatch(action, setState)\n  }\n\n  return isThenable(state) ? use(state) : state\n}\n"],"names":["dispatchAppRouterAction","useActionQueue","dispatch","action","Error","actionQueue","state","setState","React","useState","process","env","NODE_ENV","useAppDevRenderingIndicator","require","appDevRenderingIndicator","isThenable","use"],"mappings":"AAoCMU,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;;;;;;;;;;;;IArBfZ,uBAAuB,EAAA;eAAvBA;;IASAC,cAAc,EAAA;eAAdA;;;;iEAvBW;4BACA;AAQ3B,6EAA6E;AAC7E,+EAA+E;AAC/E,cAAc;AACd,IAAIC,WAA4C;AAEzC,SAASF,wBAAwBG,MAAsB;IAC5D,IAAID,aAAa,MAAM;QACrB,MAAM,OAAA,cAEL,CAFK,IAAIE,MACR,4EADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IACAF,SAASC;AACX;AAEO,SAASF,eACdI,WAAiC;IAEjC,MAAM,CAACC,OAAOC,SAAS,GAAGC,OAAAA,OAAK,CAACC,QAAQ,CAAeJ,YAAYC,KAAK;IAExE,6EAA6E;IAC7E,6EAA6E;IAC7E,yEAAyE;IACzE,uEAAuE;IACvE,4EAA4E;IAC5E,4EAA4E;IAC5E,gCAAgC;IAChC,wCAA2C;QACzC,MAAM,EAAEO,2BAA2B,EAAE,GACnCC,QAAQ;QACV,sDAAsD;QACtD,MAAMC,2BAA2BF;QAEjCX,WAAW,CAACC;YACVY,yBAAyB;gBACvBV,YAAYH,QAAQ,CAACC,QAAQI;YAC/B;QACF;IACF,OAAO;;IAKP,OAAOS,CAAAA,GAAAA,YAAAA,UAAU,EAACV,SAASW,CAAAA,GAAAA,OAAAA,GAAG,EAACX,SAASA;AAC1C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 381, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/app-call-server.ts"],"sourcesContent":["import { startTransition } from 'react'\nimport { ACTION_SERVER_ACTION } from './components/router-reducer/router-reducer-types'\nimport { dispatchAppRouterAction } from './components/use-action-queue'\n\nexport async function callServer(actionId: string, actionArgs: any[]) {\n  return new Promise((resolve, reject) => {\n    startTransition(() => {\n      dispatchAppRouterAction({\n        type: ACTION_SERVER_ACTION,\n        actionId,\n        actionArgs,\n        resolve,\n        reject,\n      })\n    })\n  })\n}\n"],"names":["callServer","actionId","actionArgs","Promise","resolve","reject","startTransition","dispatchAppRouterAction","type","ACTION_SERVER_ACTION"],"mappings":";;;+BAIsBA,cAAAA;;;eAAAA;;;uBAJU;oCACK;gCACG;AAEjC,eAAeA,WAAWC,QAAgB,EAAEC,UAAiB;IAClE,OAAO,IAAIC,QAAQ,CAACC,SAASC;QAC3BC,CAAAA,GAAAA,OAAAA,eAAe,EAAC;YACdC,CAAAA,GAAAA,gBAAAA,uBAAuB,EAAC;gBACtBC,MAAMC,oBAAAA,oBAAoB;gBAC1BR;gBACAC;gBACAE;gBACAC;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 417, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/app-find-source-map-url.ts"],"sourcesContent":["const basePath = process.env.__NEXT_ROUTER_BASEPATH || ''\nconst pathname = `${basePath}/__nextjs_source-map`\n\nexport const findSourceMapURL =\n  process.env.NODE_ENV === 'development'\n    ? function findSourceMapURL(filename: string): string | null {\n        if (filename === '') {\n          return null\n        }\n\n        if (\n          filename.startsWith(document.location.origin) &&\n          filename.includes('/_next/static')\n        ) {\n          // This is a request for a client chunk. This can only happen when\n          // using Turbopack. In this case, since we control how those source\n          // maps are generated, we can safely assume that the sourceMappingURL\n          // is relative to the filename, with an added `.map` extension. The\n          // browser can just request this file, and it gets served through the\n          // normal dev server, without the need to route this through\n          // the `/__nextjs_source-map` dev middleware.\n          return `${filename}.map`\n        }\n\n        const url = new URL(pathname, document.location.origin)\n        url.searchParams.set('filename', filename)\n\n        return url.href\n      }\n    : undefined\n"],"names":["findSourceMapURL","basePath","process","env","__NEXT_ROUTER_BASEPATH","pathname","NODE_ENV","filename","startsWith","document","location","origin","includes","url","URL","searchParams","set","href","undefined"],"mappings":"AAAiBE,QAAQC,GAAG,CAACC,sBAAsB;;;;;+BAGtCJ,oBAAAA;;;eAAAA;;;AAHb,MAAMC,mDAAiD;AACvD,MAAMI,WAAY,KAAEJ,WAAS;AAEtB,MAAMD,mBACXE,QAAQC,GAAG,CAACG,QAAQ,KAAK,cACrB,SAASN,iBAAiBO,QAAgB;IACxC,IAAIA,aAAa,IAAI;QACnB,OAAO;IACT;IAEA,IACEA,SAASC,UAAU,CAACC,SAASC,QAAQ,CAACC,MAAM,KAC5CJ,SAASK,QAAQ,CAAC,kBAClB;QACA,kEAAkE;QAClE,mEAAmE;QACnE,qEAAqE;QACrE,mEAAmE;QACnE,qEAAqE;QACrE,4DAA4D;QAC5D,6CAA6C;QAC7C,OAAQ,KAAEL,WAAS;IACrB;IAEA,MAAMM,MAAM,IAAIC,IAAIT,UAAUI,SAASC,QAAQ,CAACC,MAAM;IACtDE,IAAIE,YAAY,CAACC,GAAG,CAAC,YAAYT;IAEjC,OAAOM,IAAII,IAAI;AACjB,IACAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 459, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/shared/lib/segment.ts"],"sourcesContent":["import type { Segment } from '../../server/app-render/types'\n\nexport function isGroupSegment(segment: string) {\n  // Use array[0] for performant purpose\n  return segment[0] === '(' && segment.endsWith(')')\n}\n\nexport function isParallelRouteSegment(segment: string) {\n  return segment.startsWith('@') && segment !== '@children'\n}\n\nexport function addSearchParamsIfPageSegment(\n  segment: Segment,\n  searchParams: Record<string, string | string[] | undefined>\n) {\n  const isPageSegment = segment.includes(PAGE_SEGMENT_KEY)\n\n  if (isPageSegment) {\n    const stringifiedQuery = JSON.stringify(searchParams)\n    return stringifiedQuery !== '{}'\n      ? PAGE_SEGMENT_KEY + '?' + stringifiedQuery\n      : PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n\nexport const PAGE_SEGMENT_KEY = '__PAGE__'\nexport const DEFAULT_SEGMENT_KEY = '__DEFAULT__'\n"],"names":["DEFAULT_SEGMENT_KEY","PAGE_SEGMENT_KEY","addSearchParamsIfPageSegment","isGroupSegment","isParallelRouteSegment","segment","endsWith","startsWith","searchParams","isPageSegment","includes","stringifiedQuery","JSON","stringify"],"mappings":";;;;;;;;;;;;;;;;;IA4BaA,mBAAmB,EAAA;eAAnBA;;IADAC,gBAAgB,EAAA;eAAhBA;;IAhBGC,4BAA4B,EAAA;eAA5BA;;IATAC,cAAc,EAAA;eAAdA;;IAKAC,sBAAsB,EAAA;eAAtBA;;;AALT,SAASD,eAAeE,OAAe;IAC5C,sCAAsC;IACtC,OAAOA,OAAO,CAAC,EAAE,KAAK,OAAOA,QAAQC,QAAQ,CAAC;AAChD;AAEO,SAASF,uBAAuBC,OAAe;IACpD,OAAOA,QAAQE,UAAU,CAAC,QAAQF,YAAY;AAChD;AAEO,SAASH,6BACdG,OAAgB,EAChBG,YAA2D;IAE3D,MAAMC,gBAAgBJ,QAAQK,QAAQ,CAACT;IAEvC,IAAIQ,eAAe;QACjB,MAAME,mBAAmBC,KAAKC,SAAS,CAACL;QACxC,OAAOG,qBAAqB,OACxBV,mBAAmB,MAAMU,mBACzBV;IACN;IAEA,OAAOI;AACT;AAEO,MAAMJ,mBAAmB;AACzB,MAAMD,sBAAsB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 513, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/flight-data-helpers.ts"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightData,\n  FlightDataPath,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n} from '../server/app-render/types'\nimport type { HeadData } from '../shared/lib/app-router-context.shared-runtime'\nimport { PAGE_SEGMENT_KEY } from '../shared/lib/segment'\n\nexport type NormalizedFlightData = {\n  /**\n   * The full `FlightSegmentPath` inclusive of the final `Segment`\n   */\n  segmentPath: FlightSegmentPath\n  /**\n   * The `FlightSegmentPath` exclusive of the final `Segment`\n   */\n  pathToSegment: FlightSegmentPath\n  segment: Segment\n  tree: FlightRouterState\n  seedData: CacheNodeSeedData | null\n  head: HeadData\n  isHeadPartial: boolean\n  isRootRender: boolean\n}\n\n// TODO: We should only have to export `normalizeFlightData`, however because the initial flight data\n// that gets passed to `createInitialRouterState` doesn't conform to the `FlightDataPath` type (it's missing the root segment)\n// we're currently exporting it so we can use it directly. This should be fixed as part of the unification of\n// the different ways we express `FlightSegmentPath`.\nexport function getFlightDataPartsFromPath(\n  flightDataPath: FlightDataPath\n): NormalizedFlightData {\n  // Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].\n  const flightDataPathLength = 4\n  // tree, seedData, and head are *always* the last three items in the `FlightDataPath`.\n  const [tree, seedData, head, isHeadPartial] =\n    flightDataPath.slice(-flightDataPathLength)\n  // The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.\n  const segmentPath = flightDataPath.slice(0, -flightDataPathLength)\n\n  return {\n    // TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment (\"\")\n    // to the start of the segment path in some places which makes it hard to use solely the segment path.\n    // Look for \"// TODO-APP: remove ''\" in the codebase.\n    pathToSegment: segmentPath.slice(0, -1),\n    segmentPath,\n    // if the `FlightDataPath` corresponds with the root, there'll be no segment path,\n    // in which case we default to ''.\n    segment: segmentPath[segmentPath.length - 1] ?? '',\n    tree,\n    seedData,\n    head,\n    isHeadPartial,\n    isRootRender: flightDataPath.length === flightDataPathLength,\n  }\n}\n\nexport function getNextFlightSegmentPath(\n  flightSegmentPath: FlightSegmentPath\n): FlightSegmentPath {\n  // Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items\n  // to get the next segment path.\n  return flightSegmentPath.slice(2)\n}\n\nexport function normalizeFlightData(\n  flightData: FlightData\n): NormalizedFlightData[] | string {\n  // FlightData can be a string when the server didn't respond with a proper flight response,\n  // or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.\n  if (typeof flightData === 'string') {\n    return flightData\n  }\n\n  return flightData.map((flightDataPath) =>\n    getFlightDataPartsFromPath(flightDataPath)\n  )\n}\n\n/**\n * This function is used to prepare the flight router state for the request.\n * It removes markers that are not needed by the server, and are purely used\n * for stashing state on the client.\n * @param flightRouterState - The flight router state to prepare.\n * @param isHmrRefresh - Whether this is an HMR refresh request.\n * @returns The prepared flight router state.\n */\nexport function prepareFlightRouterStateForRequest(\n  flightRouterState: FlightRouterState,\n  isHmrRefresh?: boolean\n): string {\n  // HMR requests need the complete, unmodified state for proper functionality\n  if (isHmrRefresh) {\n    return encodeURIComponent(JSON.stringify(flightRouterState))\n  }\n\n  return encodeURIComponent(\n    JSON.stringify(stripClientOnlyDataFromFlightRouterState(flightRouterState))\n  )\n}\n\n/**\n * Recursively strips client-only data from FlightRouterState while preserving\n * server-needed information for proper rendering decisions.\n */\nfunction stripClientOnlyDataFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): FlightRouterState {\n  const [\n    segment,\n    parallelRoutes,\n    _url, // Intentionally unused - URLs are client-only\n    refreshMarker,\n    isRootLayout,\n    hasLoadingBoundary,\n  ] = flightRouterState\n\n  // __PAGE__ segments are always fetched from the server, so there's\n  // no need to send them up\n  const cleanedSegment = stripSearchParamsFromPageSegment(segment)\n\n  // Recursively process parallel routes\n  const cleanedParallelRoutes: { [key: string]: FlightRouterState } = {}\n  for (const [key, childState] of Object.entries(parallelRoutes)) {\n    cleanedParallelRoutes[key] =\n      stripClientOnlyDataFromFlightRouterState(childState)\n  }\n\n  const result: FlightRouterState = [\n    cleanedSegment,\n    cleanedParallelRoutes,\n    null, // URLs omitted - server reconstructs paths from segments\n    shouldPreserveRefreshMarker(refreshMarker) ? refreshMarker : null,\n  ]\n\n  // Append optional fields if present\n  if (isRootLayout !== undefined) {\n    result[4] = isRootLayout\n  }\n  if (hasLoadingBoundary !== undefined) {\n    result[5] = hasLoadingBoundary\n  }\n\n  return result\n}\n\n/**\n * Strips search parameters from __PAGE__ segments to prevent sensitive\n * client-side data from being sent to the server.\n */\nfunction stripSearchParamsFromPageSegment(segment: Segment): Segment {\n  if (\n    typeof segment === 'string' &&\n    segment.startsWith(PAGE_SEGMENT_KEY + '?')\n  ) {\n    return PAGE_SEGMENT_KEY\n  }\n  return segment\n}\n\n/**\n * Determines whether the refresh marker should be sent to the server\n * Client-only markers like 'refresh' are stripped, while server-needed markers\n * like 'refetch' and 'inside-shared-layout' are preserved.\n */\nfunction shouldPreserveRefreshMarker(\n  refreshMarker: FlightRouterState[3]\n): boolean {\n  return Boolean(refreshMarker && refreshMarker !== 'refresh')\n}\n"],"names":["getFlightDataPartsFromPath","getNextFlightSegmentPath","normalizeFlightData","prepareFlightRouterStateForRequest","flightDataPath","flightDataPathLength","tree","seedData","head","isHeadPartial","slice","segmentPath","pathToSegment","segment","length","isRootRender","flightSegmentPath","flightData","map","flightRouterState","isHmrRefresh","encodeURIComponent","JSON","stringify","stripClientOnlyDataFromFlightRouterState","parallelRoutes","_url","refreshMarker","isRootLayout","hasLoadingBoundary","cleanedSegment","stripSearchParamsFromPageSegment","cleanedParallelRoutes","key","childState","Object","entries","result","shouldPreserveRefreshMarker","undefined","startsWith","PAGE_SEGMENT_KEY","Boolean"],"mappings":";;;;;;;;;;;;;;;;IAgCgBA,0BAA0B,EAAA;eAA1BA;;IA4BAC,wBAAwB,EAAA;eAAxBA;;IAQAC,mBAAmB,EAAA;eAAnBA;;IAsBAC,kCAAkC,EAAA;eAAlCA;;;yBAjFiB;AAuB1B,SAASH,2BACdI,cAA8B;IAE9B,wGAAwG;IACxG,MAAMC,uBAAuB;IAC7B,sFAAsF;IACtF,MAAM,CAACC,MAAMC,UAAUC,MAAMC,cAAc,GACzCL,eAAeM,KAAK,CAAC,CAACL;IACxB,6GAA6G;IAC7G,MAAMM,cAAcP,eAAeM,KAAK,CAAC,GAAG,CAACL;QAUlCM;IARX,OAAO;QACL,kGAAkG;QAClG,sGAAsG;QACtG,qDAAqD;QACrDC,eAAeD,YAAYD,KAAK,CAAC,GAAG,CAAC;QACrCC;QACA,kFAAkF;QAClF,kCAAkC;QAClCE,SAASF,CAAAA,gBAAAA,WAAW,CAACA,YAAYG,MAAM,GAAG,EAAE,KAAA,OAAnCH,gBAAuC;QAChDL;QACAC;QACAC;QACAC;QACAM,cAAcX,eAAeU,MAAM,KAAKT;IAC1C;AACF;AAEO,SAASJ,yBACde,iBAAoC;IAEpC,4GAA4G;IAC5G,gCAAgC;IAChC,OAAOA,kBAAkBN,KAAK,CAAC;AACjC;AAEO,SAASR,oBACde,UAAsB;IAEtB,2FAA2F;IAC3F,kGAAkG;IAClG,IAAI,OAAOA,eAAe,UAAU;QAClC,OAAOA;IACT;IAEA,OAAOA,WAAWC,GAAG,CAAC,CAACd,iBACrBJ,2BAA2BI;AAE/B;AAUO,SAASD,mCACdgB,iBAAoC,EACpCC,YAAsB;IAEtB,4EAA4E;IAC5E,IAAIA,cAAc;QAChB,OAAOC,mBAAmBC,KAAKC,SAAS,CAACJ;IAC3C;IAEA,OAAOE,mBACLC,KAAKC,SAAS,CAACC,yCAAyCL;AAE5D;AAEA;;;CAGC,GACD,SAASK,yCACPL,iBAAoC;IAEpC,MAAM,CACJN,SACAY,gBACAC,MACAC,eACAC,cACAC,mBACD,GAAGV;IAEJ,mEAAmE;IACnE,0BAA0B;IAC1B,MAAMW,iBAAiBC,iCAAiClB;IAExD,sCAAsC;IACtC,MAAMmB,wBAA8D,CAAC;IACrE,KAAK,MAAM,CAACC,KAAKC,WAAW,IAAIC,OAAOC,OAAO,CAACX,gBAAiB;QAC9DO,qBAAqB,CAACC,IAAI,GACxBT,yCAAyCU;IAC7C;IAEA,MAAMG,SAA4B;QAChCP;QACAE;QACA;QACAM,4BAA4BX,iBAAiBA,gBAAgB;KAC9D;IAED,oCAAoC;IACpC,IAAIC,iBAAiBW,WAAW;QAC9BF,MAAM,CAAC,EAAE,GAAGT;IACd;IACA,IAAIC,uBAAuBU,WAAW;QACpCF,MAAM,CAAC,EAAE,GAAGR;IACd;IAEA,OAAOQ;AACT;AAEA;;;CAGC,GACD,SAASN,iCAAiClB,OAAgB;IACxD,IACE,OAAOA,YAAY,YACnBA,QAAQ2B,UAAU,CAACC,SAAAA,gBAAgB,GAAG,MACtC;QACA,OAAOA,SAAAA,gBAAgB;IACzB;IACA,OAAO5B;AACT;AAEA;;;;CAIC,GACD,SAASyB,4BACPX,aAAmC;IAEnC,OAAOe,QAAQf,iBAAiBA,kBAAkB;AACpD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 642, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/app-build-id.ts"],"sourcesContent":["// This gets assigned as a side-effect during app initialization. Because it\n// represents the build used to create the JS bundle, it should never change\n// after being set, so we store it in a global variable.\n//\n// When performing RSC requests, if the incoming data has a different build ID,\n// we perform an MPA navigation/refresh to load the updated build and ensure\n// that the client and server in sync.\n\n// Starts as an empty string. In practice, because setAppBuildId is called\n// during initialization before hydration starts, this will always get\n// reassigned to the actual build ID before it's ever needed by a navigation.\n// If for some reasons it didn't, due to a bug or race condition, then on\n// navigation the build comparision would fail and trigger an MPA navigation.\nlet globalBuildId: string = ''\n\nexport function setAppBuildId(buildId: string) {\n  globalBuildId = buildId\n}\n\nexport function getAppBuildId(): string {\n  return globalBuildId\n}\n"],"names":["getAppBuildId","setAppBuildId","globalBuildId","buildId"],"mappings":"AAAA,4EAA4E;AAC5E,4EAA4E;AAC5E,wDAAwD;AACxD,EAAE;AACF,+EAA+E;AAC/E,4EAA4E;AAC5E,sCAAsC;AAEtC,0EAA0E;AAC1E,sEAAsE;AACtE,6EAA6E;AAC7E,yEAAyE;AACzE,6EAA6E;;;;;;;;;;;;;;;IAO7DA,aAAa,EAAA;eAAbA;;IAJAC,aAAa,EAAA;eAAbA;;;AAFhB,IAAIC,gBAAwB;AAErB,SAASD,cAAcE,OAAe;IAC3CD,gBAAgBC;AAClB;AAEO,SAASH;IACd,OAAOE;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 693, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/shared/lib/hash.ts"],"sourcesContent":["// http://www.cse.yorku.ca/~oz/hash.html\n// More specifically, 32-bit hash via djbxor\n// (ref: https://gist.github.com/eplawless/52813b1d8ad9af510d85?permalink_comment_id=3367765#gistcomment-3367765)\n// This is due to number type differences between rust for turbopack to js number types,\n// where rust does not have easy way to repreesnt js's 53-bit float number type for the matching\n// overflow behavior. This is more `correct` in terms of having canonical hash across different runtime / implementation\n// as can gaurantee determinstic output from 32bit hash.\nexport function djb2Hash(str: string) {\n  let hash = 5381\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i)\n    hash = ((hash << 5) + hash + char) & 0xffffffff\n  }\n  return hash >>> 0\n}\n\nexport function hexHash(str: string) {\n  return djb2Hash(str).toString(36).slice(0, 5)\n}\n"],"names":["djb2Hash","hexHash","str","hash","i","length","char","charCodeAt","toString","slice"],"mappings":"AAAA,wCAAwC;AACxC,4CAA4C;AAC5C,iHAAiH;AACjH,wFAAwF;AACxF,gGAAgG;AAChG,wHAAwH;AACxH,wDAAwD;;;;;;;;;;;;;;;IACxCA,QAAQ,EAAA;eAARA;;IASAC,OAAO,EAAA;eAAPA;;;AATT,SAASD,SAASE,GAAW;IAClC,IAAIC,OAAO;IACX,IAAK,IAAIC,IAAI,GAAGA,IAAIF,IAAIG,MAAM,EAAED,IAAK;QACnC,MAAME,OAAOJ,IAAIK,UAAU,CAACH;QAC5BD,OAASA,CAAAA,QAAQ,CAAA,IAAKA,OAAOG,OAAQ;IACvC;IACA,OAAOH,SAAS;AAClB;AAEO,SAASF,QAAQC,GAAW;IACjC,OAAOF,SAASE,KAAKM,QAAQ,CAAC,IAAIC,KAAK,CAAC,GAAG;AAC7C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 736, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/shared/lib/router/utils/cache-busting-search-param.ts"],"sourcesContent":["import { hexHash } from '../../hash'\n\nexport function computeCacheBustingSearchParam(\n  prefetchHeader: '1' | '2' | '0' | undefined,\n  segmentPrefetchHeader: string | string[] | undefined,\n  stateTreeHeader: string | string[] | undefined,\n  nextUrlHeader: string | string[] | undefined\n): string {\n  if (\n    (prefetchHeader === undefined || prefetchHeader === '0') &&\n    segmentPrefetchHeader === undefined &&\n    stateTreeHeader === undefined &&\n    nextUrlHeader === undefined\n  ) {\n    return ''\n  }\n  return hexHash(\n    [\n      prefetchHeader || '0',\n      segmentPrefetchHeader || '0',\n      stateTreeHeader || '0',\n      nextUrlHeader || '0',\n    ].join(',')\n  )\n}\n"],"names":["computeCacheBustingSearchParam","prefetchHeader","segmentPrefetchHeader","stateTreeHeader","nextUrlHeader","undefined","hexHash","join"],"mappings":";;;+BAEgBA,kCAAAA;;;eAAAA;;;sBAFQ;AAEjB,SAASA,+BACdC,cAA2C,EAC3CC,qBAAoD,EACpDC,eAA8C,EAC9CC,aAA4C;IAE5C,IACGH,CAAAA,mBAAmBI,aAAaJ,mBAAmB,GAAE,KACtDC,0BAA0BG,aAC1BF,oBAAoBE,aACpBD,kBAAkBC,WAClB;QACA,OAAO;IACT;IACA,OAAOC,CAAAA,GAAAA,MAAAA,OAAO,EACZ;QACEL,kBAAkB;QAClBC,yBAAyB;QACzBC,mBAAmB;QACnBC,iBAAiB;KAClB,CAACG,IAAI,CAAC;AAEX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 761, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/router-reducer/set-cache-busting-search-param.ts"],"sourcesContent":["'use client'\n\nimport { computeCacheBustingSearchParam } from '../../../shared/lib/router/utils/cache-busting-search-param'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  NEXT_RSC_UNION_QUERY,\n} from '../app-router-headers'\nimport type { RequestHeaders } from './fetch-server-response'\n\n/**\n * Mutates the provided URL by adding a cache-busting search parameter for CDNs that don't\n * support custom headers. This helps avoid caching conflicts by making each request unique.\n *\n * Rather than relying on the Vary header which some CDNs ignore, we append a search param\n * to create a unique URL that forces a fresh request.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * Note: This function mutates the input URL directly and does not return anything.\n *\n * TODO: Since we need to use a search param anyway, we could simplify by removing the custom\n * headers approach entirely and just use search params.\n */\nexport const setCacheBustingSearchParam = (\n  url: URL,\n  headers: RequestHeaders\n): void => {\n  const uniqueCacheKey = computeCacheBustingSearchParam(\n    headers[NEXT_ROUTER_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_STATE_TREE_HEADER],\n    headers[NEXT_URL]\n  )\n  setCacheBustingSearchParamWithHash(url, uniqueCacheKey)\n}\n\n/**\n * Sets a cache-busting search parameter on a URL using a provided hash value.\n *\n * This function performs the same logic as `setCacheBustingSearchParam` but accepts\n * a pre-computed hash instead of computing it from headers.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * hash: \"abc123\"\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * If the hash is null, we will set `_rsc` search param without a value.\n * Like this: https://example.com/path?query=1&_rsc\n *\n * Note: This function mutates the input URL directly and does not return anything.\n */\nexport const setCacheBustingSearchParamWithHash = (\n  url: URL,\n  hash: string\n): void => {\n  /**\n   * Note that we intentionally do not use `url.searchParams.set` here:\n   *\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\n   * url.searchParams.set('_rsc', 'abc123');\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\n   *                                                                             ^ <--- this is causing confusion\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\n   * logic below.\n   */\n  const existingSearch = url.search\n  const rawQuery = existingSearch.startsWith('?')\n    ? existingSearch.slice(1)\n    : existingSearch\n\n  // Always remove any existing cache busting param and add a fresh one to ensure\n  // we have the correct value based on current request headers\n  const pairs = rawQuery\n    .split('&')\n    .filter((pair) => pair && !pair.startsWith(`${NEXT_RSC_UNION_QUERY}=`))\n\n  if (hash.length > 0) {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}=${hash}`)\n  } else {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}`)\n  }\n  url.search = pairs.length ? `?${pairs.join('&')}` : ''\n}\n"],"names":["setCacheBustingSearchParam","setCacheBustingSearchParamWithHash","url","headers","uniqueCacheKey","computeCacheBustingSearchParam","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_URL","hash","existingSearch","search","rawQuery","startsWith","slice","pairs","split","filter","pair","NEXT_RSC_UNION_QUERY","length","push","join"],"mappings":";;;;;;;;;;;;;;IA4BaA,0BAA0B,EAAA;eAA1BA;;IA6BAC,kCAAkC,EAAA;eAAlCA;;;yCAvDkC;kCAOxC;AAmBA,MAAMD,6BAA6B,CACxCE,KACAC;IAEA,MAAMC,iBAAiBC,CAAAA,GAAAA,yBAAAA,8BAA8B,EACnDF,OAAO,CAACG,kBAAAA,2BAA2B,CAAC,EACpCH,OAAO,CAACI,kBAAAA,mCAAmC,CAAC,EAC5CJ,OAAO,CAACK,kBAAAA,6BAA6B,CAAC,EACtCL,OAAO,CAACM,kBAAAA,QAAQ,CAAC;IAEnBR,mCAAmCC,KAAKE;AAC1C;AAkBO,MAAMH,qCAAqC,CAChDC,KACAQ;IAEA;;;;;;;;;;GAUC,GACD,MAAMC,iBAAiBT,IAAIU,MAAM;IACjC,MAAMC,WAAWF,eAAeG,UAAU,CAAC,OACvCH,eAAeI,KAAK,CAAC,KACrBJ;IAEJ,+EAA+E;IAC/E,6DAA6D;IAC7D,MAAMK,QAAQH,SACXI,KAAK,CAAC,KACNC,MAAM,CAAC,CAACC,OAASA,QAAQ,CAACA,KAAKL,UAAU,CAAE,KAAEM,kBAAAA,oBAAoB,GAAC;IAErE,IAAIV,KAAKW,MAAM,GAAG,GAAG;QACnBL,MAAMM,IAAI,CAAIF,kBAAAA,oBAAoB,GAAC,MAAGV;IACxC,OAAO;QACLM,MAAMM,IAAI,CAAE,KAAEF,kBAAAA,oBAAoB;IACpC;IACAlB,IAAIU,MAAM,GAAGI,MAAMK,MAAM,GAAI,MAAGL,MAAMO,IAAI,CAAC,OAAS;AACtD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 822, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/shared/lib/segment-cache/segment-value-encoding.ts"],"sourcesContent":["import { PAGE_SEGMENT_KEY } from '../segment'\nimport type { Segment as FlightRouterStateSegment } from '../../../server/app-render/types'\n\n// TypeScript trick to simulate opaque types, like in Flow.\ntype Opaque<K, T> = T & { __brand: K }\n\nexport type SegmentRequestKeyPart = Opaque<'SegmentRequestKeyPart', string>\nexport type SegmentRequestKey = Opaque<'SegmentRequestKey', string>\nexport type SegmentCacheKeyPart = Opaque<'SegmentCacheKeyPart', string>\nexport type SegmentCacheKey = Opaque<'SegmentCacheKey', string>\n\nexport const ROOT_SEGMENT_REQUEST_KEY = '' as SegmentRequestKey\nexport const ROOT_SEGMENT_CACHE_KEY = '' as SegmentCacheKey\n\nexport function createSegmentRequestKeyPart(\n  segment: FlightRouterStateSegment\n): SegmentRequestKeyPart {\n  if (typeof segment === 'string') {\n    if (segment.startsWith(PAGE_SEGMENT_KEY)) {\n      // The Flight Router State type sometimes includes the search params in\n      // the page segment. However, the Segment Cache tracks this as a separate\n      // key. So, we strip the search params here, and then add them back when\n      // the cache entry is turned back into a FlightRouterState. This is an\n      // unfortunate consequence of the FlightRouteState being used both as a\n      // transport type and as a cache key; we'll address this once more of the\n      // Segment Cache implementation has settled.\n      // TODO: We should hoist the search params out of the FlightRouterState\n      // type entirely, This is our plan for dynamic route params, too.\n      return PAGE_SEGMENT_KEY as SegmentRequestKeyPart\n    }\n    const safeName =\n      // TODO: FlightRouterState encodes Not Found routes as \"/_not-found\".\n      // But params typically don't include the leading slash. We should use\n      // a different encoding to avoid this special case.\n      segment === '/_not-found'\n        ? '_not-found'\n        : encodeToFilesystemAndURLSafeString(segment)\n    // Since this is not a dynamic segment, it's fully encoded. It does not\n    // need to be \"hydrated\" with a param value.\n    return safeName as SegmentRequestKeyPart\n  }\n\n  const name = segment[0]\n  const paramType = segment[2]\n  const safeName = encodeToFilesystemAndURLSafeString(name)\n\n  const encodedName = '$' + paramType + '$' + safeName\n  return encodedName as SegmentRequestKeyPart\n}\n\nexport function appendSegmentRequestKeyPart(\n  parentRequestKey: SegmentRequestKey,\n  parallelRouteKey: string,\n  childRequestKeyPart: SegmentRequestKeyPart\n): SegmentRequestKey {\n  // Aside from being filesystem safe, segment keys are also designed so that\n  // each segment and parallel route creates its own subdirectory. Roughly in\n  // the same shape as the source app directory. This is mostly just for easier\n  // debugging (you can open up the build folder and navigate the output); if\n  // we wanted to do we could just use a flat structure.\n\n  // Omit the parallel route key for children, since this is the most\n  // common case. Saves some bytes (and it's what the app directory does).\n  const slotKey =\n    parallelRouteKey === 'children'\n      ? childRequestKeyPart\n      : `@${encodeToFilesystemAndURLSafeString(parallelRouteKey)}/${childRequestKeyPart}`\n  return (parentRequestKey + '/' + slotKey) as SegmentRequestKey\n}\n\nexport function createSegmentCacheKeyPart(\n  requestKeyPart: SegmentRequestKeyPart,\n  segment: FlightRouterStateSegment\n): SegmentCacheKeyPart {\n  if (typeof segment === 'string') {\n    return requestKeyPart as any as SegmentCacheKeyPart\n  }\n  const paramValue = segment[1]\n  const safeValue = encodeToFilesystemAndURLSafeString(paramValue)\n  return (requestKeyPart + '$' + safeValue) as SegmentCacheKeyPart\n}\n\nexport function appendSegmentCacheKeyPart(\n  parentSegmentKey: SegmentCacheKey,\n  parallelRouteKey: string,\n  childCacheKeyPart: SegmentCacheKeyPart\n): SegmentCacheKey {\n  const slotKey =\n    parallelRouteKey === 'children'\n      ? childCacheKeyPart\n      : `@${encodeToFilesystemAndURLSafeString(parallelRouteKey)}/${childCacheKeyPart}`\n  return (parentSegmentKey + '/' + slotKey) as SegmentCacheKey\n}\n\n// Define a regex pattern to match the most common characters found in a route\n// param. It excludes anything that might not be cross-platform filesystem\n// compatible, like |. It does not need to be precise because the fallback is to\n// just base64url-encode the whole parameter, which is fine; we just don't do it\n// by default for compactness, and for easier debugging.\nconst simpleParamValueRegex = /^[a-zA-Z0-9\\-_@]+$/\n\nfunction encodeToFilesystemAndURLSafeString(value: string) {\n  if (simpleParamValueRegex.test(value)) {\n    return value\n  }\n  // If there are any unsafe characters, base64url-encode the entire value.\n  // We also add a ! prefix so it doesn't collide with the simple case.\n  const base64url = btoa(value)\n    .replace(/\\+/g, '-') // Replace '+' with '-'\n    .replace(/\\//g, '_') // Replace '/' with '_'\n    .replace(/=+$/, '') // Remove trailing '='\n  return '!' + base64url\n}\n\nexport function convertSegmentPathToStaticExportFilename(\n  segmentPath: string\n): string {\n  return `__next${segmentPath.replace(/\\//g, '.')}.txt`\n}\n"],"names":["ROOT_SEGMENT_CACHE_KEY","ROOT_SEGMENT_REQUEST_KEY","appendSegmentCacheKeyPart","appendSegmentRequestKeyPart","convertSegmentPathToStaticExportFilename","createSegmentCacheKeyPart","createSegmentRequestKeyPart","segment","startsWith","PAGE_SEGMENT_KEY","safeName","encodeToFilesystemAndURLSafeString","name","paramType","encodedName","parentRequestKey","parallelRouteKey","childRequestKeyPart","slotKey","requestKeyPart","paramValue","safeValue","parentSegmentKey","childCacheKeyPart","simpleParamValueRegex","value","test","base64url","btoa","replace","segmentPath"],"mappings":";;;;;;;;;;;;;;;;;;;IAYaA,sBAAsB,EAAA;eAAtBA;;IADAC,wBAAwB,EAAA;eAAxBA;;IAuEGC,yBAAyB,EAAA;eAAzBA;;IAhCAC,2BAA2B,EAAA;eAA3BA;;IAgEAC,wCAAwC,EAAA;eAAxCA;;IA5CAC,yBAAyB,EAAA;eAAzBA;;IAxDAC,2BAA2B,EAAA;eAA3BA;;;yBAdiB;AAW1B,MAAML,2BAA2B;AACjC,MAAMD,yBAAyB;AAE/B,SAASM,4BACdC,OAAiC;IAEjC,IAAI,OAAOA,YAAY,UAAU;QAC/B,IAAIA,QAAQC,UAAU,CAACC,SAAAA,gBAAgB,GAAG;YACxC,uEAAuE;YACvE,yEAAyE;YACzE,wEAAwE;YACxE,sEAAsE;YACtE,uEAAuE;YACvE,yEAAyE;YACzE,4CAA4C;YAC5C,uEAAuE;YACvE,iEAAiE;YACjE,OAAOA,SAAAA,gBAAgB;QACzB;QACA,MAAMC,WACJ,AACA,qEADqE,CACC;QACtE,mDAAmD;QACnDH,YAAY,gBACR,eACAI,mCAAmCJ;QACzC,uEAAuE;QACvE,4CAA4C;QAC5C,OAAOG;IACT;IAEA,MAAME,OAAOL,OAAO,CAAC,EAAE;IACvB,MAAMM,YAAYN,OAAO,CAAC,EAAE;IAC5B,MAAMG,WAAWC,mCAAmCC;IAEpD,MAAME,cAAc,MAAMD,YAAY,MAAMH;IAC5C,OAAOI;AACT;AAEO,SAASX,4BACdY,gBAAmC,EACnCC,gBAAwB,EACxBC,mBAA0C;IAE1C,2EAA2E;IAC3E,2EAA2E;IAC3E,6EAA6E;IAC7E,2EAA2E;IAC3E,sDAAsD;IAEtD,mEAAmE;IACnE,wEAAwE;IACxE,MAAMC,UACJF,qBAAqB,aACjBC,sBACC,MAAGN,mCAAmCK,oBAAkB,MAAGC;IAClE,OAAQF,mBAAmB,MAAMG;AACnC;AAEO,SAASb,0BACdc,cAAqC,EACrCZ,OAAiC;IAEjC,IAAI,OAAOA,YAAY,UAAU;QAC/B,OAAOY;IACT;IACA,MAAMC,aAAab,OAAO,CAAC,EAAE;IAC7B,MAAMc,YAAYV,mCAAmCS;IACrD,OAAQD,iBAAiB,MAAME;AACjC;AAEO,SAASnB,0BACdoB,gBAAiC,EACjCN,gBAAwB,EACxBO,iBAAsC;IAEtC,MAAML,UACJF,qBAAqB,aACjBO,oBACC,MAAGZ,mCAAmCK,oBAAkB,MAAGO;IAClE,OAAQD,mBAAmB,MAAMJ;AACnC;AAEA,8EAA8E;AAC9E,0EAA0E;AAC1E,gFAAgF;AAChF,gFAAgF;AAChF,wDAAwD;AACxD,MAAMM,wBAAwB;AAE9B,SAASb,mCAAmCc,KAAa;IACvD,IAAID,sBAAsBE,IAAI,CAACD,QAAQ;QACrC,OAAOA;IACT;IACA,yEAAyE;IACzE,qEAAqE;IACrE,MAAME,YAAYC,KAAKH,OACpBI,OAAO,CAAC,OAAO,KAAK,uBAAuB;KAC3CA,OAAO,CAAC,OAAO,KAAK,uBAAuB;KAC3CA,OAAO,CAAC,OAAO,IAAI,sBAAsB;;IAC5C,OAAO,MAAMF;AACf;AAEO,SAASvB,yCACd0B,WAAmB;IAEnB,OAAQ,WAAQA,YAAYD,OAAO,CAAC,OAAO,OAAK;AAClD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 941, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/route-params.ts"],"sourcesContent":["import type { DynamicParamTypesShort } from '../server/app-render/types'\nimport {\n  addSearchParamsIfPageSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../shared/lib/segment'\nimport { ROOT_SEGMENT_REQUEST_KEY } from '../shared/lib/segment-cache/segment-value-encoding'\nimport {\n  NEXT_REWRITTEN_PATH_HEADER,\n  NEXT_REWRITTEN_QUERY_HEADER,\n  NEXT_RSC_UNION_QUERY,\n} from './components/app-router-headers'\nimport type { NormalizedSearch } from './components/segment-cache'\nimport type { RSCResponse } from './components/router-reducer/fetch-server-response'\n\nexport type RouteParamValue = string | Array<string> | null\n\nexport type RouteParam = {\n  name: string\n  value: RouteParamValue\n  type: DynamicParamTypesShort\n}\n\nexport function getRenderedSearch(response: RSCResponse): NormalizedSearch {\n  // If the server performed a rewrite, the search params used to render the\n  // page will be different from the params in the request URL. In this case,\n  // the response will include a header that gives the rewritten search query.\n  const rewrittenQuery = response.headers.get(NEXT_REWRITTEN_QUERY_HEADER)\n  if (rewrittenQuery !== null) {\n    return (\n      rewrittenQuery === '' ? '' : '?' + rewrittenQuery\n    ) as NormalizedSearch\n  }\n  // If the header is not present, there was no rewrite, so we use the search\n  // query of the response URL.\n  return urlToUrlWithoutFlightMarker(new URL(response.url))\n    .search as NormalizedSearch\n}\n\nexport function getRenderedPathname(response: RSCResponse): string {\n  // If the server performed a rewrite, the pathname used to render the\n  // page will be different from the pathname in the request URL. In this case,\n  // the response will include a header that gives the rewritten pathname.\n  const rewrittenPath = response.headers.get(NEXT_REWRITTEN_PATH_HEADER)\n  return (\n    rewrittenPath ?? urlToUrlWithoutFlightMarker(new URL(response.url)).pathname\n  )\n}\n\nexport function parseDynamicParamFromURLPart(\n  paramType: DynamicParamTypesShort,\n  pathnameParts: Array<string>,\n  partIndex: number\n): RouteParamValue {\n  // This needs to match the behavior in get-dynamic-param.ts.\n  switch (paramType) {\n    // Catchalls\n    case 'c':\n    case 'ci': {\n      // Catchalls receive all the remaining URL parts. If there are no\n      // remaining pathname parts, return an empty array.\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n        : []\n    }\n    // Optional catchalls\n    case 'oc': {\n      // Optional catchalls receive all the remaining URL parts, unless this is\n      // the end of the pathname, in which case they return null.\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n        : null\n    }\n    // Dynamic\n    case 'd':\n    case 'di': {\n      if (partIndex >= pathnameParts.length) {\n        // The route tree expected there to be more parts in the URL than there\n        // actually are. This could happen if the x-nextjs-rewritten-path header\n        // is incorrectly set, or potentially due to bug in Next.js. TODO:\n        // Should this be a hard error? During a prefetch, we can just abort.\n        // During a client navigation, we could trigger a hard refresh. But if\n        // it happens during initial render, we don't really have any\n        // recovery options.\n        return ''\n      }\n      return encodeURIComponent(pathnameParts[partIndex])\n    }\n    default:\n      paramType satisfies never\n      return ''\n  }\n}\n\nexport function doesStaticSegmentAppearInURL(segment: string): boolean {\n  // This is not a parameterized segment; however, we need to determine\n  // whether or not this segment appears in the URL. For example, this route\n  // groups do not appear in the URL, so they should be skipped. Any other\n  // special cases must be handled here.\n  // TODO: Consider encoding this directly into the router tree instead of\n  // inferring it on the client based on the segment type. Something like\n  // a `doesAppearInURL` flag in FlightRouterState.\n  if (\n    segment === ROOT_SEGMENT_REQUEST_KEY ||\n    // For some reason, the loader tree sometimes includes extra __PAGE__\n    // \"layouts\" when part of a parallel route. But it's not a leaf node.\n    // Otherwise, we wouldn't need this special case because pages are\n    // always leaf nodes.\n    // TODO: Investigate why the loader produces these fake page segments.\n    segment.startsWith(PAGE_SEGMENT_KEY) ||\n    // Route groups.\n    (segment[0] === '(' && segment.endsWith(')')) ||\n    segment === DEFAULT_SEGMENT_KEY ||\n    segment === '/_not-found'\n  ) {\n    return false\n  } else {\n    // All other segment types appear in the URL\n    return true\n  }\n}\n\nexport function getCacheKeyForDynamicParam(\n  paramValue: RouteParamValue,\n  renderedSearch: NormalizedSearch\n): string {\n  // This needs to match the logic in get-dynamic-param.ts, until we're able to\n  // unify the various implementations so that these are always computed on\n  // the client.\n  if (typeof paramValue === 'string') {\n    // TODO: Refactor or remove this helper function to accept a string rather\n    // than the whole segment type. Also we can probably just append the\n    // search string instead of turning it into JSON.\n    const pageSegmentWithSearchParams = addSearchParamsIfPageSegment(\n      paramValue,\n      Object.fromEntries(new URLSearchParams(renderedSearch))\n    ) as string\n    return pageSegmentWithSearchParams\n  } else if (paramValue === null) {\n    return ''\n  } else {\n    return paramValue.join('/')\n  }\n}\n\nexport function urlToUrlWithoutFlightMarker(url: URL): URL {\n  const urlWithoutFlightParameters = new URL(url)\n  urlWithoutFlightParameters.searchParams.delete(NEXT_RSC_UNION_QUERY)\n  if (process.env.NODE_ENV === 'production') {\n    if (\n      process.env.__NEXT_CONFIG_OUTPUT === 'export' &&\n      urlWithoutFlightParameters.pathname.endsWith('.txt')\n    ) {\n      const { pathname } = urlWithoutFlightParameters\n      const length = pathname.endsWith('/index.txt') ? 10 : 4\n      // Slice off `/index.txt` or `.txt` from the end of the pathname\n      urlWithoutFlightParameters.pathname = pathname.slice(0, -length)\n    }\n  }\n  return urlWithoutFlightParameters\n}\n\nexport function getParamValueFromCacheKey(\n  paramCacheKey: string,\n  paramType: DynamicParamTypesShort\n) {\n  // Turn the cache key string sent by the server (as part of FlightRouterState)\n  // into a value that can be passed to `useParams` and client components.\n  const isCatchAll = paramType === 'c' || paramType === 'oc'\n  if (isCatchAll) {\n    // Catch-all param keys are a concatenation of the path segments.\n    // See equivalent logic in `getSelectedParams`.\n    // TODO: We should just pass the array directly, rather than concatenate\n    // it to a string and then split it back to an array. It needs to be an\n    // array in some places, like when passing a key React, but we can convert\n    // it at runtime in those places.\n    return paramCacheKey.split('/')\n  }\n  return paramCacheKey\n}\n"],"names":["doesStaticSegmentAppearInURL","getCacheKeyForDynamicParam","getParamValueFromCacheKey","getRenderedPathname","getRenderedSearch","parseDynamicParamFromURLPart","urlToUrlWithoutFlightMarker","response","rewrittenQuery","headers","get","NEXT_REWRITTEN_QUERY_HEADER","URL","url","search","rewrittenPath","NEXT_REWRITTEN_PATH_HEADER","pathname","paramType","pathnameParts","partIndex","length","slice","map","s","encodeURIComponent","segment","ROOT_SEGMENT_REQUEST_KEY","startsWith","PAGE_SEGMENT_KEY","endsWith","DEFAULT_SEGMENT_KEY","paramValue","renderedSearch","pageSegmentWithSearchParams","addSearchParamsIfPageSegment","Object","fromEntries","URLSearchParams","join","urlWithoutFlightParameters","searchParams","delete","NEXT_RSC_UNION_QUERY","process","env","NODE_ENV","__NEXT_CONFIG_OUTPUT","paramCacheKey","isCatchAll","split"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1115, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/router-reducer/fetch-server-response.ts"],"sourcesContent":["'use client'\n\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { createFromReadableStream as createFromReadableStreamBrowser } from 'react-server-dom-webpack/client'\n\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../server/app-render/types'\n\nimport type { NEXT_ROUTER_SEGMENT_PREFETCH_HEADER } from '../app-router-headers'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_RSC_UNION_QUERY,\n  NEXT_URL,\n  RSC_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n} from '../app-router-headers'\nimport { callServer } from '../../app-call-server'\nimport { findSourceMapURL } from '../../app-find-source-map-url'\nimport { PrefetchKind } from './router-reducer-types'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n  type NormalizedFlightData,\n} from '../../flight-data-helpers'\nimport { getAppBuildId } from '../../app-build-id'\nimport { setCacheBustingSearchParam } from './set-cache-busting-search-param'\nimport { urlToUrlWithoutFlightMarker } from '../../route-params'\n\nconst createFromReadableStream =\n  createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']\n\nexport interface FetchServerResponseOptions {\n  readonly flightRouterState: FlightRouterState\n  readonly nextUrl: string | null\n  readonly prefetchKind?: PrefetchKind\n  readonly isHmrRefresh?: boolean\n}\n\nexport type FetchServerResponseResult = {\n  flightData: NormalizedFlightData[] | string\n  canonicalUrl: URL | undefined\n  couldBeIntercepted: boolean\n  prerendered: boolean\n  postponed: boolean\n  staleTime: number\n}\n\nexport type RequestHeaders = {\n  [RSC_HEADER]?: '1'\n  [NEXT_ROUTER_STATE_TREE_HEADER]?: string\n  [NEXT_URL]?: string\n  [NEXT_ROUTER_PREFETCH_HEADER]?: '1' | '2'\n  [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]?: string\n  'x-deployment-id'?: string\n  [NEXT_HMR_REFRESH_HEADER]?: '1'\n  // A header that is only added in test mode to assert on fetch priority\n  'Next-Test-Fetch-Priority'?: RequestInit['priority']\n}\n\nfunction doMpaNavigation(url: string): FetchServerResponseResult {\n  return {\n    flightData: urlToUrlWithoutFlightMarker(\n      new URL(url, location.origin)\n    ).toString(),\n    canonicalUrl: undefined,\n    couldBeIntercepted: false,\n    prerendered: false,\n    postponed: false,\n    staleTime: -1,\n  }\n}\n\nlet abortController = new AbortController()\n\nif (typeof window !== 'undefined') {\n  // Abort any in-flight requests when the page is unloaded, e.g. due to\n  // reloading the page or performing hard navigations. This allows us to ignore\n  // what would otherwise be a thrown TypeError when the browser cancels the\n  // requests.\n  window.addEventListener('pagehide', () => {\n    abortController.abort()\n  })\n\n  // Use a fresh AbortController instance on pageshow, e.g. when navigating back\n  // and the JavaScript execution context is restored by the browser.\n  window.addEventListener('pageshow', () => {\n    abortController = new AbortController()\n  })\n}\n\n/**\n * Fetch the flight data for the provided url. Takes in the current router state\n * to decide what to render server-side.\n */\nexport async function fetchServerResponse(\n  url: URL,\n  options: FetchServerResponseOptions\n): Promise<FetchServerResponseResult> {\n  const { flightRouterState, nextUrl, prefetchKind } = options\n\n  const headers: RequestHeaders = {\n    // Enable flight response\n    [RSC_HEADER]: '1',\n    // Provide the current router state\n    [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(\n      flightRouterState,\n      options.isHmrRefresh\n    ),\n  }\n\n  /**\n   * Three cases:\n   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully\n   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\n   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\n   */\n  if (prefetchKind === PrefetchKind.AUTO) {\n    headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n  }\n\n  if (process.env.NODE_ENV === 'development' && options.isHmrRefresh) {\n    headers[NEXT_HMR_REFRESH_HEADER] = '1'\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  try {\n    // When creating a \"temporary\" prefetch (the \"on-demand\" prefetch that gets created on navigation, if one doesn't exist)\n    // we send the request with a \"high\" priority as it's in response to a user interaction that could be blocking a transition.\n    // Otherwise, all other prefetches are sent with a \"low\" priority.\n    // We use \"auto\" for in all other cases to match the existing default, as this function is shared outside of prefetching.\n    const fetchPriority = prefetchKind\n      ? prefetchKind === PrefetchKind.TEMPORARY\n        ? 'high'\n        : 'low'\n      : 'auto'\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        // In \"output: export\" mode, we can't rely on headers to distinguish\n        // between HTML and RSC requests. Instead, we append an extra prefix\n        // to the request.\n        url = new URL(url)\n        if (url.pathname.endsWith('/')) {\n          url.pathname += 'index.txt'\n        } else {\n          url.pathname += '.txt'\n        }\n      }\n    }\n\n    const res = await createFetch(\n      url,\n      headers,\n      fetchPriority,\n      abortController.signal\n    )\n\n    const responseUrl = urlToUrlWithoutFlightMarker(new URL(res.url))\n    const canonicalUrl = res.redirected ? responseUrl : undefined\n\n    const contentType = res.headers.get('content-type') || ''\n    const interception = !!res.headers.get('vary')?.includes(NEXT_URL)\n    const postponed = !!res.headers.get(NEXT_DID_POSTPONE_HEADER)\n    const staleTimeHeaderSeconds = res.headers.get(\n      NEXT_ROUTER_STALE_TIME_HEADER\n    )\n    const staleTime =\n      staleTimeHeaderSeconds !== null\n        ? parseInt(staleTimeHeaderSeconds, 10) * 1000\n        : -1\n    let isFlightResponse = contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        if (!isFlightResponse) {\n          isFlightResponse = contentType.startsWith('text/plain')\n        }\n      }\n    }\n\n    // If fetch returns something different than flight response handle it like a mpa navigation\n    // If the fetch was not 200, we also handle it like a mpa navigation\n    if (!isFlightResponse || !res.ok || !res.body) {\n      // in case the original URL came with a hash, preserve it before redirecting to the new URL\n      if (url.hash) {\n        responseUrl.hash = url.hash\n      }\n\n      return doMpaNavigation(responseUrl.toString())\n    }\n\n    // We may navigate to a page that requires a different Webpack runtime.\n    // In prod, every page will have the same Webpack runtime.\n    // In dev, the Webpack runtime is minimal for each page.\n    // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n    if (process.env.NODE_ENV !== 'production' && !process.env.TURBOPACK) {\n      await (\n        require('../../dev/hot-reloader/app/hot-reloader-app') as typeof import('../../dev/hot-reloader/app/hot-reloader-app')\n      ).waitForWebpackRuntimeHotUpdate()\n    }\n\n    // Handle the `fetch` readable stream that can be unwrapped by `React.use`.\n    const flightStream = postponed\n      ? createUnclosingPrefetchStream(res.body)\n      : res.body\n    const response = await (createFromNextReadableStream(\n      flightStream\n    ) as Promise<NavigationFlightResponse>)\n\n    if (getAppBuildId() !== response.b) {\n      return doMpaNavigation(res.url)\n    }\n\n    return {\n      flightData: normalizeFlightData(response.f),\n      canonicalUrl: canonicalUrl,\n      couldBeIntercepted: interception,\n      prerendered: response.S,\n      postponed,\n      staleTime,\n    }\n  } catch (err) {\n    if (!abortController.signal.aborted) {\n      console.error(\n        `Failed to fetch RSC payload for ${url}. Falling back to browser navigation.`,\n        err\n      )\n    }\n\n    // If fetch fails handle it like a mpa navigation\n    // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n    // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n    return {\n      flightData: url.toString(),\n      canonicalUrl: undefined,\n      couldBeIntercepted: false,\n      prerendered: false,\n      postponed: false,\n      staleTime: -1,\n    }\n  }\n}\n\n// This is a subset of the standard Response type. We use a custom type for\n// this so we can limit which details about the response leak into the rest of\n// the codebase. For example, there's some custom logic for manually following\n// redirects, so \"redirected\" in this type could be a composite of multiple\n// browser fetch calls; however, this fact should not leak to the caller.\nexport type RSCResponse = {\n  ok: boolean\n  redirected: boolean\n  headers: Headers\n  body: ReadableStream<Uint8Array> | null\n  status: number\n  url: string\n}\n\nexport async function createFetch(\n  url: URL,\n  headers: RequestHeaders,\n  fetchPriority: 'auto' | 'high' | 'low' | null,\n  signal?: AbortSignal\n): Promise<RSCResponse> {\n  // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n  // cache busting search param) from the request so they're\n  // maximally cacheable.\n\n  if (process.env.__NEXT_TEST_MODE && fetchPriority !== null) {\n    headers['Next-Test-Fetch-Priority'] = fetchPriority\n  }\n\n  if (process.env.NEXT_DEPLOYMENT_ID) {\n    headers['x-deployment-id'] = process.env.NEXT_DEPLOYMENT_ID\n  }\n\n  const fetchOptions: RequestInit = {\n    // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n    credentials: 'same-origin',\n    headers,\n    priority: fetchPriority || undefined,\n    signal,\n  }\n  // `fetchUrl` is slightly different from `url` because we add a cache-busting\n  // search param to it. This should not leak outside of this function, so we\n  // track them separately.\n  let fetchUrl = new URL(url)\n  setCacheBustingSearchParam(fetchUrl, headers)\n  let browserResponse = await fetch(fetchUrl, fetchOptions)\n\n  // If the server responds with a redirect (e.g. 307), and the redirected\n  // location does not contain the cache busting search param set in the\n  // original request, the response is likely invalid — when following the\n  // redirect, the browser forwards the request headers, but since the cache\n  // busting search param is missing, the server will reject the request due to\n  // a mismatch.\n  //\n  // Ideally, we would be able to intercept the redirect response and perform it\n  // manually, instead of letting the browser automatically follow it, but this\n  // is not allowed by the fetch API.\n  //\n  // So instead, we must \"replay\" the redirect by fetching the new location\n  // again, but this time we'll append the cache busting search param to prevent\n  // a mismatch.\n  //\n  // TODO: We can optimize Next.js's built-in middleware APIs by returning a\n  // custom status code, to prevent the browser from automatically following it.\n  //\n  // This does not affect Server Action-based redirects; those are encoded\n  // differently, as part of the Flight body. It only affects redirects that\n  // occur in a middleware or a third-party proxy.\n\n  let redirected = browserResponse.redirected\n  if (process.env.__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS) {\n    // This is to prevent a redirect loop. Same limit used by Chrome.\n    const MAX_REDIRECTS = 20\n    for (let n = 0; n < MAX_REDIRECTS; n++) {\n      if (!browserResponse.redirected) {\n        // The server did not perform a redirect.\n        break\n      }\n      const responseUrl = new URL(browserResponse.url, fetchUrl)\n      if (responseUrl.origin !== fetchUrl.origin) {\n        // The server redirected to an external URL. The rest of the logic below\n        // is not relevant, because it only applies to internal redirects.\n        break\n      }\n      if (\n        responseUrl.searchParams.get(NEXT_RSC_UNION_QUERY) ===\n        fetchUrl.searchParams.get(NEXT_RSC_UNION_QUERY)\n      ) {\n        // The redirected URL already includes the cache busting search param.\n        // This was probably intentional. Regardless, there's no reason to\n        // issue another request to this URL because it already has the param\n        // value that we would have added below.\n        break\n      }\n      // The RSC request was redirected. Assume the response is invalid.\n      //\n      // Append the cache busting search param to the redirected URL and\n      // fetch again.\n      fetchUrl = new URL(responseUrl)\n      setCacheBustingSearchParam(fetchUrl, headers)\n      browserResponse = await fetch(fetchUrl, fetchOptions)\n      // We just performed a manual redirect, so this is now true.\n      redirected = true\n    }\n  }\n\n  // Remove the cache busting search param from the response URL, to prevent it\n  // from leaking outside of this function.\n  const responseUrl = new URL(browserResponse.url, fetchUrl)\n  responseUrl.searchParams.delete(NEXT_RSC_UNION_QUERY)\n\n  const rscResponse: RSCResponse = {\n    url: responseUrl.href,\n\n    // This is true if any redirects occurred, either automatically by the\n    // browser, or manually by us. So it's different from\n    // `browserResponse.redirected`, which only tells us whether the browser\n    // followed a redirect, and only for the last response in the chain.\n    redirected,\n\n    // These can be copied from the last browser response we received. We\n    // intentionally only expose the subset of fields that are actually used\n    // elsewhere in the codebase.\n    ok: browserResponse.ok,\n    headers: browserResponse.headers,\n    body: browserResponse.body,\n    status: browserResponse.status,\n  }\n\n  return rscResponse\n}\n\nexport function createFromNextReadableStream(\n  flightStream: ReadableStream<Uint8Array>\n): Promise<unknown> {\n  return createFromReadableStream(flightStream, {\n    callServer,\n    findSourceMapURL,\n  })\n}\n\nfunction createUnclosingPrefetchStream(\n  originalFlightStream: ReadableStream<Uint8Array>\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream.\n        return\n      }\n    },\n  })\n}\n"],"names":["createFetch","createFromNextReadableStream","fetchServerResponse","createFromReadableStream","createFromReadableStreamBrowser","doMpaNavigation","url","flightData","urlToUrlWithoutFlightMarker","URL","location","origin","toString","canonicalUrl","undefined","couldBeIntercepted","prerendered","postponed","staleTime","abortController","AbortController","window","addEventListener","abort","options","flightRouterState","nextUrl","prefetchKind","headers","RSC_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","prepareFlightRouterStateForRequest","isHmrRefresh","PrefetchKind","AUTO","NEXT_ROUTER_PREFETCH_HEADER","process","env","NODE_ENV","NEXT_HMR_REFRESH_HEADER","NEXT_URL","res","fetchPriority","TEMPORARY","__NEXT_CONFIG_OUTPUT","pathname","endsWith","signal","responseUrl","redirected","contentType","get","interception","includes","NEXT_DID_POSTPONE_HEADER","staleTimeHeaderSeconds","NEXT_ROUTER_STALE_TIME_HEADER","parseInt","isFlightResponse","startsWith","RSC_CONTENT_TYPE_HEADER","ok","body","hash","TURBOPACK","require","waitForWebpackRuntimeHotUpdate","flightStream","createUnclosingPrefetchStream","response","getAppBuildId","b","normalizeFlightData","f","S","err","aborted","console","error","__NEXT_TEST_MODE","NEXT_DEPLOYMENT_ID","fetchOptions","credentials","priority","fetchUrl","setCacheBustingSearchParam","browserResponse","fetch","__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS","MAX_REDIRECTS","n","searchParams","NEXT_RSC_UNION_QUERY","delete","rscResponse","href","status","callServer","findSourceMapURL","originalFlightStream","reader","getReader","ReadableStream","pull","controller","done","value","read","enqueue"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1379, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/unresolved-thenable.ts"],"sourcesContent":["/**\n * Create a \"Thenable\" that does not resolve. This is used to suspend indefinitely when data is not available yet.\n */\nexport const unresolvedThenable = {\n  then: () => {},\n} as PromiseLike<void>\n"],"names":["unresolvedThenable","then"],"mappings":"AAAA;;CAEC;;;+BACYA,sBAAAA;;;eAAAA;;;AAAN,MAAMA,qBAAqB;IAChCC,MAAM,KAAO;AACf","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1404, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/shared/lib/hooks-client-context.shared-runtime.ts"],"sourcesContent":["'use client'\n\nimport { createContext } from 'react'\nimport type { Params } from '../../server/request/params'\n\nexport const SearchParamsContext = createContext<URLSearchParams | null>(null)\nexport const PathnameContext = createContext<string | null>(null)\nexport const PathParamsContext = createContext<Params | null>(null)\n\nif (process.env.NODE_ENV !== 'production') {\n  SearchParamsContext.displayName = 'SearchParamsContext'\n  PathnameContext.displayName = 'PathnameContext'\n  PathParamsContext.displayName = 'PathParamsContext'\n}\n"],"names":["PathParamsContext","PathnameContext","SearchParamsContext","createContext","process","env","NODE_ENV","displayName"],"mappings":"AASII,QAAQC,GAAG,CAACC,QAAQ,KAAK;AAT7B;;;;;;;;;;;;;;;;;IAOaN,iBAAiB,EAAA;eAAjBA;;IADAC,eAAe,EAAA;eAAfA;;IADAC,mBAAmB,EAAA;eAAnBA;;;uBAHiB;AAGvB,MAAMA,sBAAsBC,CAAAA,GAAAA,OAAAA,aAAa,EAAyB;AAClE,MAAMF,kBAAkBE,CAAAA,GAAAA,OAAAA,aAAa,EAAgB;AACrD,MAAMH,oBAAoBG,CAAAA,GAAAA,OAAAA,aAAa,EAAgB;AAE9D,wCAA2C;IACzCD,oBAAoBK,WAAW,GAAG;IAClCN,gBAAgBM,WAAW,GAAG;IAC9BP,kBAAkBO,WAAW,GAAG;AAClC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1445, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/server/app-render/async-local-storage.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\n\nconst sharedAsyncLocalStorageNotAvailableError = new Error(\n  'Invariant: AsyncLocalStorage accessed in runtime where it is not available'\n)\n\nclass FakeAsyncLocalStorage<Store extends {}>\n  implements AsyncLocalStorage<Store>\n{\n  disable(): void {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  getStore(): Store | undefined {\n    // This fake implementation of AsyncLocalStorage always returns `undefined`.\n    return undefined\n  }\n\n  run<R>(): R {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  exit<R>(): R {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  enterWith(): void {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  static bind<T>(fn: T): T {\n    return fn\n  }\n}\n\nconst maybeGlobalAsyncLocalStorage =\n  typeof globalThis !== 'undefined' && (globalThis as any).AsyncLocalStorage\n\nexport function createAsyncLocalStorage<\n  Store extends {},\n>(): AsyncLocalStorage<Store> {\n  if (maybeGlobalAsyncLocalStorage) {\n    return new maybeGlobalAsyncLocalStorage()\n  }\n  return new FakeAsyncLocalStorage()\n}\n\nexport function bindSnapshot<T>(fn: T): T {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.bind(fn)\n  }\n  return FakeAsyncLocalStorage.bind(fn)\n}\n\nexport function createSnapshot(): <R, TArgs extends any[]>(\n  fn: (...args: TArgs) => R,\n  ...args: TArgs\n) => R {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.snapshot()\n  }\n  return function (fn: any, ...args: any[]) {\n    return fn(...args)\n  }\n}\n"],"names":["bindSnapshot","createAsyncLocalStorage","createSnapshot","sharedAsyncLocalStorageNotAvailableError","Error","FakeAsyncLocalStorage","disable","getStore","undefined","run","exit","enterWith","bind","fn","maybeGlobalAsyncLocalStorage","globalThis","AsyncLocalStorage","snapshot","args"],"mappings":";;;;;;;;;;;;;;;IA+CgBA,YAAY,EAAA;eAAZA;;IATAC,uBAAuB,EAAA;eAAvBA;;IAgBAC,cAAc,EAAA;eAAdA;;;AApDhB,MAAMC,2CAA2C,OAAA,cAEhD,CAFgD,IAAIC,MACnD,+EAD+C,qBAAA;WAAA;gBAAA;kBAAA;AAEjD;AAEA,MAAMC;IAGJC,UAAgB;QACd,MAAMH;IACR;IAEAI,WAA8B;QAC5B,4EAA4E;QAC5E,OAAOC;IACT;IAEAC,MAAY;QACV,MAAMN;IACR;IAEAO,OAAa;QACX,MAAMP;IACR;IAEAQ,YAAkB;QAChB,MAAMR;IACR;IAEA,OAAOS,KAAQC,EAAK,EAAK;QACvB,OAAOA;IACT;AACF;AAEA,MAAMC,+BACJ,OAAOC,eAAe,eAAgBA,WAAmBC,iBAAiB;AAErE,SAASf;IAGd,IAAIa,8BAA8B;QAChC,OAAO,IAAIA;IACb;IACA,OAAO,IAAIT;AACb;AAEO,SAASL,aAAgBa,EAAK;IACnC,IAAIC,8BAA8B;QAChC,OAAOA,6BAA6BF,IAAI,CAACC;IAC3C;IACA,OAAOR,sBAAsBO,IAAI,CAACC;AACpC;AAEO,SAASX;IAId,IAAIY,8BAA8B;QAChC,OAAOA,6BAA6BG,QAAQ;IAC9C;IACA,OAAO,SAAUJ,EAAO;;YAAKK,2BAAH,KAAc;;QACtC,OAAOL,MAAMK;IACf;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1524, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/server/app-render/work-unit-async-storage-instance.ts"],"sourcesContent":["import { createAsyncLocalStorage } from './async-local-storage'\nimport type { WorkUnitAsyncStorage } from './work-unit-async-storage.external'\n\nexport const workUnitAsyncStorageInstance: WorkUnitAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["workUnitAsyncStorageInstance","createAsyncLocalStorage"],"mappings":";;;+BAGaA,gCAAAA;;;eAAAA;;;mCAH2B;AAGjC,MAAMA,+BACXC,CAAAA,GAAAA,mBAAAA,uBAAuB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1539, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/shared/lib/invariant-error.ts"],"sourcesContent":["export class InvariantError extends Error {\n  constructor(message: string, options?: ErrorOptions) {\n    super(\n      `Invariant: ${message.endsWith('.') ? message : message + '.'} This is a bug in Next.js.`,\n      options\n    )\n    this.name = 'InvariantError'\n  }\n}\n"],"names":["InvariantError","Error","constructor","message","options","endsWith","name"],"mappings":";;;+BAAaA,kBAAAA;;;eAAAA;;;AAAN,MAAMA,uBAAuBC;IAClCC,YAAYC,OAAe,EAAEC,OAAsB,CAAE;QACnD,KAAK,CACF,gBAAaD,CAAAA,QAAQE,QAAQ,CAAC,OAAOF,UAAUA,UAAU,GAAE,IAAE,8BAC9DC;QAEF,IAAI,CAACE,IAAI,GAAG;IACd;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1558, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/server/app-render/work-unit-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\nimport type { DraftModeProvider } from '../async-storage/draft-mode-provider'\nimport type { ResponseCookies } from '../web/spec-extension/cookies'\nimport type { ReadonlyHeaders } from '../web/spec-extension/adapters/headers'\nimport type { ReadonlyRequestCookies } from '../web/spec-extension/adapters/request-cookies'\nimport type { CacheSignal } from './cache-signal'\nimport type { DynamicTrackingState } from './dynamic-rendering'\nimport type { FallbackRouteParams } from '../request/fallback-params'\n\n// Share the instance module in the next-shared layer\nimport { workUnitAsyncStorageInstance } from './work-unit-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport type {\n  RenderResumeDataCache,\n  PrerenderResumeDataCache,\n} from '../resume-data-cache/resume-data-cache'\nimport type { Params } from '../request/params'\nimport type { ImplicitTags } from '../lib/implicit-tags'\nimport type { WorkStore } from './work-async-storage.external'\nimport { NEXT_HMR_REFRESH_HASH_COOKIE } from '../../client/components/app-router-headers'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nexport type WorkUnitPhase = 'action' | 'render' | 'after'\n\nexport interface CommonWorkUnitStore {\n  /** NOTE: Will be mutated as phases change */\n  phase: WorkUnitPhase\n  readonly implicitTags: ImplicitTags\n}\n\nexport interface RequestStore extends CommonWorkUnitStore {\n  readonly type: 'request'\n\n  /**\n   * The URL of the request. This only specifies the pathname and the search\n   * part of the URL.\n   */\n  readonly url: {\n    /**\n     * The pathname of the requested URL.\n     */\n    readonly pathname: string\n\n    /**\n     * The search part of the requested URL. If the request did not provide a\n     * search part, this will be an empty string.\n     */\n    readonly search: string\n  }\n\n  readonly headers: ReadonlyHeaders\n  // This is mutable because we need to reassign it when transitioning from the action phase to the render phase.\n  // The cookie object itself is deliberately read only and thus can't be updated.\n  cookies: ReadonlyRequestCookies\n  readonly mutableCookies: ResponseCookies\n  readonly userspaceMutableCookies: ResponseCookies\n  readonly draftMode: DraftModeProvider\n  readonly isHmrRefresh?: boolean\n  readonly serverComponentsHmrCache?: ServerComponentsHmrCache\n\n  readonly rootParams: Params\n\n  /**\n   * The resume data cache for this request. This will be a immutable cache.\n   */\n  renderResumeDataCache: RenderResumeDataCache | null\n\n  // DEV-only\n  usedDynamic?: boolean\n  prerenderPhase?: boolean\n  devFallbackParams?: FallbackRouteParams | null\n}\n\n/**\n * The Prerender store is for tracking information related to prerenders.\n *\n * It can be used for both RSC and SSR prerendering and should be scoped as close\n * to the individual `renderTo...` API call as possible. To keep the type simple\n * we don't distinguish between RSC and SSR prerendering explicitly but instead\n * use conditional object properties to infer which mode we are in. For instance cache tracking\n * only needs to happen during the RSC prerender when we are prospectively prerendering\n * to fill all caches.\n */\nexport type PrerenderStoreModern =\n  | PrerenderStoreModernClient\n  | PrerenderStoreModernServer\n  | PrerenderStoreModernRuntime\n\n/** Like `PrerenderStoreModern`, but only including static prerenders (i.e. not runtime prerenders) */\nexport type StaticPrerenderStoreModern = Exclude<\n  PrerenderStoreModern,\n  PrerenderStoreModernRuntime\n>\n\nexport interface PrerenderStoreModernClient\n  extends PrerenderStoreModernCommon,\n    StaticPrerenderStoreCommon {\n  readonly type: 'prerender-client'\n}\n\nexport interface PrerenderStoreModernServer\n  extends PrerenderStoreModernCommon,\n    StaticPrerenderStoreCommon {\n  readonly type: 'prerender'\n}\n\nexport interface PrerenderStoreModernRuntime\n  extends PrerenderStoreModernCommon {\n  readonly type: 'prerender-runtime'\n\n  /**\n   * A runtime prerender resolves APIs in two tasks:\n   *\n   * 1. Static data (available in a static prerender)\n   * 2. Runtime data (available in a runtime prerender)\n   *\n   * This separation is achieved by awaiting this promise in \"runtime\" APIs.\n   * In the final prerender, the promise will be resolved during the second task,\n   * and the render will be aborted in the task that follows it.\n   */\n  readonly runtimeStagePromise: Promise<void> | null\n\n  readonly cookies: RequestStore['cookies']\n  readonly draftMode: RequestStore['draftMode']\n}\n\nexport interface RevalidateStore {\n  // Collected revalidate times and tags for this document during the prerender.\n  revalidate: number // in seconds. 0 means dynamic. INFINITE_CACHE and higher means never revalidate.\n  expire: number // server expiration time\n  stale: number // client expiration time\n  tags: null | string[]\n}\n\ninterface PrerenderStoreModernCommon\n  extends CommonWorkUnitStore,\n    RevalidateStore {\n  /**\n   * The render signal is aborted after React's `prerender` function is aborted\n   * (using a separate signal), which happens in two cases:\n   *\n   * 1. When all caches are filled during the prospective prerender.\n   * 2. When the final prerender is aborted immediately after the prerender was\n   *    started.\n   *\n   * It can be used to reject any pending I/O, including hanging promises. This\n   * allows React to properly track the async I/O in dev mode, which yields\n   * better owner stacks for dynamic validation errors.\n   */\n  readonly renderSignal: AbortSignal\n\n  /**\n   * This is the AbortController which represents the boundary between Prerender\n   * and dynamic. In some renders it is the same as the controller for React,\n   * but in others it is a separate controller. It should be aborted whenever we\n   * are no longer in the prerender phase of rendering. Typically this is after\n   * one task, or when you call a sync API which requires the prerender to end\n   * immediately.\n   */\n  readonly controller: AbortController\n\n  /**\n   * When not null, this signal is used to track cache reads during prerendering\n   * and to await all cache reads completing, before aborting the prerender.\n   */\n  readonly cacheSignal: null | CacheSignal\n\n  /**\n   * During some prerenders we want to track dynamic access.\n   */\n  readonly dynamicTracking: null | DynamicTrackingState\n\n  readonly rootParams: Params\n\n  /**\n   * A mutable resume data cache for this prerender.\n   */\n  prerenderResumeDataCache: PrerenderResumeDataCache | null\n\n  /**\n   * An immutable resume data cache for this prerender. This may be provided\n   * instead of the `prerenderResumeDataCache` if the prerender is not supposed\n   * to fill caches, and only read from prefilled caches, e.g. when prerendering\n   * an optional fallback shell.\n   */\n  renderResumeDataCache: RenderResumeDataCache | null\n\n  /**\n   * The HMR refresh hash is only provided in dev mode. It is needed for the dev\n   * warmup render to ensure that the cache keys will be identical for the\n   * subsequent dynamic render.\n   */\n  readonly hmrRefreshHash: string | undefined\n\n  /**\n   * Only available in dev mode.\n   */\n  readonly captureOwnerStack: undefined | (() => string | null)\n}\n\ninterface StaticPrerenderStoreCommon {\n  /**\n   * The set of unknown route parameters. Accessing these will be tracked as\n   * a dynamic access.\n   */\n  readonly fallbackRouteParams: FallbackRouteParams | null\n\n  /**\n   * When true, the page is prerendered as a fallback shell, while allowing any\n   * dynamic accesses to result in an empty shell. This is the case when there\n   * are also routes prerendered with a more complete set of params.\n   * Prerendering those routes would catch any invalid dynamic accesses.\n   */\n  readonly allowEmptyStaticShell: boolean\n}\n\nexport interface PrerenderStorePPR\n  extends CommonWorkUnitStore,\n    RevalidateStore {\n  readonly type: 'prerender-ppr'\n  readonly rootParams: Params\n  readonly dynamicTracking: null | DynamicTrackingState\n\n  /**\n   * The set of unknown route parameters. Accessing these will be tracked as\n   * a dynamic access.\n   */\n  readonly fallbackRouteParams: FallbackRouteParams | null\n\n  /**\n   * The resume data cache for this prerender.\n   */\n  prerenderResumeDataCache: PrerenderResumeDataCache\n}\n\nexport interface PrerenderStoreLegacy\n  extends CommonWorkUnitStore,\n    RevalidateStore {\n  readonly type: 'prerender-legacy'\n  readonly rootParams: Params\n}\n\nexport type PrerenderStore =\n  | PrerenderStoreLegacy\n  | PrerenderStorePPR\n  | PrerenderStoreModern\n\n// /** Like `PrerenderStoreModern`, but only including static prerenders (i.e. not runtime prerenders) */\nexport type StaticPrerenderStore = Exclude<\n  PrerenderStore,\n  PrerenderStoreModernRuntime\n>\n\nexport interface CommonCacheStore\n  extends Omit<CommonWorkUnitStore, 'implicitTags'> {\n  /**\n   * A cache work unit store might not always have an outer work unit store,\n   * from which implicit tags could be inherited.\n   */\n  readonly implicitTags: ImplicitTags | undefined\n  /**\n   * Draft mode is only available if the outer work unit store is a request\n   * store and draft mode is enabled.\n   */\n  readonly draftMode: DraftModeProvider | undefined\n}\n\nexport interface CommonUseCacheStore extends CommonCacheStore, RevalidateStore {\n  explicitRevalidate: undefined | number // explicit revalidate time from cacheLife() calls\n  explicitExpire: undefined | number // server expiration time\n  explicitStale: undefined | number // client expiration time\n  readonly hmrRefreshHash: string | undefined\n  readonly isHmrRefresh: boolean\n  readonly serverComponentsHmrCache: ServerComponentsHmrCache | undefined\n  readonly forceRevalidate: boolean\n}\n\nexport interface PublicUseCacheStore extends CommonUseCacheStore {\n  readonly type: 'cache'\n}\n\nexport interface PrivateUseCacheStore extends CommonUseCacheStore {\n  readonly type: 'private-cache'\n\n  /**\n   * A runtime prerender resolves APIs in two tasks:\n   *\n   * 1. Static data (available in a static prerender)\n   * 2. Runtime data (available in a runtime prerender)\n   *\n   * This separation is achieved by awaiting this promise in \"runtime\" APIs.\n   * In the final prerender, the promise will be resolved during the second task,\n   * and the render will be aborted in the task that follows it.\n   */\n  readonly runtimeStagePromise: Promise<void> | null\n\n  /**\n   * As opposed to the public cache store, the private cache store is allowed to\n   * access the request cookies.\n   */\n  readonly cookies: ReadonlyRequestCookies\n\n  /**\n   * Private caches don't currently need to track root params in the cache key\n   * because they're not persisted anywhere, so we can allow root params access\n   * (unlike public caches)\n   */\n  readonly rootParams: Params\n}\n\nexport type UseCacheStore = PublicUseCacheStore | PrivateUseCacheStore\n\nexport interface UnstableCacheStore extends CommonCacheStore {\n  readonly type: 'unstable-cache'\n}\n\n/**\n * The Cache store is for tracking information inside a \"use cache\" or\n * unstable_cache context. A cache store shadows an outer request store (if\n * present) as a work unit, so that we never accidentally expose any request or\n * page specific information to cache functions, unless it's explicitly desired.\n * For those exceptions, the data is copied over from the request store to the\n * cache store, instead of generally making the request store available to cache\n * functions.\n */\nexport type CacheStore = UseCacheStore | UnstableCacheStore\n\nexport type WorkUnitStore = RequestStore | CacheStore | PrerenderStore\n\nexport type WorkUnitAsyncStorage = AsyncLocalStorage<WorkUnitStore>\n\nexport { workUnitAsyncStorageInstance as workUnitAsyncStorage }\n\nexport function throwForMissingRequestStore(callingExpression: string): never {\n  throw new Error(\n    `\\`${callingExpression}\\` was called outside a request scope. Read more: https://nextjs.org/docs/messages/next-dynamic-api-wrong-context`\n  )\n}\n\nexport function throwInvariantForMissingStore(): never {\n  throw new InvariantError('Expected workUnitAsyncStorage to have a store.')\n}\n\nexport function getPrerenderResumeDataCache(\n  workUnitStore: WorkUnitStore\n): PrerenderResumeDataCache | null {\n  switch (workUnitStore.type) {\n    case 'prerender':\n    case 'prerender-runtime':\n    case 'prerender-ppr':\n      return workUnitStore.prerenderResumeDataCache\n    case 'prerender-client':\n      // TODO eliminate fetch caching in client scope and stop exposing this data\n      // cache during SSR.\n      return workUnitStore.prerenderResumeDataCache\n    case 'prerender-legacy':\n    case 'request':\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n      return null\n    default:\n      return workUnitStore satisfies never\n  }\n}\n\nexport function getRenderResumeDataCache(\n  workUnitStore: WorkUnitStore\n): RenderResumeDataCache | null {\n  switch (workUnitStore.type) {\n    case 'request':\n      return workUnitStore.renderResumeDataCache\n    case 'prerender':\n    case 'prerender-runtime':\n    case 'prerender-client':\n      if (workUnitStore.renderResumeDataCache) {\n        // If we are in a prerender, we might have a render resume data cache\n        // that is used to read from prefilled caches.\n        return workUnitStore.renderResumeDataCache\n      }\n    // fallthrough\n    case 'prerender-ppr':\n      // Otherwise we return the mutable resume data cache here as an immutable\n      // version of the cache as it can also be used for reading.\n      return workUnitStore.prerenderResumeDataCache\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n    case 'prerender-legacy':\n      return null\n    default:\n      return workUnitStore satisfies never\n  }\n}\n\nexport function getHmrRefreshHash(\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore\n): string | undefined {\n  if (workStore.dev) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'private-cache':\n      case 'prerender':\n      case 'prerender-runtime':\n        return workUnitStore.hmrRefreshHash\n      case 'request':\n        return workUnitStore.cookies.get(NEXT_HMR_REFRESH_HASH_COOKIE)?.value\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  return undefined\n}\n\nexport function isHmrRefresh(\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore\n): boolean {\n  if (workStore.dev) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'private-cache':\n      case 'request':\n        return workUnitStore.isHmrRefresh ?? false\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-runtime':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  return false\n}\n\nexport function getServerComponentsHmrCache(\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore\n): ServerComponentsHmrCache | undefined {\n  if (workStore.dev) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'private-cache':\n      case 'request':\n        return workUnitStore.serverComponentsHmrCache\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-runtime':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Returns a draft mode provider only if draft mode is enabled.\n */\nexport function getDraftModeProviderForCacheScope(\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore\n): DraftModeProvider | undefined {\n  if (workStore.isDraftMode) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n      case 'prerender-runtime':\n      case 'request':\n        return workUnitStore.draftMode\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  return undefined\n}\n\nexport function getCacheSignal(\n  workUnitStore: WorkUnitStore\n): CacheSignal | null {\n  switch (workUnitStore.type) {\n    case 'prerender':\n    case 'prerender-client':\n    case 'prerender-runtime':\n      return workUnitStore.cacheSignal\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'request':\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n      return null\n    default:\n      return workUnitStore satisfies never\n  }\n}\n\nexport function getRuntimeStagePromise(\n  workUnitStore: WorkUnitStore\n): Promise<void> | null {\n  switch (workUnitStore.type) {\n    case 'prerender-runtime':\n    case 'private-cache':\n      return workUnitStore.runtimeStagePromise\n    case 'prerender':\n    case 'prerender-client':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'request':\n    case 'cache':\n    case 'unstable-cache':\n      return null\n    default:\n      return workUnitStore satisfies never\n  }\n}\n"],"names":["getCacheSignal","getDraftModeProviderForCacheScope","getHmrRefreshHash","getPrerenderResumeDataCache","getRenderResumeDataCache","getRuntimeStagePromise","getServerComponentsHmrCache","isHmrRefresh","throwForMissingRequestStore","throwInvariantForMissingStore","workUnitAsyncStorage","workUnitAsyncStorageInstance","callingExpression","Error","InvariantError","workUnitStore","type","prerenderResumeDataCache","renderResumeDataCache","workStore","dev","hmrRefreshHash","cookies","get","NEXT_HMR_REFRESH_HASH_COOKIE","value","undefined","serverComponentsHmrCache","isDraftMode","draftMode","cacheSignal","runtimeStagePromise"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1799, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/navigation-untracked.ts"],"sourcesContent":["import { useContext } from 'react'\nimport { PathnameContext } from '../../shared/lib/hooks-client-context.shared-runtime'\n\n/**\n * This checks to see if the current render has any unknown route parameters.\n * It's used to trigger a different render path in the error boundary.\n *\n * @returns true if there are any unknown route parameters, false otherwise\n */\nfunction hasFallbackRouteParams(): boolean {\n  if (typeof window === 'undefined') {\n    // AsyncLocalStorage should not be included in the client bundle.\n    const { workUnitAsyncStorage } =\n      require('../../server/app-render/work-unit-async-storage.external') as typeof import('../../server/app-render/work-unit-async-storage.external')\n\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    if (!workUnitStore) return false\n\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        return fallbackParams ? fallbackParams.size > 0 : false\n      case 'prerender-legacy':\n      case 'request':\n      case 'prerender-runtime':\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n\n    return false\n  }\n\n  return false\n}\n\n/**\n * This returns a `null` value if there are any unknown route parameters, and\n * otherwise returns the pathname from the context. This is an alternative to\n * `usePathname` that is used in the error boundary to avoid rendering the\n * error boundary when there are unknown route parameters. This doesn't throw\n * when accessed with unknown route parameters.\n *\n * @returns\n *\n * @internal\n */\nexport function useUntrackedPathname(): string | null {\n  // If there are any unknown route parameters we would typically throw\n  // an error, but this internal method allows us to return a null value instead\n  // for components that do not propagate the pathname to the static shell (like\n  // the error boundary).\n  if (hasFallbackRouteParams()) {\n    return null\n  }\n\n  // This shouldn't cause any issues related to conditional rendering because\n  // the environment will be consistent for the render.\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return useContext(PathnameContext)\n}\n"],"names":["useUntrackedPathname","hasFallbackRouteParams","window","workUnitAsyncStorage","require","workUnitStore","getStore","type","fallbackParams","fallbackRouteParams","size","useContext","PathnameContext"],"mappings":";;;+BAoDgBA,wBAAAA;;;eAAAA;;;uBApDW;iDACK;AAEhC;;;;;CAKC,GACD,SAASC;IACP,IAAI,OAAOC,WAAW,aAAa;QACjC,iEAAiE;QACjE,MAAM,EAAEC,oBAAoB,EAAE,GAC5BC,QAAQ;QAEV,MAAMC,gBAAgBF,qBAAqBG,QAAQ;QACnD,IAAI,CAACD,eAAe,OAAO;QAE3B,OAAQA,cAAcE,IAAI;YACxB,KAAK;YACL,KAAK;YACL,KAAK;gBACH,MAAMC,iBAAiBH,cAAcI,mBAAmB;gBACxD,OAAOD,iBAAiBA,eAAeE,IAAI,GAAG,IAAI;YACpD,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;gBACH;YACF;gBACEL;QACJ;QAEA,OAAO;IACT;IAEA,OAAO;AACT;AAaO,SAASL;IACd,qEAAqE;IACrE,8EAA8E;IAC9E,8EAA8E;IAC9E,uBAAuB;IACvB,IAAIC,0BAA0B;QAC5B,OAAO;IACT;IAEA,2EAA2E;IAC3E,qDAAqD;IACrD,sDAAsD;IACtD,OAAOU,CAAAA,GAAAA,OAAAA,UAAU,EAACC,iCAAAA,eAAe;AACnC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1865, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/http-access-fallback/http-access-fallback.ts"],"sourcesContent":["export const HTTPAccessErrorStatus = {\n  NOT_FOUND: 404,\n  FORBIDDEN: 403,\n  UNAUTHORIZED: 401,\n}\n\nconst ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus))\n\nexport const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK'\n\nexport type HTTPAccessFallbackError = Error & {\n  digest: `${typeof HTTP_ERROR_FALLBACK_ERROR_CODE};${string}`\n}\n\n/**\n * Checks an error to determine if it's an error generated by\n * the HTTP navigation APIs `notFound()`, `forbidden()` or `unauthorized()`.\n *\n * @param error the error that may reference a HTTP access error\n * @returns true if the error is a HTTP access error\n */\nexport function isHTTPAccessFallbackError(\n  error: unknown\n): error is HTTPAccessFallbackError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n  const [prefix, httpStatus] = error.digest.split(';')\n\n  return (\n    prefix === HTTP_ERROR_FALLBACK_ERROR_CODE &&\n    ALLOWED_CODES.has(Number(httpStatus))\n  )\n}\n\nexport function getAccessFallbackHTTPStatus(\n  error: HTTPAccessFallbackError\n): number {\n  const httpStatus = error.digest.split(';')[1]\n  return Number(httpStatus)\n}\n\nexport function getAccessFallbackErrorTypeByStatus(\n  status: number\n): 'not-found' | 'forbidden' | 'unauthorized' | undefined {\n  switch (status) {\n    case 401:\n      return 'unauthorized'\n    case 403:\n      return 'forbidden'\n    case 404:\n      return 'not-found'\n    default:\n      return\n  }\n}\n"],"names":["HTTPAccessErrorStatus","HTTP_ERROR_FALLBACK_ERROR_CODE","getAccessFallbackErrorTypeByStatus","getAccessFallbackHTTPStatus","isHTTPAccessFallbackError","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","ALLOWED_CODES","Set","Object","values","error","digest","prefix","httpStatus","split","has","Number","status"],"mappings":";;;;;;;;;;;;;;;;;IAAaA,qBAAqB,EAAA;eAArBA;;IAQAC,8BAA8B,EAAA;eAA9BA;;IAuCGC,kCAAkC,EAAA;eAAlCA;;IAPAC,2BAA2B,EAAA;eAA3BA;;IAnBAC,yBAAyB,EAAA;eAAzBA;;;AArBT,MAAMJ,wBAAwB;IACnCK,WAAW;IACXC,WAAW;IACXC,cAAc;AAChB;AAEA,MAAMC,gBAAgB,IAAIC,IAAIC,OAAOC,MAAM,CAACX;AAErC,MAAMC,iCAAiC;AAavC,SAASG,0BACdQ,KAAc;IAEd,IACE,OAAOA,UAAU,YACjBA,UAAU,QACV,CAAE,CAAA,YAAYA,KAAI,KAClB,OAAOA,MAAMC,MAAM,KAAK,UACxB;QACA,OAAO;IACT;IACA,MAAM,CAACC,QAAQC,WAAW,GAAGH,MAAMC,MAAM,CAACG,KAAK,CAAC;IAEhD,OACEF,WAAWb,kCACXO,cAAcS,GAAG,CAACC,OAAOH;AAE7B;AAEO,SAASZ,4BACdS,KAA8B;IAE9B,MAAMG,aAAaH,MAAMC,MAAM,CAACG,KAAK,CAAC,IAAI,CAAC,EAAE;IAC7C,OAAOE,OAAOH;AAChB;AAEO,SAASb,mCACdiB,MAAc;IAEd,OAAQA;QACN,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT;YACE;IACJ;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1939, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/redirect-status-code.ts"],"sourcesContent":["export enum RedirectStatusCode {\n  SeeOther = 303,\n  TemporaryRedirect = 307,\n  PermanentRedirect = 308,\n}\n"],"names":["RedirectStatusCode"],"mappings":";;;+BAAYA,sBAAAA;;;eAAAA;;;AAAL,IAAKA,qBAAAA,WAAAA,GAAAA,SAAAA,kBAAAA;;;;WAAAA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1965, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/redirect-error.ts"],"sourcesContent":["import { RedirectStatusCode } from './redirect-status-code'\n\nexport const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT'\n\nexport enum RedirectType {\n  push = 'push',\n  replace = 'replace',\n}\n\nexport type RedirectError = Error & {\n  digest: `${typeof REDIRECT_ERROR_CODE};${RedirectType};${string};${RedirectStatusCode};`\n}\n\n/**\n * Checks an error to determine if it's an error generated by the\n * `redirect(url)` helper.\n *\n * @param error the error that may reference a redirect error\n * @returns true if the error is a redirect error\n */\nexport function isRedirectError(error: unknown): error is RedirectError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n\n  const digest = error.digest.split(';')\n  const [errorCode, type] = digest\n  const destination = digest.slice(2, -2).join(';')\n  const status = digest.at(-2)\n\n  const statusCode = Number(status)\n\n  return (\n    errorCode === REDIRECT_ERROR_CODE &&\n    (type === 'replace' || type === 'push') &&\n    typeof destination === 'string' &&\n    !isNaN(statusCode) &&\n    statusCode in RedirectStatusCode\n  )\n}\n"],"names":["REDIRECT_ERROR_CODE","RedirectType","isRedirectError","error","digest","split","errorCode","type","destination","slice","join","status","at","statusCode","Number","isNaN","RedirectStatusCode"],"mappings":";;;;;;;;;;;;;;;IAEaA,mBAAmB,EAAA;eAAnBA;;IAEDC,YAAY,EAAA;eAAZA;;IAgBIC,eAAe,EAAA;eAAfA;;;oCApBmB;AAE5B,MAAMF,sBAAsB;AAE5B,IAAKC,eAAAA,WAAAA,GAAAA,SAAAA,YAAAA;;;WAAAA;;AAgBL,SAASC,gBAAgBC,KAAc;IAC5C,IACE,OAAOA,UAAU,YACjBA,UAAU,QACV,CAAE,CAAA,YAAYA,KAAI,KAClB,OAAOA,MAAMC,MAAM,KAAK,UACxB;QACA,OAAO;IACT;IAEA,MAAMA,SAASD,MAAMC,MAAM,CAACC,KAAK,CAAC;IAClC,MAAM,CAACC,WAAWC,KAAK,GAAGH;IAC1B,MAAMI,cAAcJ,OAAOK,KAAK,CAAC,GAAG,CAAC,GAAGC,IAAI,CAAC;IAC7C,MAAMC,SAASP,OAAOQ,EAAE,CAAC,CAAC;IAE1B,MAAMC,aAAaC,OAAOH;IAE1B,OACEL,cAAcN,uBACbO,CAAAA,SAAS,aAAaA,SAAS,MAAK,KACrC,OAAOC,gBAAgB,YACvB,CAACO,MAAMF,eACPA,cAAcG,oBAAAA,kBAAkB;AAEpC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2019, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/is-next-router-error.ts"],"sourcesContent":["import {\n  isHTTPAccessFallbackError,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\nimport { isRedirectError, type RedirectError } from './redirect-error'\n\n/**\n * Returns true if the error is a navigation signal error. These errors are\n * thrown by user code to perform navigation operations and interrupt the React\n * render.\n */\nexport function isNextRouterError(\n  error: unknown\n): error is RedirectError | HTTPAccessFallbackError {\n  return isRedirectError(error) || isHTTPAccessFallbackError(error)\n}\n"],"names":["isNextRouterError","error","isRedirectError","isHTTPAccessFallbackError"],"mappings":";;;+BAWgBA,qBAAAA;;;eAAAA;;;oCART;+BAC6C;AAO7C,SAASA,kBACdC,KAAc;IAEd,OAAOC,CAAAA,GAAAA,eAAAA,eAAe,EAACD,UAAUE,CAAAA,GAAAA,oBAAAA,yBAAyB,EAACF;AAC7D","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2044, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/router-reducer/create-href-from-url.ts"],"sourcesContent":["export function createHrefFromUrl(\n  url: Pick<URL, 'pathname' | 'search' | 'hash'>,\n  includeHash: boolean = true\n): string {\n  return url.pathname + url.search + (includeHash ? url.hash : '')\n}\n"],"names":["createHrefFromUrl","url","includeHash","pathname","search","hash"],"mappings":";;;+BAAgBA,qBAAAA;;;eAAAA;;;AAAT,SAASA,kBACdC,GAA8C,EAC9CC,WAA2B;IAA3BA,IAAAA,gBAAAA,KAAAA,GAAAA,cAAuB;IAEvB,OAAOD,IAAIE,QAAQ,GAAGF,IAAIG,MAAM,GAAIF,CAAAA,cAAcD,IAAII,IAAI,GAAG,EAAC;AAChE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2068, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/nav-failure-handler.ts"],"sourcesContent":["import { useEffect } from 'react'\nimport { createHrefFromUrl } from './router-reducer/create-href-from-url'\n\nexport function handleHardNavError(error: unknown): boolean {\n  if (\n    error &&\n    typeof window !== 'undefined' &&\n    window.next.__pendingUrl &&\n    createHrefFromUrl(new URL(window.location.href)) !==\n      createHrefFromUrl(window.next.__pendingUrl)\n  ) {\n    console.error(\n      `Error occurred during navigation, falling back to hard navigation`,\n      error\n    )\n    window.location.href = window.next.__pendingUrl.toString()\n    return true\n  }\n  return false\n}\n\nexport function useNavFailureHandler() {\n  if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n    // this if is only for DCE of the feature flag not conditional\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      const uncaughtExceptionHandler = (\n        evt: ErrorEvent | PromiseRejectionEvent\n      ) => {\n        const error = 'reason' in evt ? evt.reason : evt.error\n        // if we have an unhandled exception/rejection during\n        // a navigation we fall back to a hard navigation to\n        // attempt recovering to a good state\n        handleHardNavError(error)\n      }\n      window.addEventListener('unhandledrejection', uncaughtExceptionHandler)\n      window.addEventListener('error', uncaughtExceptionHandler)\n      return () => {\n        window.removeEventListener('error', uncaughtExceptionHandler)\n        window.removeEventListener(\n          'unhandledrejection',\n          uncaughtExceptionHandler\n        )\n      }\n    }, [])\n  }\n}\n"],"names":["handleHardNavError","useNavFailureHandler","error","window","next","__pendingUrl","createHrefFromUrl","URL","location","href","console","toString","process","env","__NEXT_APP_NAV_FAIL_HANDLING","useEffect","uncaughtExceptionHandler","evt","reason","addEventListener","removeEventListener"],"mappings":"AAsBMY,QAAQC,GAAG,CAACC,4BAA4B,EAAE;;;;;;;;;;;;;;;;IAnBhCd,kBAAkB,EAAA;eAAlBA;;IAkBAC,oBAAoB,EAAA;eAApBA;;;uBArBU;mCACQ;AAE3B,SAASD,mBAAmBE,KAAc;IAC/C,IACEA,SACA,OAAOC,WAAW,eAClBA,OAAOC,IAAI,CAACC,YAAY,IACxBC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAAC,IAAIC,IAAIJ,OAAOK,QAAQ,CAACC,IAAI,OAC5CH,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACH,OAAOC,IAAI,CAACC,YAAY,GAC5C;QACAK,QAAQR,KAAK,CACV,qEACDA;QAEFC,OAAOK,QAAQ,CAACC,IAAI,GAAGN,OAAOC,IAAI,CAACC,YAAY,CAACM,QAAQ;QACxD,OAAO;IACT;IACA,OAAO;AACT;AAEO,SAASV;IACd;;AAwBF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2116, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/server/app-render/work-async-storage-instance.ts"],"sourcesContent":["import type { WorkAsyncStorage } from './work-async-storage.external'\nimport { createAsyncLocalStorage } from './async-local-storage'\n\nexport const workAsyncStorageInstance: WorkAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["workAsyncStorageInstance","createAsyncLocalStorage"],"mappings":";;;+BAGaA,4BAAAA;;;eAAAA;;;mCAF2B;AAEjC,MAAMA,2BACXC,CAAAA,GAAAA,mBAAAA,uBAAuB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2131, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/server/app-render/work-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\nimport type { IncrementalCache } from '../lib/incremental-cache'\nimport type { FetchMetrics } from '../base-http'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport type { AppSegmentConfig } from '../../build/segment-config/app/app-segment-config'\nimport type { AfterContext } from '../after/after-context'\nimport type { CacheLife } from '../use-cache/cache-life'\n\n// Share the instance module in the next-shared layer\nimport { workAsyncStorageInstance } from './work-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nimport type { LazyResult } from '../lib/lazy-result'\n\nexport interface WorkStore {\n  readonly isStaticGeneration: boolean\n\n  /**\n   * The page that is being rendered. This relates to the path to the page file.\n   */\n  readonly page: string\n\n  /**\n   * The route that is being rendered. This is the page property without the\n   * trailing `/page` or `/route` suffix.\n   */\n  readonly route: string\n\n  readonly incrementalCache?: IncrementalCache\n  readonly cacheLifeProfiles?: { [profile: string]: CacheLife }\n\n  readonly isOnDemandRevalidate?: boolean\n  readonly isBuildTimePrerendering?: boolean\n\n  /**\n   * This is true when:\n   * - source maps are generated\n   * - source maps are applied\n   * - minification is disabled\n   */\n  readonly hasReadableErrorStacks?: boolean\n\n  readonly isRevalidate?: boolean\n\n  forceDynamic?: boolean\n  fetchCache?: AppSegmentConfig['fetchCache']\n\n  forceStatic?: boolean\n  dynamicShouldError?: boolean\n  pendingRevalidates?: Record<string, Promise<any>>\n  pendingRevalidateWrites?: Array<Promise<void>> // This is like pendingRevalidates but isn't used for deduping.\n  readonly afterContext: AfterContext\n\n  dynamicUsageDescription?: string\n  dynamicUsageStack?: string\n\n  /**\n   * Invalid dynamic usage errors might be caught in userland. We attach them to\n   * the work store to ensure we can still fail the build, or show en error in\n   * dev mode.\n   */\n  // TODO: Collect an array of errors, and throw as AggregateError when\n  // `serializeError` and the Dev Overlay support it.\n  invalidDynamicUsageError?: Error\n\n  nextFetchId?: number\n  pathWasRevalidated?: boolean\n\n  /**\n   * Tags that were revalidated during the current request. They need to be sent\n   * to cache handlers to propagate their revalidation.\n   */\n  pendingRevalidatedTags?: string[]\n\n  /**\n   * Tags that were previously revalidated (e.g. by a redirecting server action)\n   * and have already been sent to cache handlers. Retrieved cache entries that\n   * include any of these tags must be discarded.\n   */\n  readonly previouslyRevalidatedTags: readonly string[]\n\n  /**\n   * This map contains lazy results so that we can evaluate them when the first\n   * cache entry is read. It allows us to skip refreshing tags if no caches are\n   * read at all.\n   */\n  readonly refreshTagsByCacheKind: Map<string, LazyResult<void>>\n\n  fetchMetrics?: FetchMetrics\n  shouldTrackFetchMetrics: boolean\n\n  isDraftMode?: boolean\n  isUnstableNoStore?: boolean\n  isPrefetchRequest?: boolean\n\n  buildId: string\n\n  readonly reactLoadableManifest?: DeepReadonly<\n    Record<string, { files: string[] }>\n  >\n  readonly assetPrefix?: string\n\n  cacheComponentsEnabled: boolean\n  dev: boolean\n\n  /**\n   * Run the given function inside a clean AsyncLocalStorage snapshot. This is\n   * useful when generating cache entries, to ensure that the cache generation\n   * cannot read anything from the context we're currently executing in, which\n   * might include request-specific things like `cookies()` inside a\n   * `React.cache()`.\n   */\n  runInCleanSnapshot: <R, TArgs extends any[]>(\n    fn: (...args: TArgs) => R,\n    ...args: TArgs\n  ) => R\n}\n\nexport type WorkAsyncStorage = AsyncLocalStorage<WorkStore>\n\nexport { workAsyncStorageInstance as workAsyncStorage }\n"],"names":["workAsyncStorage","workAsyncStorageInstance"],"mappings":";;;+BAsHqCA,oBAAAA;;;eAA5BC,0BAAAA,wBAAwB;;;0CA7GQ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2145, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/handle-isr-error.tsx"],"sourcesContent":["const workAsyncStorage =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n      ).workAsyncStorage\n    : undefined\n\n// if we are revalidating we want to re-throw the error so the\n// function crashes so we can maintain our previous cache\n// instead of caching the error page\nexport function HandleISRError({ error }: { error: any }) {\n  if (workAsyncStorage) {\n    const store = workAsyncStorage.getStore()\n    if (store?.isRevalidate || store?.isStaticGeneration) {\n      console.error(error)\n      throw error\n    }\n  }\n\n  return null\n}\n"],"names":["HandleISRError","workAsyncStorage","window","require","undefined","error","store","getStore","isRevalidate","isStaticGeneration","console"],"mappings":";;;+BAUgBA,kBAAAA;;;eAAAA;;;AAVhB,MAAMC,mBACJ,OAAOC,WAAW,cAEZC,QAAQ,yKACRF,gBAAgB,GAClBG;AAKC,SAASJ,eAAe,KAAyB;IAAzB,IAAA,EAAEK,KAAK,EAAkB,GAAzB;IAC7B,IAAIJ,kBAAkB;QACpB,MAAMK,QAAQL,iBAAiBM,QAAQ;QACvC,IAAID,CAAAA,SAAAA,OAAAA,KAAAA,IAAAA,MAAOE,YAAY,KAAA,CAAIF,SAAAA,OAAAA,KAAAA,IAAAA,MAAOG,kBAAkB,GAAE;YACpDC,QAAQL,KAAK,CAACA;YACd,MAAMA;QACR;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2177, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/shared/lib/router/utils/html-bots.ts"],"sourcesContent":["// This regex contains the bots that we need to do a blocking render for and can't safely stream the response\n// due to how they parse the DOM. For example, they might explicitly check for metadata in the `head` tag, so we can't stream metadata tags after the `head` was sent.\n// Note: The pattern [\\w-]+-Google captures all Google crawlers with \"-Google\" suffix (e.g., Mediapartners-Google, AdsBot-Google, Storebot-Google)\n// as well as crawlers starting with \"Google-\" (e.g., Google-PageRenderer, Google-InspectionTool)\nexport const HTML_LIMITED_BOT_UA_RE =\n  /[\\w-]+-Google|Google-[\\w-]+|Chrome-Lighthouse|Slurp|DuckDuckBot|baiduspider|yandex|sogou|bitlybot|tumblr|vkShare|quora link preview|redditbot|ia_archiver|Bingbot|BingPreview|applebot|facebookexternalhit|facebookcatalog|Twitterbot|LinkedInBot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|Yeti|googleweblight/i\n"],"names":["HTML_LIMITED_BOT_UA_RE"],"mappings":"AAAA,6GAA6G;AAC7G,sKAAsK;AACtK,kJAAkJ;AAClJ,iGAAiG;;;;+BACpFA,0BAAAA;;;eAAAA;;;AAAN,MAAMA,yBACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2195, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/shared/lib/router/utils/is-bot.ts"],"sourcesContent":["import { HTML_LIMITED_BOT_UA_RE } from './html-bots'\n\n// Bot crawler that will spin up a headless browser and execute JS.\n// Only the main Googlebot search crawler executes JavaScript, not other Google crawlers.\n// x-ref: https://developers.google.com/search/docs/crawling-indexing/google-common-crawlers\n// This regex specifically matches \"Googlebot\" but NOT \"Mediapartners-Google\", \"AdsBot-Google\", etc.\nconst HEADLESS_BROWSER_BOT_UA_RE = /Googlebot(?!-)|Googlebot$/i\n\nexport const HTML_LIMITED_BOT_UA_RE_STRING = HTML_LIMITED_BOT_UA_RE.source\n\nexport { HTML_LIMITED_BOT_UA_RE }\n\nfunction isDomBotUA(userAgent: string) {\n  return HEADLESS_BROWSER_BOT_UA_RE.test(userAgent)\n}\n\nfunction isHtmlLimitedBotUA(userAgent: string) {\n  return HTML_LIMITED_BOT_UA_RE.test(userAgent)\n}\n\nexport function isBot(userAgent: string): boolean {\n  return isDomBotUA(userAgent) || isHtmlLimitedBotUA(userAgent)\n}\n\nexport function getBotType(userAgent: string): 'dom' | 'html' | undefined {\n  if (isDomBotUA(userAgent)) {\n    return 'dom'\n  }\n  if (isHtmlLimitedBotUA(userAgent)) {\n    return 'html'\n  }\n  return undefined\n}\n"],"names":["HTML_LIMITED_BOT_UA_RE","HTML_LIMITED_BOT_UA_RE_STRING","getBotType","isBot","HEADLESS_BROWSER_BOT_UA_RE","source","isDomBotUA","userAgent","test","isHtmlLimitedBotUA","undefined"],"mappings":";;;;;;;;;;;;;;;;IAUSA,sBAAsB,EAAA;eAAtBA,UAAAA,sBAAsB;;IAFlBC,6BAA6B,EAAA;eAA7BA;;IAgBGC,UAAU,EAAA;eAAVA;;IAJAC,KAAK,EAAA;eAALA;;;0BApBuB;AAEvC,mEAAmE;AACnE,yFAAyF;AACzF,4FAA4F;AAC5F,oGAAoG;AACpG,MAAMC,6BAA6B;AAE5B,MAAMH,gCAAgCD,UAAAA,sBAAsB,CAACK,MAAM;AAI1E,SAASC,WAAWC,SAAiB;IACnC,OAAOH,2BAA2BI,IAAI,CAACD;AACzC;AAEA,SAASE,mBAAmBF,SAAiB;IAC3C,OAAOP,UAAAA,sBAAsB,CAACQ,IAAI,CAACD;AACrC;AAEO,SAASJ,MAAMI,SAAiB;IACrC,OAAOD,WAAWC,cAAcE,mBAAmBF;AACrD;AAEO,SAASL,WAAWK,SAAiB;IAC1C,IAAID,WAAWC,YAAY;QACzB,OAAO;IACT;IACA,IAAIE,mBAAmBF,YAAY;QACjC,OAAO;IACT;IACA,OAAOG;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2253, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/error-boundary.tsx"],"sourcesContent":["'use client'\n\nimport React, { type JSX } from 'react'\nimport { useUntrackedPathname } from './navigation-untracked'\nimport { isNextRouterError } from './is-next-router-error'\nimport { handleHardNavError } from './nav-failure-handler'\nimport { HandleISRError } from './handle-isr-error'\nimport { isBot } from '../../shared/lib/router/utils/is-bot'\n\nconst isBotUserAgent =\n  typeof window !== 'undefined' && isBot(window.navigator.userAgent)\n\nexport type ErrorComponent = React.ComponentType<{\n  error: Error\n  // global-error, there's no `reset` function;\n  // regular error boundary, there's a `reset` function.\n  reset?: () => void\n}>\n\nexport interface ErrorBoundaryProps {\n  children?: React.ReactNode\n  errorComponent: ErrorComponent | undefined\n  errorStyles?: React.ReactNode | undefined\n  errorScripts?: React.ReactNode | undefined\n}\n\ninterface ErrorBoundaryHandlerProps extends ErrorBoundaryProps {\n  pathname: string | null\n  errorComponent: ErrorComponent\n}\n\ninterface ErrorBoundaryHandlerState {\n  error: Error | null\n  previousPathname: string | null\n}\n\nexport class ErrorBoundaryHandler extends React.Component<\n  ErrorBoundaryHandlerProps,\n  ErrorBoundaryHandlerState\n> {\n  constructor(props: ErrorBoundaryHandlerProps) {\n    super(props)\n    this.state = { error: null, previousPathname: this.props.pathname }\n  }\n\n  static getDerivedStateFromError(error: Error) {\n    if (isNextRouterError(error)) {\n      // Re-throw if an expected internal Next.js router error occurs\n      // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)\n      throw error\n    }\n\n    return { error }\n  }\n\n  static getDerivedStateFromProps(\n    props: ErrorBoundaryHandlerProps,\n    state: ErrorBoundaryHandlerState\n  ): ErrorBoundaryHandlerState | null {\n    const { error } = state\n\n    // if we encounter an error while\n    // a navigation is pending we shouldn't render\n    // the error boundary and instead should fallback\n    // to a hard navigation to attempt recovering\n    if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n      if (error && handleHardNavError(error)) {\n        // clear error so we don't render anything\n        return {\n          error: null,\n          previousPathname: props.pathname,\n        }\n      }\n    }\n\n    /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */\n    if (props.pathname !== state.previousPathname && state.error) {\n      return {\n        error: null,\n        previousPathname: props.pathname,\n      }\n    }\n    return {\n      error: state.error,\n      previousPathname: props.pathname,\n    }\n  }\n\n  reset = () => {\n    this.setState({ error: null })\n  }\n\n  // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\n  render(): React.ReactNode {\n    //When it's bot request, segment level error boundary will keep rendering the children,\n    // the final error will be caught by the root error boundary and determine wether need to apply graceful degrade.\n    if (this.state.error && !isBotUserAgent) {\n      return (\n        <>\n          <HandleISRError error={this.state.error} />\n          {this.props.errorStyles}\n          {this.props.errorScripts}\n          <this.props.errorComponent\n            error={this.state.error}\n            reset={this.reset}\n          />\n        </>\n      )\n    }\n\n    return this.props.children\n  }\n}\n\n/**\n * Handles errors through `getDerivedStateFromError`.\n * Renders the provided error component and provides a way to `reset` the error boundary state.\n */\n\n/**\n * Renders error boundary with the provided \"errorComponent\" property as the fallback.\n * If no \"errorComponent\" property is provided it renders the children without an error boundary.\n */\nexport function ErrorBoundary({\n  errorComponent,\n  errorStyles,\n  errorScripts,\n  children,\n}: ErrorBoundaryProps & {\n  children: React.ReactNode\n}): JSX.Element {\n  // When we're rendering the missing params shell, this will return null. This\n  // is because we won't be rendering any not found boundaries or error\n  // boundaries for the missing params shell. When this runs on the client\n  // (where these errors can occur), we will get the correct pathname.\n  const pathname = useUntrackedPathname()\n  if (errorComponent) {\n    return (\n      <ErrorBoundaryHandler\n        pathname={pathname}\n        errorComponent={errorComponent}\n        errorStyles={errorStyles}\n        errorScripts={errorScripts}\n      >\n        {children}\n      </ErrorBoundaryHandler>\n    )\n  }\n\n  return <>{children}</>\n}\n"],"names":["ErrorBoundary","ErrorBoundaryHandler","isBotUserAgent","window","isBot","navigator","userAgent","React","Component","getDerivedStateFromError","error","isNextRouterError","getDerivedStateFromProps","props","state","process","env","__NEXT_APP_NAV_FAIL_HANDLING","handleHardNavError","previousPathname","pathname","render","HandleISRError","errorStyles","errorScripts","this","errorComponent","reset","children","constructor","setState","useUntrackedPathname"],"mappings":"AAiEQe,QAAQC,GAAG,CAACC,4BAA4B,EAAE;AAjElD;;;;;;;;;;;;;;;;IAgIgBjB,aAAa,EAAA;eAAbA;;IA5FHC,oBAAoB,EAAA;eAApBA;;;;;gEAlCmB;qCACK;mCACH;mCACC;gCACJ;uBACT;AAEtB,MAAMC,iBACJ,OAAOC,WAAW,eAAeC,CAAAA,GAAAA,OAAAA,KAAK,EAACD,OAAOE,SAAS,CAACC,SAAS;AA0B5D,MAAML,6BAA6BM,OAAAA,OAAK,CAACC,SAAS;IASvD,OAAOC,yBAAyBC,KAAY,EAAE;QAC5C,IAAIC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACD,QAAQ;YAC5B,+DAA+D;YAC/D,4GAA4G;YAC5G,MAAMA;QACR;QAEA,OAAO;YAAEA;QAAM;IACjB;IAEA,OAAOE,yBACLC,KAAgC,EAChCC,KAAgC,EACE;QAClC,MAAM,EAAEJ,KAAK,EAAE,GAAGI;QAElB,iCAAiC;QACjC,8CAA8C;QAC9C,iDAAiD;QACjD,6CAA6C;QAC7C;;QAUA;;;;;KAKC,GACD,IAAID,MAAMO,QAAQ,KAAKN,MAAMK,gBAAgB,IAAIL,MAAMJ,KAAK,EAAE;YAC5D,OAAO;gBACLA,OAAO;gBACPS,kBAAkBN,MAAMO,QAAQ;YAClC;QACF;QACA,OAAO;YACLV,OAAOI,MAAMJ,KAAK;YAClBS,kBAAkBN,MAAMO,QAAQ;QAClC;IACF;IAMA,yIAAyI;IACzIC,SAA0B;QACxB,uFAAuF;QACvF,iHAAiH;QACjH,IAAI,IAAI,CAACP,KAAK,CAACJ,KAAK,IAAI,CAACR,gBAAgB;YACvC,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,IAAA,EAAA,YAAA,QAAA,EAAA;;kCACE,CAAA,GAAA,YAAA,GAAA,EAACoB,gBAAAA,cAAc,EAAA;wBAACZ,OAAO,IAAI,CAACI,KAAK,CAACJ,KAAK;;oBACtC,IAAI,CAACG,KAAK,CAACU,WAAW;oBACtB,IAAI,CAACV,KAAK,CAACW,YAAY;kCACxB,CAAA,GAAA,YAAA,GAAA,EAACC,IAAI,CAACZ,KAAK,CAACa,cAAc,EAAA;wBACxBhB,OAAO,IAAI,CAACI,KAAK,CAACJ,KAAK;wBACvBiB,OAAO,IAAI,CAACA,KAAK;;;;QAIzB;QAEA,OAAO,IAAI,CAACd,KAAK,CAACe,QAAQ;IAC5B;IA5EAC,YAAYhB,KAAgC,CAAE;QAC5C,KAAK,CAACA,QAAAA,IAAAA,CAoDRc,KAAAA,GAAQ;YACN,IAAI,CAACG,QAAQ,CAAC;gBAAEpB,OAAO;YAAK;QAC9B;QArDE,IAAI,CAACI,KAAK,GAAG;YAAEJ,OAAO;YAAMS,kBAAkB,IAAI,CAACN,KAAK,CAACO,QAAQ;QAAC;IACpE;AA0EF;AAWO,SAASpB,cAAc,KAO7B;IAP6B,IAAA,EAC5B0B,cAAc,EACdH,WAAW,EACXC,YAAY,EACZI,QAAQ,EAGT,GAP6B;IAQ5B,6EAA6E;IAC7E,qEAAqE;IACrE,wEAAwE;IACxE,oEAAoE;IACpE,MAAMR,WAAWW,CAAAA,GAAAA,qBAAAA,oBAAoB;IACrC,IAAIL,gBAAgB;QAClB,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACzB,sBAAAA;YACCmB,UAAUA;YACVM,gBAAgBA;YAChBH,aAAaA;YACbC,cAAcA;sBAEbI;;IAGP;IAEA,OAAA,WAAA,GAAO,CAAA,GAAA,YAAA,GAAA,EAAA,YAAA,QAAA,EAAA;kBAAGA;;AACZ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2385, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/match-segments.ts"],"sourcesContent":["import type { Segment } from '../../server/app-render/types'\n\nexport const matchSegment = (\n  existingSegment: Segment,\n  segment: Segment\n): boolean => {\n  // segment is either Array or string\n  if (typeof existingSegment === 'string') {\n    if (typeof segment === 'string') {\n      // Common case: segment is just a string\n      return existingSegment === segment\n    }\n    return false\n  }\n\n  if (typeof segment === 'string') {\n    return false\n  }\n  return existingSegment[0] === segment[0] && existingSegment[1] === segment[1]\n}\n"],"names":["matchSegment","existingSegment","segment"],"mappings":";;;+BAEaA,gBAAAA;;;eAAAA;;;AAAN,MAAMA,eAAe,CAC1BC,iBACAC;IAEA,oCAAoC;IACpC,IAAI,OAAOD,oBAAoB,UAAU;QACvC,IAAI,OAAOC,YAAY,UAAU;YAC/B,wCAAwC;YACxC,OAAOD,oBAAoBC;QAC7B;QACA,OAAO;IACT;IAEA,IAAI,OAAOA,YAAY,UAAU;QAC/B,OAAO;IACT;IACA,OAAOD,eAAe,CAAC,EAAE,KAAKC,OAAO,CAAC,EAAE,IAAID,eAAe,CAAC,EAAE,KAAKC,OAAO,CAAC,EAAE;AAC/E","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2419, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/shared/lib/utils/warn-once.ts"],"sourcesContent":["let warnOnce = (_: string) => {}\nif (process.env.NODE_ENV !== 'production') {\n  const warnings = new Set<string>()\n  warnOnce = (msg: string) => {\n    if (!warnings.has(msg)) {\n      console.warn(msg)\n    }\n    warnings.add(msg)\n  }\n}\n\nexport { warnOnce }\n"],"names":["warnOnce","_","process","env","NODE_ENV","warnings","Set","msg","has","console","warn","add"],"mappings":"AACIE,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;+BAUpBJ,YAAAA;;;eAAAA;;;AAXT,IAAIA,WAAW,CAACC,KAAe;AAC/B,wCAA2C;IACzC,MAAMI,WAAW,IAAIC;IACrBN,WAAW,CAACO;QACV,IAAI,CAACF,SAASG,GAAG,CAACD,MAAM;YACtBE,QAAQC,IAAI,CAACH;QACf;QACAF,SAASM,GAAG,CAACJ;IACf;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2444, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/shared/lib/router/utils/disable-smooth-scroll.ts"],"sourcesContent":["import { warnOnce } from '../../utils/warn-once'\n\n/**\n * Run function with `scroll-behavior: auto` applied to `<html/>`.\n * This css change will be reverted after the function finishes.\n */\nexport function disableSmoothScrollDuringRouteTransition(\n  fn: () => void,\n  options: { dontForceLayout?: boolean; onlyHashChange?: boolean } = {}\n) {\n  // if only the hash is changed, we don't need to disable smooth scrolling\n  // we only care to prevent smooth scrolling when navigating to a new page to avoid jarring UX\n  if (options.onlyHashChange) {\n    fn()\n    return\n  }\n\n  const htmlElement = document.documentElement\n  const hasDataAttribute = htmlElement.dataset.scrollBehavior === 'smooth'\n\n  // Since this is a breaking change, this is temporarily flagged\n  // and will be false by default.\n  // In the next major (v16), this will be automatically enabled\n  if (process.env.__NEXT_OPTIMIZE_ROUTER_SCROLL) {\n    if (!hasDataAttribute) {\n      // No smooth scrolling configured, run directly without style manipulation\n      fn()\n      return\n    }\n  } else {\n    // Old behavior: always manipulate styles, but warn about upcoming change\n\n    // Warn if smooth scrolling is detected but no data attribute is present\n    if (\n      process.env.NODE_ENV === 'development' &&\n      !hasDataAttribute &&\n      getComputedStyle(htmlElement).scrollBehavior === 'smooth'\n    ) {\n      warnOnce(\n        'Detected `scroll-behavior: smooth` on the `<html>` element. In a future version, ' +\n          'Next.js will no longer automatically disable smooth scrolling during route transitions. ' +\n          'To prepare for this change, add `data-scroll-behavior=\"smooth\"` to your <html> element. ' +\n          'Learn more: https://nextjs.org/docs/messages/missing-data-scroll-behavior'\n      )\n    }\n  }\n\n  // Proceed with temporarily disabling smooth scrolling\n  const existing = htmlElement.style.scrollBehavior\n  htmlElement.style.scrollBehavior = 'auto'\n  if (!options.dontForceLayout) {\n    // In Chrome-based browsers we need to force reflow before calling `scrollTo`.\n    // Otherwise it will not pickup the change in scrollBehavior\n    // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042\n    htmlElement.getClientRects()\n  }\n  fn()\n  htmlElement.style.scrollBehavior = existing\n}\n"],"names":["disableSmoothScrollDuringRouteTransition","fn","options","onlyHashChange","htmlElement","document","documentElement","hasDataAttribute","dataset","scrollBehavior","process","env","__NEXT_OPTIMIZE_ROUTER_SCROLL","NODE_ENV","getComputedStyle","warnOnce","existing","style","dontForceLayout","getClientRects"],"mappings":"AAuBMU,QAAQC,GAAG,CAACC,6BAA6B,EAAE;;;;;+BAjBjCZ,4CAAAA;;;eAAAA;;;0BANS;AAMlB,SAASA,yCACdC,EAAc,EACdC,OAAqE;IAArEA,IAAAA,YAAAA,KAAAA,GAAAA,UAAmE,CAAC;IAEpE,yEAAyE;IACzE,6FAA6F;IAC7F,IAAIA,QAAQC,cAAc,EAAE;QAC1BF;QACA;IACF;IAEA,MAAMG,cAAcC,SAASC,eAAe;IAC5C,MAAMC,mBAAmBH,YAAYI,OAAO,CAACC,cAAc,KAAK;IAEhE,+DAA+D;IAC/D,gCAAgC;IAChC,8DAA8D;IAC9D;;SAMO;QACL,yEAAyE;QAEzE,wEAAwE;QACxE,IACEC,QAAQC,GAAG,CAACE,QAAQ,gCAAK,iBACzB,CAACN,oBACDO,iBAAiBV,aAAaK,cAAc,KAAK,UACjD;YACAM,CAAAA,GAAAA,UAAAA,QAAQ,EACN,sFACE,6FACA,6FACA;QAEN;IACF;IAEA,sDAAsD;IACtD,MAAMC,WAAWZ,YAAYa,KAAK,CAACR,cAAc;IACjDL,YAAYa,KAAK,CAACR,cAAc,GAAG;IACnC,IAAI,CAACP,QAAQgB,eAAe,EAAE;QAC5B,8EAA8E;QAC9E,4DAA4D;QAC5D,yFAAyF;QACzFd,YAAYe,cAAc;IAC5B;IACAlB;IACAG,YAAYa,KAAK,CAACR,cAAc,GAAGO;AACrC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2494, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/router-reducer/reducers/get-segment-value.ts"],"sourcesContent":["import type { Segment } from '../../../../server/app-render/types'\n\nexport function getSegmentValue(segment: Segment) {\n  return Array.isArray(segment) ? segment[1] : segment\n}\n"],"names":["getSegmentValue","segment","Array","isArray"],"mappings":";;;+BAEgBA,mBAAAA;;;eAAAA;;;AAAT,SAASA,gBAAgBC,OAAgB;IAC9C,OAAOC,MAAMC,OAAO,CAACF,WAAWA,OAAO,CAAC,EAAE,GAAGA;AAC/C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2517, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/server/app-render/action-async-storage-instance.ts"],"sourcesContent":["import type { ActionAsyncStorage } from './action-async-storage.external'\nimport { createAsyncLocalStorage } from './async-local-storage'\n\nexport const actionAsyncStorageInstance: ActionAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["actionAsyncStorageInstance","createAsyncLocalStorage"],"mappings":";;;+BAGaA,8BAAAA;;;eAAAA;;;mCAF2B;AAEjC,MAAMA,6BACXC,CAAAA,GAAAA,mBAAAA,uBAAuB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2532, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/server/app-render/action-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\n\n// Share the instance module in the next-shared layer\nimport { actionAsyncStorageInstance } from './action-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nexport interface ActionStore {\n  readonly isAction?: boolean\n  readonly isAppRoute?: boolean\n}\n\nexport type ActionAsyncStorage = AsyncLocalStorage<ActionStore>\n\nexport { actionAsyncStorageInstance as actionAsyncStorage }\n"],"names":["actionAsyncStorage","actionAsyncStorageInstance"],"mappings":";;;+BAWuCA,sBAAAA;;;eAA9BC,4BAAAA,0BAA0B;;;4CARQ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2546, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/redirect.ts"],"sourcesContent":["import { RedirectStatusCode } from './redirect-status-code'\nimport {\n  RedirectType,\n  type RedirectError,\n  isRedirectError,\n  REDIRECT_ERROR_CODE,\n} from './redirect-error'\n\nconst actionAsyncStorage =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/action-async-storage.external') as typeof import('../../server/app-render/action-async-storage.external')\n      ).actionAsyncStorage\n    : undefined\n\nexport function getRedirectError(\n  url: string,\n  type: RedirectType,\n  statusCode: RedirectStatusCode = RedirectStatusCode.TemporaryRedirect\n): RedirectError {\n  const error = new Error(REDIRECT_ERROR_CODE) as RedirectError\n  error.digest = `${REDIRECT_ERROR_CODE};${type};${url};${statusCode};`\n  return error\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 307/303 to the caller.\n * - In a Server Action, type defaults to 'push' and 'replace' elsewhere.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function redirect(\n  /** The URL to redirect to */\n  url: string,\n  type?: RedirectType\n): never {\n  type ??= actionAsyncStorage?.getStore()?.isAction\n    ? RedirectType.push\n    : RedirectType.replace\n\n  throw getRedirectError(url, type, RedirectStatusCode.TemporaryRedirect)\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 308/303 to the caller.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function permanentRedirect(\n  /** The URL to redirect to */\n  url: string,\n  type: RedirectType = RedirectType.replace\n): never {\n  throw getRedirectError(url, type, RedirectStatusCode.PermanentRedirect)\n}\n\n/**\n * Returns the encoded URL from the error if it's a RedirectError, null\n * otherwise. Note that this does not validate the URL returned.\n *\n * @param error the error that may be a redirect error\n * @return the url if the error was a redirect error\n */\nexport function getURLFromRedirectError(error: RedirectError): string\nexport function getURLFromRedirectError(error: unknown): string | null {\n  if (!isRedirectError(error)) return null\n\n  // Slices off the beginning of the digest that contains the code and the\n  // separating ';'.\n  return error.digest.split(';').slice(2, -2).join(';')\n}\n\nexport function getRedirectTypeFromError(error: RedirectError): RedirectType {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return error.digest.split(';', 2)[1] as RedirectType\n}\n\nexport function getRedirectStatusCodeFromError(error: RedirectError): number {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return Number(error.digest.split(';').at(-2))\n}\n"],"names":["getRedirectError","getRedirectStatusCodeFromError","getRedirectTypeFromError","getURLFromRedirectError","permanentRedirect","redirect","actionAsyncStorage","window","require","undefined","url","type","statusCode","RedirectStatusCode","TemporaryRedirect","error","Error","REDIRECT_ERROR_CODE","digest","getStore","isAction","RedirectType","push","replace","PermanentRedirect","isRedirectError","split","slice","join","Number","at"],"mappings":";;;;;;;;;;;;;;;;;;IAegBA,gBAAgB,EAAA;eAAhBA;;IA6EAC,8BAA8B,EAAA;eAA9BA;;IARAC,wBAAwB,EAAA;eAAxBA;;IARAC,uBAAuB,EAAA;eAAvBA;;IAhBAC,iBAAiB,EAAA;eAAjBA;;IAvBAC,QAAQ,EAAA;eAARA;;;oCArCmB;+BAM5B;AAEP,MAAMC,qBACJ,OAAOC,WAAW,cAEZC,QAAQ,2KACRF,kBAAkB,GACpBG;AAEC,SAAST,iBACdU,GAAW,EACXC,IAAkB,EAClBC,UAAqE;IAArEA,IAAAA,eAAAA,KAAAA,GAAAA,aAAiCC,oBAAAA,kBAAkB,CAACC,iBAAiB;IAErE,MAAMC,QAAQ,OAAA,cAA8B,CAA9B,IAAIC,MAAMC,eAAAA,mBAAmB,GAA7B,qBAAA;eAAA;oBAAA;sBAAA;IAA6B;IAC3CF,MAAMG,MAAM,GAAMD,eAAAA,mBAAmB,GAAC,MAAGN,OAAK,MAAGD,MAAI,MAAGE,aAAW;IACnE,OAAOG;AACT;AAcO,SAASV,SACd,2BAA2B,GAC3BK,GAAW,EACXC,IAAmB;QAEVL;IAATK,QAAAA,OAAAA,OAAAA,OAASL,CAAAA,sBAAAA,OAAAA,KAAAA,IAAAA,CAAAA,+BAAAA,mBAAoBa,QAAQ,EAAA,KAAA,OAAA,KAAA,IAA5Bb,6BAAgCc,QAAQ,IAC7CC,eAAAA,YAAY,CAACC,IAAI,GACjBD,eAAAA,YAAY,CAACE,OAAO;IAExB,MAAMvB,iBAAiBU,KAAKC,MAAME,oBAAAA,kBAAkB,CAACC,iBAAiB;AACxE;AAaO,SAASV,kBACd,2BAA2B,GAC3BM,GAAW,EACXC,IAAyC;IAAzCA,IAAAA,SAAAA,KAAAA,GAAAA,OAAqBU,eAAAA,YAAY,CAACE,OAAO;IAEzC,MAAMvB,iBAAiBU,KAAKC,MAAME,oBAAAA,kBAAkB,CAACW,iBAAiB;AACxE;AAUO,SAASrB,wBAAwBY,KAAc;IACpD,IAAI,CAACU,CAAAA,GAAAA,eAAAA,eAAe,EAACV,QAAQ,OAAO;IAEpC,wEAAwE;IACxE,kBAAkB;IAClB,OAAOA,MAAMG,MAAM,CAACQ,KAAK,CAAC,KAAKC,KAAK,CAAC,GAAG,CAAC,GAAGC,IAAI,CAAC;AACnD;AAEO,SAAS1B,yBAAyBa,KAAoB;IAC3D,IAAI,CAACU,CAAAA,GAAAA,eAAAA,eAAe,EAACV,QAAQ;QAC3B,MAAM,OAAA,cAAiC,CAAjC,IAAIC,MAAM,yBAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAgC;IACxC;IAEA,OAAOD,MAAMG,MAAM,CAACQ,KAAK,CAAC,KAAK,EAAE,CAAC,EAAE;AACtC;AAEO,SAASzB,+BAA+Bc,KAAoB;IACjE,IAAI,CAACU,CAAAA,GAAAA,eAAAA,eAAe,EAACV,QAAQ;QAC3B,MAAM,OAAA,cAAiC,CAAjC,IAAIC,MAAM,yBAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAgC;IACxC;IAEA,OAAOa,OAAOd,MAAMG,MAAM,CAACQ,KAAK,CAAC,KAAKI,EAAE,CAAC,CAAC;AAC5C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2642, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/not-found.ts"],"sourcesContent":["import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n/**\n * This function allows you to render the [not-found.js file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)\n * within a route segment as well as inject a tag.\n *\n * `notFound()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a `<meta name=\"robots\" content=\"noindex\" />` meta tag and set the status code to 404.\n * - In a Route Handler or Server Action, it will serve a 404 to the caller.\n *\n * Read more: [Next.js Docs: `notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};404`\n\nexport function notFound(): never {\n  // eslint-disable-next-line no-throw-literal\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n\n  throw error\n}\n"],"names":["notFound","DIGEST","HTTP_ERROR_FALLBACK_ERROR_CODE","error","Error","digest"],"mappings":";;;+BAsBgBA,YAAAA;;;eAAAA;;;oCAnBT;AAEP;;;;;;;;;;;;;CAaC,GAED,MAAMC,SAAU,KAAEC,oBAAAA,8BAA8B,GAAC;AAE1C,SAASF;IACd,4CAA4C;IAC5C,MAAMG,QAAQ,OAAA,cAAiB,CAAjB,IAAIC,MAAMH,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BE,MAAkCE,MAAM,GAAGJ;IAE7C,MAAME;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2687, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/forbidden.ts"],"sourcesContent":["import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `forbidden` docs\n/**\n * @experimental\n * This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)\n * within a route segment as well as inject a tag.\n *\n * `forbidden()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};403`\n\nexport function forbidden(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`forbidden()\\` is experimental and only allowed to be enabled when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  // eslint-disable-next-line no-throw-literal\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n"],"names":["forbidden","DIGEST","HTTP_ERROR_FALLBACK_ERROR_CODE","process","env","__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS","Error","error","digest"],"mappings":"AAsBOG,QAAQC,GAAG,CAACC,mCAAmC;;;;;+BADtCL,aAAAA;;;eAAAA;;;oCAlBT;AAEP,6BAA6B;AAC7B;;;;;;;;;;;CAWC,GAED,MAAMC,SAAU,KAAEC,oBAAAA,8BAA8B,GAAC;AAE1C,SAASF;IACd,IAAI,oCAAkD;QACpD,MAAM,OAAA,cAEL,CAFK,IAAIM,MACP,gHADG,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,4CAA4C;IAC5C,MAAMC,QAAQ,OAAA,cAAiB,CAAjB,IAAID,MAAML,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BM,MAAkCC,MAAM,GAAGP;IAC7C,MAAMM;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2740, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/unauthorized.ts"],"sourcesContent":["import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `unauthorized` docs\n/**\n * @experimental\n * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)\n * within a route segment as well as inject a tag.\n *\n * `unauthorized()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n *\n * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};401`\n\nexport function unauthorized(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`unauthorized()\\` is experimental and only allowed to be used when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  // eslint-disable-next-line no-throw-literal\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n"],"names":["unauthorized","DIGEST","HTTP_ERROR_FALLBACK_ERROR_CODE","process","env","__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS","Error","error","digest"],"mappings":"AAuBOG,QAAQC,GAAG,CAACC,mCAAmC;;;;;+BADtCL,gBAAAA;;;eAAAA;;;oCAnBT;AAEP,gCAAgC;AAChC;;;;;;;;;;;;CAYC,GAED,MAAMC,SAAU,KAAEC,oBAAAA,8BAA8B,GAAC;AAE1C,SAASF;IACd,IAAI,oCAAkD;QACpD,MAAM,OAAA,cAEL,CAFK,IAAIM,MACP,gHADG,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,4CAA4C;IAC5C,MAAMC,QAAQ,OAAA,cAAiB,CAAjB,IAAID,MAAML,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BM,MAAkCC,MAAM,GAAGP;IAC7C,MAAMM;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2794, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/shared/lib/lazy-dynamic/bailout-to-csr.ts"],"sourcesContent":["// This has to be a shared module which is shared between client component error boundary and dynamic component\nconst BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING'\n\n/** An error that should be thrown when we want to bail out to client-side rendering. */\nexport class BailoutToCSRError extends Error {\n  public readonly digest = BAILOUT_TO_CSR\n\n  constructor(public readonly reason: string) {\n    super(`Bail out to client-side rendering: ${reason}`)\n  }\n}\n\n/** Checks if a passed argument is an error that is thrown if we want to bail out to client-side rendering. */\nexport function isBailoutToCSRError(err: unknown): err is BailoutToCSRError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === BAILOUT_TO_CSR\n}\n"],"names":["BailoutToCSRError","isBailoutToCSRError","BAILOUT_TO_CSR","Error","constructor","reason","digest","err"],"mappings":"AAAA,+GAA+G;;;;;;;;;;;;;;;IAIlGA,iBAAiB,EAAA;eAAjBA;;IASGC,mBAAmB,EAAA;eAAnBA;;;AAZhB,MAAMC,iBAAiB;AAGhB,MAAMF,0BAA0BG;IAGrCC,YAA4BC,MAAc,CAAE;QAC1C,KAAK,CAAE,wCAAqCA,SAAAA,IAAAA,CADlBA,MAAAA,GAAAA,QAAAA,IAAAA,CAFZC,MAAAA,GAASJ;IAIzB;AACF;AAGO,SAASD,oBAAoBM,GAAY;IAC9C,IAAI,OAAOA,QAAQ,YAAYA,QAAQ,QAAQ,CAAE,CAAA,YAAYA,GAAE,GAAI;QACjE,OAAO;IACT;IAEA,OAAOA,IAAID,MAAM,KAAKJ;AACxB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2832, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/unstable-rethrow.browser.ts"],"sourcesContent":["import { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isNextRouterError } from './is-next-router-error'\n\nexport function unstable_rethrow(error: unknown): void {\n  if (isNextRouterError(error) || isBailoutToCSRError(error)) {\n    throw error\n  }\n\n  if (error instanceof Error && 'cause' in error) {\n    unstable_rethrow(error.cause)\n  }\n}\n"],"names":["unstable_rethrow","error","isNextRouterError","isBailoutToCSRError","Error","cause"],"mappings":";;;+BAGgBA,oBAAAA;;;eAAAA;;;8BAHoB;mCACF;AAE3B,SAASA,iBAAiBC,KAAc;IAC7C,IAAIC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACD,UAAUE,CAAAA,GAAAA,cAAAA,mBAAmB,EAACF,QAAQ;QAC1D,MAAMA;IACR;IAEA,IAAIA,iBAAiBG,SAAS,WAAWH,OAAO;QAC9CD,iBAAiBC,MAAMI,KAAK;IAC9B;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2862, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/server/dynamic-rendering-utils.ts"],"sourcesContent":["export function isHangingPromiseRejectionError(\n  err: unknown\n): err is HangingPromiseRejectionError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === HANGING_PROMISE_REJECTION\n}\n\nconst HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION'\n\nclass HangingPromiseRejectionError extends Error {\n  public readonly digest = HANGING_PROMISE_REJECTION\n\n  constructor(\n    public readonly route: string,\n    public readonly expression: string\n  ) {\n    super(\n      `During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`after\\`, or similar functions you may observe this error and you should handle it in that context. This occurred at route \"${route}\".`\n    )\n  }\n}\n\ntype AbortListeners = Array<(err: unknown) => void>\nconst abortListenersBySignal = new WeakMap<AbortSignal, AbortListeners>()\n\n/**\n * This function constructs a promise that will never resolve. This is primarily\n * useful for cacheComponents where we use promise resolution timing to determine which\n * parts of a render can be included in a prerender.\n *\n * @internal\n */\nexport function makeHangingPromise<T>(\n  signal: AbortSignal,\n  route: string,\n  expression: string\n): Promise<T> {\n  if (signal.aborted) {\n    return Promise.reject(new HangingPromiseRejectionError(route, expression))\n  } else {\n    const hangingPromise = new Promise<T>((_, reject) => {\n      const boundRejection = reject.bind(\n        null,\n        new HangingPromiseRejectionError(route, expression)\n      )\n      let currentListeners = abortListenersBySignal.get(signal)\n      if (currentListeners) {\n        currentListeners.push(boundRejection)\n      } else {\n        const listeners = [boundRejection]\n        abortListenersBySignal.set(signal, listeners)\n        signal.addEventListener(\n          'abort',\n          () => {\n            for (let i = 0; i < listeners.length; i++) {\n              listeners[i]()\n            }\n          },\n          { once: true }\n        )\n      }\n    })\n    // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n    // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n    // your own promise out of it you'll need to ensure you handle the error when it rejects.\n    hangingPromise.catch(ignoreReject)\n    return hangingPromise\n  }\n}\n\nfunction ignoreReject() {}\n\nexport function makeDevtoolsIOAwarePromise<T>(underlying: T): Promise<T> {\n  // in React DevTools if we resolve in a setTimeout we will observe\n  // the promise resolution as something that can suspend a boundary or root.\n  return new Promise<T>((resolve) => {\n    // Must use setTimeout to be considered IO React DevTools. setImmediate will not work.\n    setTimeout(() => {\n      resolve(underlying)\n    }, 0)\n  })\n}\n"],"names":["isHangingPromiseRejectionError","makeDevtoolsIOAwarePromise","makeHangingPromise","err","digest","HANGING_PROMISE_REJECTION","HangingPromiseRejectionError","Error","constructor","route","expression","abortListenersBySignal","WeakMap","signal","aborted","Promise","reject","hangingPromise","_","boundRejection","bind","currentListeners","get","push","listeners","set","addEventListener","i","length","once","catch","ignoreReject","underlying","resolve","setTimeout"],"mappings":";;;;;;;;;;;;;;;IAAgBA,8BAA8B,EAAA;eAA9BA;;IA2EAC,0BAA0B,EAAA;eAA1BA;;IAxCAC,kBAAkB,EAAA;eAAlBA;;;AAnCT,SAASF,+BACdG,GAAY;IAEZ,IAAI,OAAOA,QAAQ,YAAYA,QAAQ,QAAQ,CAAE,CAAA,YAAYA,GAAE,GAAI;QACjE,OAAO;IACT;IAEA,OAAOA,IAAIC,MAAM,KAAKC;AACxB;AAEA,MAAMA,4BAA4B;AAElC,MAAMC,qCAAqCC;IAGzCC,YACkBC,KAAa,EACbC,UAAkB,CAClC;QACA,KAAK,CACH,AAAC,qBAAqB,UAAEA,YAAW,qGAAqG,WAAEA,YAAW,8KAA8K,OAAED,OAAM,EAAE,CAAC,KAAA,IAAA,CAJhUA,KAAAA,GAAAA,OAAAA,IAAAA,CACAC,UAAAA,GAAAA,YAAAA,IAAAA,CAJFN,MAAAA,GAASC;IASzB;AACF;AAGA,MAAMM,yBAAyB,IAAIC;AAS5B,SAASV,mBACdW,MAAmB,EACnBJ,KAAa,EACbC,UAAkB;IAElB,IAAIG,OAAOC,OAAO,EAAE;QAClB,OAAOC,QAAQC,MAAM,CAAC,IAAIV,6BAA6BG,OAAOC;IAChE,OAAO;QACL,MAAMO,iBAAiB,IAAIF,QAAW,CAACG,GAAGF;YACxC,MAAMG,iBAAiBH,OAAOI,IAAI,CAChC,MACA,IAAId,6BAA6BG,OAAOC;YAE1C,IAAIW,mBAAmBV,uBAAuBW,GAAG,CAACT;YAClD,IAAIQ,kBAAkB;gBACpBA,iBAAiBE,IAAI,CAACJ;YACxB,OAAO;gBACL,MAAMK,YAAY;oBAACL;iBAAe;gBAClCR,uBAAuBc,GAAG,CAACZ,QAAQW;gBACnCX,OAAOa,gBAAgB,CACrB,SACA;oBACE,IAAK,IAAIC,IAAI,GAAGA,IAAIH,UAAUI,MAAM,EAAED,IAAK;wBACzCH,SAAS,CAACG,EAAE;oBACd;gBACF,GACA;oBAAEE,MAAM;gBAAK;YAEjB;QACF;QACA,2GAA2G;QAC3G,6GAA6G;QAC7G,yFAAyF;QACzFZ,eAAea,KAAK,CAACC;QACrB,OAAOd;IACT;AACF;AAEA,SAASc,gBAAgB;AAElB,SAAS9B,2BAA8B+B,UAAa;IACzD,kEAAkE;IAClE,2EAA2E;IAC3E,OAAO,IAAIjB,QAAW,CAACkB;QACrB,sFAAsF;QACtFC,WAAW;YACTD,QAAQD;QACV,GAAG;IACL;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2945, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/server/lib/router-utils/is-postpone.ts"],"sourcesContent":["const REACT_POSTPONE_TYPE: symbol = Symbol.for('react.postpone')\n\nexport function isPostpone(error: any): boolean {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    error.$$typeof === REACT_POSTPONE_TYPE\n  )\n}\n"],"names":["isPostpone","REACT_POSTPONE_TYPE","Symbol","for","error","$$typeof"],"mappings":";;;+BAEgBA,cAAAA;;;eAAAA;;;AAFhB,MAAMC,sBAA8BC,OAAOC,GAAG,CAAC;AAExC,SAASH,WAAWI,KAAU;IACnC,OACE,OAAOA,UAAU,YACjBA,UAAU,QACVA,MAAMC,QAAQ,KAAKJ;AAEvB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2962, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/hooks-server-context.ts"],"sourcesContent":["const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE'\n\nexport class DynamicServerError extends Error {\n  digest: typeof DYNAMIC_ERROR_CODE = DYNAMIC_ERROR_CODE\n\n  constructor(public readonly description: string) {\n    super(`Dynamic server usage: ${description}`)\n  }\n}\n\nexport function isDynamicServerError(err: unknown): err is DynamicServerError {\n  if (\n    typeof err !== 'object' ||\n    err === null ||\n    !('digest' in err) ||\n    typeof err.digest !== 'string'\n  ) {\n    return false\n  }\n\n  return err.digest === DYNAMIC_ERROR_CODE\n}\n"],"names":["DynamicServerError","isDynamicServerError","DYNAMIC_ERROR_CODE","Error","constructor","description","digest","err"],"mappings":";;;;;;;;;;;;;;IAEaA,kBAAkB,EAAA;eAAlBA;;IAQGC,oBAAoB,EAAA;eAApBA;;;AAVhB,MAAMC,qBAAqB;AAEpB,MAAMF,2BAA2BG;IAGtCC,YAA4BC,WAAmB,CAAE;QAC/C,KAAK,CAAE,2BAAwBA,cAAAA,IAAAA,CADLA,WAAAA,GAAAA,aAAAA,IAAAA,CAF5BC,MAAAA,GAAoCJ;IAIpC;AACF;AAEO,SAASD,qBAAqBM,GAAY;IAC/C,IACE,OAAOA,QAAQ,YACfA,QAAQ,QACR,CAAE,CAAA,YAAYA,GAAE,KAChB,OAAOA,IAAID,MAAM,KAAK,UACtB;QACA,OAAO;IACT;IAEA,OAAOC,IAAID,MAAM,KAAKJ;AACxB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3006, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/static-generation-bailout.ts"],"sourcesContent":["const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT'\n\nexport class StaticGenBailoutError extends Error {\n  public readonly code = NEXT_STATIC_GEN_BAILOUT\n}\n\nexport function isStaticGenBailoutError(\n  error: unknown\n): error is StaticGenBailoutError {\n  if (typeof error !== 'object' || error === null || !('code' in error)) {\n    return false\n  }\n\n  return error.code === NEXT_STATIC_GEN_BAILOUT\n}\n"],"names":["StaticGenBailoutError","isStaticGenBailoutError","NEXT_STATIC_GEN_BAILOUT","Error","code","error"],"mappings":";;;;;;;;;;;;;;IAEaA,qBAAqB,EAAA;eAArBA;;IAIGC,uBAAuB,EAAA;eAAvBA;;;AANhB,MAAMC,0BAA0B;AAEzB,MAAMF,8BAA8BG;;QAApC,KAAA,IAAA,OAAA,IAAA,CACWC,IAAAA,GAAOF;;AACzB;AAEO,SAASD,wBACdI,KAAc;IAEd,IAAI,OAAOA,UAAU,YAAYA,UAAU,QAAQ,CAAE,CAAA,UAAUA,KAAI,GAAI;QACrE,OAAO;IACT;IAEA,OAAOA,MAAMD,IAAI,KAAKF;AACxB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3050, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/lib/framework/boundary-constants.tsx"],"sourcesContent":["export const METADATA_BOUNDARY_NAME = '__next_metadata_boundary__'\nexport const VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__'\nexport const OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__'\nexport const ROOT_LAYOUT_BOUNDARY_NAME = '__next_root_layout_boundary__'\n"],"names":["METADATA_BOUNDARY_NAME","OUTLET_BOUNDARY_NAME","ROOT_LAYOUT_BOUNDARY_NAME","VIEWPORT_BOUNDARY_NAME"],"mappings":";;;;;;;;;;;;;;;;IAAaA,sBAAsB,EAAA;eAAtBA;;IAEAC,oBAAoB,EAAA;eAApBA;;IACAC,yBAAyB,EAAA;eAAzBA;;IAFAC,sBAAsB,EAAA;eAAtBA;;;AADN,MAAMH,yBAAyB;AAC/B,MAAMG,yBAAyB;AAC/B,MAAMF,uBAAuB;AAC7B,MAAMC,4BAA4B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3087, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/lib/scheduler.ts"],"sourcesContent":["export type ScheduledFn<T = void> = () => T | PromiseLike<T>\nexport type SchedulerFn<T = void> = (cb: ScheduledFn<T>) => void\n\n/**\n * Schedules a function to be called on the next tick after the other promises\n * have been resolved.\n *\n * @param cb the function to schedule\n */\nexport const scheduleOnNextTick = (cb: ScheduledFn<void>) => {\n  // We use Promise.resolve().then() here so that the operation is scheduled at\n  // the end of the promise job queue, we then add it to the next process tick\n  // to ensure it's evaluated afterwards.\n  //\n  // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255\n  //\n  Promise.resolve().then(() => {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n      setTimeout(cb, 0)\n    } else {\n      process.nextTick(cb)\n    }\n  })\n}\n\n/**\n * Schedules a function to be called using `setImmediate` or `setTimeout` if\n * `setImmediate` is not available (like in the Edge runtime).\n *\n * @param cb the function to schedule\n */\nexport const scheduleImmediate = (cb: ScheduledFn<void>): void => {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    setTimeout(cb, 0)\n  } else {\n    setImmediate(cb)\n  }\n}\n\n/**\n * returns a promise than resolves in a future task. There is no guarantee that the task it resolves in\n * will be the next task but if you await it you can at least be sure that the current task is over and\n * most usefully that the entire microtask queue of the current task has been emptied.\n */\nexport function atLeastOneTask() {\n  return new Promise<void>((resolve) => scheduleImmediate(resolve))\n}\n\n/**\n * This utility function is extracted to make it easier to find places where we are doing\n * specific timing tricks to try to schedule work after React has rendered. This is especially\n * important at the moment because Next.js uses the edge builds of React which use setTimeout to\n * schedule work when you might expect that something like setImmediate would do the trick.\n *\n * Long term we should switch to the node versions of React rendering when possible and then\n * update this to use setImmediate rather than setTimeout\n */\nexport function waitAtLeastOneReactRenderTask(): Promise<void> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    return new Promise((r) => setTimeout(r, 0))\n  } else {\n    return new Promise((r) => setImmediate(r))\n  }\n}\n"],"names":["atLeastOneTask","scheduleImmediate","scheduleOnNextTick","waitAtLeastOneReactRenderTask","cb","Promise","resolve","then","process","env","NEXT_RUNTIME","setTimeout","nextTick","setImmediate","r"],"mappings":"AAiBQQ,QAAQC,GAAG,CAACC,YAAY,KAAK,QAAQ;;;;;;;;;;;;;;;;;;IA2B7BV,cAAc,EAAA;eAAdA;;IAbHC,iBAAiB,EAAA;eAAjBA;;IAtBAC,kBAAkB,EAAA;eAAlBA;;IAgDGC,6BAA6B,EAAA;eAA7BA;;;AAhDT,MAAMD,qBAAqB,CAACE;IACjC,6EAA6E;IAC7E,4EAA4E;IAC5E,uCAAuC;IACvC,EAAE;IACF,kLAAkL;IAClL,EAAE;IACFC,QAAQC,OAAO,GAAGC,IAAI,CAAC;QACrB;;aAEO;YACLC,mOAAAA,CAAQI,QAAQ,CAACR;QACnB;IACF;AACF;AAQO,MAAMH,oBAAoB,CAACG;IAChC,IAAII,QAAQC,GAAG,CAACC,YAAY,KAAK,QAAQ;;SAElC;QACLG,aAAaT;IACf;AACF;AAOO,SAASJ;IACd,OAAO,IAAIK,QAAc,CAACC,UAAYL,kBAAkBK;AAC1D;AAWO,SAASH;IACd,IAAIK,QAAQC,GAAG,CAACC,YAAY,KAAK,QAAQ;;SAElC;QACL,OAAO,IAAIL,QAAQ,CAACS,IAAMD,aAAaC;IACzC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3154, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/server/app-render/dynamic-rendering.ts"],"sourcesContent":["/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */\n\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport type {\n  WorkUnitStore,\n  RequestStore,\n  PrerenderStoreLegacy,\n  PrerenderStoreModern,\n  PrerenderStoreModernRuntime,\n} from '../app-render/work-unit-async-storage.external'\n\n// Once postpone is in stable we should switch to importing the postpone export directly\nimport React from 'react'\n\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport {\n  getRuntimeStagePromise,\n  workUnitAsyncStorage,\n} from './work-unit-async-storage.external'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport {\n  METADATA_BOUNDARY_NAME,\n  VIEWPORT_BOUNDARY_NAME,\n  OUTLET_BOUNDARY_NAME,\n  ROOT_LAYOUT_BOUNDARY_NAME,\n} from '../../lib/framework/boundary-constants'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\nimport { BailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nconst hasPostpone = typeof React.unstable_postpone === 'function'\n\nexport type DynamicAccess = {\n  /**\n   * If debugging, this will contain the stack trace of where the dynamic access\n   * occurred. This is used to provide more information to the user about why\n   * their page is being rendered dynamically.\n   */\n  stack?: string\n\n  /**\n   * The expression that was accessed dynamically.\n   */\n  expression: string\n}\n\n// Stores dynamic reasons used during an RSC render.\nexport type DynamicTrackingState = {\n  /**\n   * When true, stack information will also be tracked during dynamic access.\n   */\n  readonly isDebugDynamicAccesses: boolean | undefined\n\n  /**\n   * The dynamic accesses that occurred during the render.\n   */\n  readonly dynamicAccesses: Array<DynamicAccess>\n\n  syncDynamicErrorWithStack: null | Error\n}\n\n// Stores dynamic reasons used during an SSR render.\nexport type DynamicValidationState = {\n  hasSuspenseAboveBody: boolean\n  hasDynamicMetadata: boolean\n  hasDynamicViewport: boolean\n  hasAllowedDynamic: boolean\n  dynamicErrors: Array<Error>\n}\n\nexport function createDynamicTrackingState(\n  isDebugDynamicAccesses: boolean | undefined\n): DynamicTrackingState {\n  return {\n    isDebugDynamicAccesses,\n    dynamicAccesses: [],\n    syncDynamicErrorWithStack: null,\n  }\n}\n\nexport function createDynamicValidationState(): DynamicValidationState {\n  return {\n    hasSuspenseAboveBody: false,\n    hasDynamicMetadata: false,\n    hasDynamicViewport: false,\n    hasAllowedDynamic: false,\n    dynamicErrors: [],\n  }\n}\n\nexport function getFirstDynamicReason(\n  trackingState: DynamicTrackingState\n): undefined | string {\n  return trackingState.dynamicAccesses[0]?.expression\n}\n\n/**\n * This function communicates that the current scope should be treated as dynamic.\n *\n * In most cases this function is a no-op but if called during\n * a PPR prerender it will postpone the current sub-tree and calling\n * it during a normal prerender will cause the entire prerender to abort\n */\nexport function markCurrentScopeAsDynamic(\n  store: WorkStore,\n  workUnitStore: undefined | Exclude<WorkUnitStore, PrerenderStoreModern>,\n  expression: string\n): void {\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'unstable-cache':\n        // Inside cache scopes, marking a scope as dynamic has no effect,\n        // because the outer cache scope creates a cache boundary. This is\n        // subtly different from reading a dynamic data source, which is\n        // forbidden inside a cache scope.\n        return\n      case 'private-cache':\n        // A private cache scope is already dynamic by definition.\n        return\n      case 'prerender-legacy':\n      case 'prerender-ppr':\n      case 'request':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  // If we're forcing dynamic rendering or we're forcing static rendering, we\n  // don't need to do anything here because the entire page is already dynamic\n  // or it's static and it should not throw or postpone here.\n  if (store.forceDynamic || store.forceStatic) return\n\n  if (store.dynamicShouldError) {\n    throw new StaticGenBailoutError(\n      `Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n    )\n  }\n\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender-ppr':\n        return postponeWithTracking(\n          store.route,\n          expression,\n          workUnitStore.dynamicTracking\n        )\n      case 'prerender-legacy':\n        workUnitStore.revalidate = 0\n\n        // We aren't prerendering, but we are generating a static page. We need\n        // to bail out of static generation.\n        const err = new DynamicServerError(\n          `Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n        )\n        store.dynamicUsageDescription = expression\n        store.dynamicUsageStack = err.stack\n\n        throw err\n      case 'request':\n        if (process.env.NODE_ENV !== 'production') {\n          workUnitStore.usedDynamic = true\n        }\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n}\n\n/**\n * This function is meant to be used when prerendering without cacheComponents or PPR.\n * When called during a build it will cause Next.js to consider the route as dynamic.\n *\n * @internal\n */\nexport function throwToInterruptStaticGeneration(\n  expression: string,\n  store: WorkStore,\n  prerenderStore: PrerenderStoreLegacy\n): never {\n  // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n  const err = new DynamicServerError(\n    `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n  )\n\n  prerenderStore.revalidate = 0\n\n  store.dynamicUsageDescription = expression\n  store.dynamicUsageStack = err.stack\n\n  throw err\n}\n\n/**\n * This function should be used to track whether something dynamic happened even when\n * we are in a dynamic render. This is useful for Dev where all renders are dynamic but\n * we still track whether dynamic APIs were accessed for helpful messaging\n *\n * @internal\n */\nexport function trackDynamicDataInDynamicRender(workUnitStore: WorkUnitStore) {\n  switch (workUnitStore.type) {\n    case 'cache':\n    case 'unstable-cache':\n      // Inside cache scopes, marking a scope as dynamic has no effect,\n      // because the outer cache scope creates a cache boundary. This is\n      // subtly different from reading a dynamic data source, which is\n      // forbidden inside a cache scope.\n      return\n    case 'private-cache':\n      // A private cache scope is already dynamic by definition.\n      return\n    case 'prerender':\n    case 'prerender-runtime':\n    case 'prerender-legacy':\n    case 'prerender-ppr':\n    case 'prerender-client':\n      break\n    case 'request':\n      if (process.env.NODE_ENV !== 'production') {\n        workUnitStore.usedDynamic = true\n      }\n      break\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nfunction abortOnSynchronousDynamicDataAccess(\n  route: string,\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n\n  const error = createPrerenderInterruptedError(reason)\n\n  prerenderStore.controller.abort(error)\n\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function abortOnSynchronousPlatformIOAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n  // It is important that we set this tracking value after aborting. Aborts are executed\n  // synchronously except for the case where you abort during render itself. By setting this\n  // value late we can use it to determine if any of the aborted tasks are the task that\n  // called the sync IO expression in the first place.\n  if (dynamicTracking) {\n    if (dynamicTracking.syncDynamicErrorWithStack === null) {\n      dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n    }\n  }\n}\n\nexport function trackSynchronousPlatformIOAccessInDev(\n  requestStore: RequestStore\n): void {\n  // We don't actually have a controller to abort but we do the semantic equivalent by\n  // advancing the request store out of prerender mode\n  requestStore.prerenderPhase = false\n}\n\n/**\n * use this function when prerendering with cacheComponents. If we are doing a\n * prospective prerender we don't actually abort because we want to discover\n * all caches for the shell. If this is the actual prerender we do abort.\n *\n * This function accepts a prerenderStore but the caller should ensure we're\n * actually running in cacheComponents mode.\n *\n * @internal\n */\nexport function abortAndThrowOnSynchronousRequestDataAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): never {\n  const prerenderSignal = prerenderStore.controller.signal\n  if (prerenderSignal.aborted === false) {\n    // TODO it would be better to move this aborted check into the callsite so we can avoid making\n    // the error object when it isn't relevant to the aborting of the prerender however\n    // since we need the throw semantics regardless of whether we abort it is easier to land\n    // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer\n    // to ideal implementation\n    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n    // It is important that we set this tracking value after aborting. Aborts are executed\n    // synchronously except for the case where you abort during render itself. By setting this\n    // value late we can use it to determine if any of the aborted tasks are the task that\n    // called the sync IO expression in the first place.\n    const dynamicTracking = prerenderStore.dynamicTracking\n    if (dynamicTracking) {\n      if (dynamicTracking.syncDynamicErrorWithStack === null) {\n        dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n      }\n    }\n  }\n  throw createPrerenderInterruptedError(\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n  )\n}\n\n/**\n * Use this function when dynamically prerendering with dynamicIO.\n * We don't want to error, because it's better to return something\n * (and we've already aborted the render at the point where the sync dynamic error occured),\n * but we should log an error server-side.\n * @internal\n */\nexport function warnOnSyncDynamicError(dynamicTracking: DynamicTrackingState) {\n  if (dynamicTracking.syncDynamicErrorWithStack) {\n    // the server did something sync dynamic, likely\n    // leading to an early termination of the prerender.\n    console.error(dynamicTracking.syncDynamicErrorWithStack)\n  }\n}\n\n// For now these implementations are the same so we just reexport\nexport const trackSynchronousRequestDataAccessInDev =\n  trackSynchronousPlatformIOAccessInDev\n\n/**\n * This component will call `React.postpone` that throws the postponed error.\n */\ntype PostponeProps = {\n  reason: string\n  route: string\n}\nexport function Postpone({ reason, route }: PostponeProps): never {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  const dynamicTracking =\n    prerenderStore && prerenderStore.type === 'prerender-ppr'\n      ? prerenderStore.dynamicTracking\n      : null\n  postponeWithTracking(route, reason, dynamicTracking)\n}\n\nexport function postponeWithTracking(\n  route: string,\n  expression: string,\n  dynamicTracking: null | DynamicTrackingState\n): never {\n  assertPostpone()\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n\n  React.unstable_postpone(createPostponeReason(route, expression))\n}\n\nfunction createPostponeReason(route: string, expression: string) {\n  return (\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` +\n    `React throws this special object to indicate where. It should not be caught by ` +\n    `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`\n  )\n}\n\nexport function isDynamicPostpone(err: unknown) {\n  if (\n    typeof err === 'object' &&\n    err !== null &&\n    typeof (err as any).message === 'string'\n  ) {\n    return isDynamicPostponeReason((err as any).message)\n  }\n  return false\n}\n\nfunction isDynamicPostponeReason(reason: string) {\n  return (\n    reason.includes(\n      'needs to bail out of prerendering at this point because it used'\n    ) &&\n    reason.includes(\n      'Learn more: https://nextjs.org/docs/messages/ppr-caught-error'\n    )\n  )\n}\n\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\n  throw new Error(\n    'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'\n  )\n}\n\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED'\n\nfunction createPrerenderInterruptedError(message: string): Error {\n  const error = new Error(message)\n  ;(error as any).digest = NEXT_PRERENDER_INTERRUPTED\n  return error\n}\n\ntype DigestError = Error & {\n  digest: string\n}\n\nexport function isPrerenderInterruptedError(\n  error: unknown\n): error is DigestError {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    (error as any).digest === NEXT_PRERENDER_INTERRUPTED &&\n    'name' in error &&\n    'message' in error &&\n    error instanceof Error\n  )\n}\n\nexport function accessedDynamicData(\n  dynamicAccesses: Array<DynamicAccess>\n): boolean {\n  return dynamicAccesses.length > 0\n}\n\nexport function consumeDynamicAccess(\n  serverDynamic: DynamicTrackingState,\n  clientDynamic: DynamicTrackingState\n): DynamicTrackingState['dynamicAccesses'] {\n  // We mutate because we only call this once we are no longer writing\n  // to the dynamicTrackingState and it's more efficient than creating a new\n  // array.\n  serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses)\n  return serverDynamic.dynamicAccesses\n}\n\nexport function formatDynamicAPIAccesses(\n  dynamicAccesses: Array<DynamicAccess>\n): string[] {\n  return dynamicAccesses\n    .filter(\n      (access): access is Required<DynamicAccess> =>\n        typeof access.stack === 'string' && access.stack.length > 0\n    )\n    .map(({ expression, stack }) => {\n      stack = stack\n        .split('\\n')\n        // Remove the \"Error: \" prefix from the first line of the stack trace as\n        // well as the first 4 lines of the stack trace which is the distance\n        // from the user code and the `new Error().stack` call.\n        .slice(4)\n        .filter((line) => {\n          // Exclude Next.js internals from the stack trace.\n          if (line.includes('node_modules/next/')) {\n            return false\n          }\n\n          // Exclude anonymous functions from the stack trace.\n          if (line.includes(' (<anonymous>)')) {\n            return false\n          }\n\n          // Exclude Node.js internals from the stack trace.\n          if (line.includes(' (node:')) {\n            return false\n          }\n\n          return true\n        })\n        .join('\\n')\n      return `Dynamic API Usage Debug - ${expression}:\\n${stack}`\n    })\n}\n\nfunction assertPostpone() {\n  if (!hasPostpone) {\n    throw new Error(\n      `Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`\n    )\n  }\n}\n\n/**\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\n * abort semantics slightly.\n */\nexport function createRenderInBrowserAbortSignal(): AbortSignal {\n  const controller = new AbortController()\n  controller.abort(new BailoutToCSRError('Render in Browser'))\n  return controller.signal\n}\n\n/**\n * In a prerender, we may end up with hanging Promises as inputs due them\n * stalling on connection() or because they're loading dynamic data. In that\n * case we need to abort the encoding of arguments since they'll never complete.\n */\nexport function createHangingInputAbortSignal(\n  workUnitStore: WorkUnitStore\n): AbortSignal | undefined {\n  switch (workUnitStore.type) {\n    case 'prerender':\n    case 'prerender-runtime':\n      const controller = new AbortController()\n\n      if (workUnitStore.cacheSignal) {\n        // If we have a cacheSignal it means we're in a prospective render. If\n        // the input we're waiting on is coming from another cache, we do want\n        // to wait for it so that we can resolve this cache entry too.\n        workUnitStore.cacheSignal.inputReady().then(() => {\n          controller.abort()\n        })\n      } else {\n        // Otherwise we're in the final render and we should already have all\n        // our caches filled.\n        // If the prerender uses stages, we have wait until the runtime stage,\n        // at which point all runtime inputs will be resolved.\n        // (otherwise, a runtime prerender might consider `cookies()` hanging\n        //  even though they'd resolve in the next task.)\n        //\n        // We might still be waiting on some microtasks so we\n        // wait one tick before giving up. When we give up, we still want to\n        // render the content of this cache as deeply as we can so that we can\n        // suspend as deeply as possible in the tree or not at all if we don't\n        // end up waiting for the input.\n        const runtimeStagePromise = getRuntimeStagePromise(workUnitStore)\n        if (runtimeStagePromise) {\n          runtimeStagePromise.then(() =>\n            scheduleOnNextTick(() => controller.abort())\n          )\n        } else {\n          scheduleOnNextTick(() => controller.abort())\n        }\n      }\n\n      return controller.signal\n    case 'prerender-client':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'request':\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n      return undefined\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nexport function annotateDynamicAccess(\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n) {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function useDynamicRouteParams(expression: string) {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workStore && workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender-client':\n      case 'prerender': {\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        if (fallbackParams && fallbackParams.size > 0) {\n          // We are in a prerender with cacheComponents semantics. We are going to\n          // hang here and never resolve. This will cause the currently\n          // rendering component to effectively be a dynamic hole.\n          React.use(\n            makeHangingPromise(\n              workUnitStore.renderSignal,\n              workStore.route,\n              expression\n            )\n          )\n        }\n        break\n      }\n      case 'prerender-ppr': {\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        if (fallbackParams && fallbackParams.size > 0) {\n          return postponeWithTracking(\n            workStore.route,\n            expression,\n            workUnitStore.dynamicTracking\n          )\n        }\n        break\n      }\n      case 'prerender-runtime':\n        throw new InvariantError(\n          `\\`${expression}\\` was called during a runtime prerender. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n        )\n      case 'cache':\n      case 'private-cache':\n        throw new InvariantError(\n          `\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n        )\n      case 'prerender-legacy':\n      case 'request':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n}\n\nconst hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/\n\n// Common implicit body tags that React will treat as body when placed directly in html\nconst bodyAndImplicitTags =\n  'body|div|main|section|article|aside|header|footer|nav|form|p|span|h1|h2|h3|h4|h5|h6'\n\n// Detects when RootLayoutBoundary (our framework marker component) appears\n// after Suspense in the component stack, indicating the root layout is wrapped\n// within a Suspense boundary. Ensures no body/html/implicit-body components are in between.\n//\n// Example matches:\n//   at Suspense (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\n//\n// Or with other components in between (but not body/html/implicit-body):\n//   at Suspense (<anonymous>)\n//   at SomeComponent (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\nconst hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex = new RegExp(\n  `\\\\n\\\\s+at Suspense \\\\(<anonymous>\\\\)(?:(?!\\\\n\\\\s+at (?:${bodyAndImplicitTags}) \\\\(<anonymous>\\\\))[\\\\s\\\\S])*?\\\\n\\\\s+at ${ROOT_LAYOUT_BOUNDARY_NAME} \\\\([^\\\\n]*\\\\)`\n)\n\nconst hasMetadataRegex = new RegExp(\n  `\\\\n\\\\s+at ${METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasViewportRegex = new RegExp(\n  `\\\\n\\\\s+at ${VIEWPORT_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`)\n\nexport function trackAllowedDynamicAccess(\n  workStore: WorkStore,\n  componentStack: string,\n  dynamicValidation: DynamicValidationState,\n  clientDynamic: DynamicTrackingState\n) {\n  if (hasOutletRegex.test(componentStack)) {\n    // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n    return\n  } else if (hasMetadataRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicMetadata = true\n    return\n  } else if (hasViewportRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicViewport = true\n    return\n  } else if (\n    hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(\n      componentStack\n    )\n  ) {\n    // For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.\n    // But if you have Suspense above body, the prelude is empty but we allow that because having Suspense\n    // is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.\n    dynamicValidation.hasAllowedDynamic = true\n    dynamicValidation.hasSuspenseAboveBody = true\n    return\n  } else if (hasSuspenseRegex.test(componentStack)) {\n    // this error had a Suspense boundary above it so we don't need to report it as a source\n    // of disallowed\n    dynamicValidation.hasAllowedDynamic = true\n    return\n  } else if (clientDynamic.syncDynamicErrorWithStack) {\n    // This task was the task that called the sync error.\n    dynamicValidation.dynamicErrors.push(\n      clientDynamic.syncDynamicErrorWithStack\n    )\n    return\n  } else {\n    const message = `Route \"${workStore.route}\": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a \"use cache\" above it. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  }\n}\n\n/**\n * In dev mode, we prefer using the owner stack, otherwise the provided\n * component stack is used.\n */\nfunction createErrorWithComponentOrOwnerStack(\n  message: string,\n  componentStack: string\n) {\n  const ownerStack =\n    process.env.NODE_ENV !== 'production' && React.captureOwnerStack\n      ? React.captureOwnerStack()\n      : null\n\n  const error = new Error(message)\n  error.stack = error.name + ': ' + message + (ownerStack ?? componentStack)\n  return error\n}\n\nexport enum PreludeState {\n  Full = 0,\n  Empty = 1,\n  Errored = 2,\n}\n\nexport function logDisallowedDynamicError(\n  workStore: WorkStore,\n  error: Error\n): void {\n  console.error(error)\n\n  if (!workStore.dev) {\n    if (workStore.hasReadableErrorStacks) {\n      console.error(\n        `To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.`\n      )\n    } else {\n      console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:\n  - Start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.\n  - Rerun the production build with \\`next build --debug-prerender\\` to generate better stack traces.`)\n    }\n  }\n}\n\nexport function throwIfDisallowedDynamic(\n  workStore: WorkStore,\n  prelude: PreludeState,\n  dynamicValidation: DynamicValidationState,\n  serverDynamic: DynamicTrackingState\n): void {\n  if (prelude !== PreludeState.Full) {\n    if (dynamicValidation.hasSuspenseAboveBody) {\n      // This route has opted into allowing fully dynamic rendering\n      // by including a Suspense boundary above the body. In this case\n      // a lack of a shell is not considered disallowed so we simply return\n      return\n    }\n\n    if (serverDynamic.syncDynamicErrorWithStack) {\n      // There is no shell and the server did something sync dynamic likely\n      // leading to an early termination of the prerender before the shell\n      // could be completed. We terminate the build/validating render.\n      logDisallowedDynamicError(\n        workStore,\n        serverDynamic.syncDynamicErrorWithStack\n      )\n      throw new StaticGenBailoutError()\n    }\n\n    // We didn't have any sync bailouts but there may be user code which\n    // blocked the root. We would have captured these during the prerender\n    // and can log them here and then terminate the build/validating render\n    const dynamicErrors = dynamicValidation.dynamicErrors\n    if (dynamicErrors.length > 0) {\n      for (let i = 0; i < dynamicErrors.length; i++) {\n        logDisallowedDynamicError(workStore, dynamicErrors[i])\n      }\n\n      throw new StaticGenBailoutError()\n    }\n\n    // If we got this far then the only other thing that could be blocking\n    // the root is dynamic Viewport. If this is dynamic then\n    // you need to opt into that by adding a Suspense boundary above the body\n    // to indicate your are ok with fully dynamic rendering.\n    if (dynamicValidation.hasDynamicViewport) {\n      console.error(\n        `Route \"${workStore.route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`\n      )\n      throw new StaticGenBailoutError()\n    }\n\n    if (prelude === PreludeState.Empty) {\n      // If we ever get this far then we messed up the tracking of invalid dynamic.\n      // We still adhere to the constraint that you must produce a shell but invite the\n      // user to report this as a bug in Next.js.\n      console.error(\n        `Route \"${workStore.route}\" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`\n      )\n      throw new StaticGenBailoutError()\n    }\n  } else {\n    if (\n      dynamicValidation.hasAllowedDynamic === false &&\n      dynamicValidation.hasDynamicMetadata\n    ) {\n      console.error(\n        `Route \"${workStore.route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`\n      )\n      throw new StaticGenBailoutError()\n    }\n  }\n}\n\nexport function delayUntilRuntimeStage<T>(\n  prerenderStore: PrerenderStoreModernRuntime,\n  result: Promise<T>\n): Promise<T> {\n  if (prerenderStore.runtimeStagePromise) {\n    return prerenderStore.runtimeStagePromise.then(() => result)\n  }\n  return result\n}\n"],"names":["Postpone","PreludeState","abortAndThrowOnSynchronousRequestDataAccess","abortOnSynchronousPlatformIOAccess","accessedDynamicData","annotateDynamicAccess","consumeDynamicAccess","createDynamicTrackingState","createDynamicValidationState","createHangingInputAbortSignal","createRenderInBrowserAbortSignal","delayUntilRuntimeStage","formatDynamicAPIAccesses","getFirstDynamicReason","isDynamicPostpone","isPrerenderInterruptedError","logDisallowedDynamicError","markCurrentScopeAsDynamic","postponeWithTracking","throwIfDisallowedDynamic","throwToInterruptStaticGeneration","trackAllowedDynamicAccess","trackDynamicDataInDynamicRender","trackSynchronousPlatformIOAccessInDev","trackSynchronousRequestDataAccessInDev","useDynamicRouteParams","warnOnSyncDynamicError","hasPostpone","React","unstable_postpone","isDebugDynamicAccesses","dynamicAccesses","syncDynamicErrorWithStack","hasSuspenseAboveBody","hasDynamicMetadata","hasDynamicViewport","hasAllowedDynamic","dynamicErrors","trackingState","expression","store","workUnitStore","type","forceDynamic","forceStatic","dynamicShouldError","StaticGenBailoutError","route","dynamicTracking","revalidate","err","DynamicServerError","dynamicUsageDescription","dynamicUsageStack","stack","process","env","NODE_ENV","usedDynamic","prerenderStore","abortOnSynchronousDynamicDataAccess","reason","error","createPrerenderInterruptedError","controller","abort","push","Error","undefined","errorWithStack","requestStore","prerenderPhase","prerenderSignal","signal","aborted","console","workUnitAsyncStorage","getStore","assertPostpone","createPostponeReason","message","isDynamicPostponeReason","includes","NEXT_PRERENDER_INTERRUPTED","digest","length","serverDynamic","clientDynamic","filter","access","map","split","slice","line","join","AbortController","BailoutToCSRError","cacheSignal","inputReady","then","runtimeStagePromise","getRuntimeStagePromise","scheduleOnNextTick","workStore","workAsyncStorage","fallbackParams","fallbackRouteParams","size","use","makeHangingPromise","renderSignal","InvariantError","hasSuspenseRegex","bodyAndImplicitTags","hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex","RegExp","ROOT_LAYOUT_BOUNDARY_NAME","hasMetadataRegex","METADATA_BOUNDARY_NAME","hasViewportRegex","VIEWPORT_BOUNDARY_NAME","hasOutletRegex","OUTLET_BOUNDARY_NAME","componentStack","dynamicValidation","test","createErrorWithComponentOrOwnerStack","ownerStack","captureOwnerStack","name","dev","hasReadableErrorStacks","prelude","i","result"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;CAoBC,GAmKWuD,QAAQC,GAAG,CAACC,QAAQ,KAAK;AAnKpC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA6VezD,QAAQ,EAAA;eAARA;;IA4XJC,YAAY,EAAA;eAAZA;;IApbIC,2CAA2C,EAAA;eAA3CA;;IArCAC,kCAAkC,EAAA;eAAlCA;;IAuLAC,mBAAmB,EAAA;eAAnBA;;IAkIAC,qBAAqB,EAAA;eAArBA;;IA5HAC,oBAAoB,EAAA;eAApBA;;IArXAC,0BAA0B,EAAA;eAA1BA;;IAUAC,4BAA4B,EAAA;eAA5BA;;IAmbAC,6BAA6B,EAAA;eAA7BA;;IAXAC,gCAAgC,EAAA;eAAhCA;;IA8TAC,sBAAsB,EAAA;eAAtBA;;IAhXAC,wBAAwB,EAAA;eAAxBA;;IA5WAC,qBAAqB,EAAA;eAArBA;;IAsSAC,iBAAiB,EAAA;eAAjBA;;IAwCAC,2BAA2B,EAAA;eAA3BA;;IAqTAC,yBAAyB,EAAA;eAAzBA;;IAtnBAC,yBAAyB,EAAA;eAAzBA;;IA6PAC,oBAAoB,EAAA;eAApBA;;IA4YAC,wBAAwB,EAAA;eAAxBA;;IA/jBAC,gCAAgC,EAAA;eAAhCA;;IAueAC,yBAAyB,EAAA;eAAzBA;;IA9cAC,+BAA+B,EAAA;eAA/BA;;IAuEAC,qCAAqC,EAAA;eAArCA;;IAgEHC,sCAAsC,EAAA;eAAtCA;;IAqPGC,qBAAqB,EAAA;eAArBA;;IA9PAC,sBAAsB,EAAA;eAAtBA;;;8DA9TE;oCAEiB;yCACG;8CAI/B;0CAC0B;uCACE;mCAM5B;2BAC4B;8BACD;gCACH;;;;;;AAE/B,MAAMC,cAAc,OAAOC,OAAAA,OAAK,CAACC,iBAAiB,KAAK;AAwChD,SAAStB,2BACduB,sBAA2C;IAE3C,OAAO;QACLA;QACAC,iBAAiB,EAAE;QACnBC,2BAA2B;IAC7B;AACF;AAEO,SAASxB;IACd,OAAO;QACLyB,sBAAsB;QACtBC,oBAAoB;QACpBC,oBAAoB;QACpBC,mBAAmB;QACnBC,eAAe,EAAE;IACnB;AACF;AAEO,SAASxB,sBACdyB,aAAmC;QAE5BA;IAAP,OAAA,CAAOA,kCAAAA,cAAcP,eAAe,CAAC,EAAE,KAAA,OAAA,KAAA,IAAhCO,gCAAkCC,UAAU;AACrD;AASO,SAAStB,0BACduB,KAAgB,EAChBC,aAAuE,EACvEF,UAAkB;IAElB,IAAIE,eAAe;QACjB,OAAQA,cAAcC,IAAI;YACxB,KAAK;YACL,KAAK;gBACH,iEAAiE;gBACjE,kEAAkE;gBAClE,gEAAgE;gBAChE,kCAAkC;gBAClC;YACF,KAAK;gBACH,0DAA0D;gBAC1D;YACF,KAAK;YACL,KAAK;YACL,KAAK;gBACH;YACF;gBACED;QACJ;IACF;IAEA,2EAA2E;IAC3E,4EAA4E;IAC5E,2DAA2D;IAC3D,IAAID,MAAMG,YAAY,IAAIH,MAAMI,WAAW,EAAE;IAE7C,IAAIJ,MAAMK,kBAAkB,EAAE;QAC5B,MAAM,OAAA,cAEL,CAFK,IAAIC,yBAAAA,qBAAqB,CAC5B,AAAD,MAAO,UAAEN,MAAMO,KAAK,EAAC,8EAA8E,SAAER,YAAW,4HAA4H,CAAC,IADzO,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,IAAIE,eAAe;QACjB,OAAQA,cAAcC,IAAI;YACxB,KAAK;gBACH,OAAOxB,qBACLsB,MAAMO,KAAK,EACXR,YACAE,cAAcO,eAAe;YAEjC,KAAK;gBACHP,cAAcQ,UAAU,GAAG;gBAE3B,uEAAuE;gBACvE,oCAAoC;gBACpC,MAAMC,MAAM,OAAA,cAEX,CAFW,IAAIC,oBAAAA,kBAAkB,CAChC,AAAC,MAAM,UAAEX,MAAMO,KAAK,EAAC,iDAAiD,WAAER,YAAW,2EAA2E,CAAC,KADrJ,qBAAA;2BAAA;gCAAA;kCAAA;gBAEZ;gBACAC,MAAMY,uBAAuB,GAAGb;gBAChCC,MAAMa,iBAAiB,GAAGH,IAAII,KAAK;gBAEnC,MAAMJ;YACR,KAAK;gBACH,wCAA2C;oBACzCT,cAAciB,WAAW,GAAG;gBAC9B;gBACA;YACF;gBACEjB;QACJ;IACF;AACF;AAQO,SAASrB,iCACdmB,UAAkB,EAClBC,KAAgB,EAChBmB,cAAoC;IAEpC,uGAAuG;IACvG,MAAMT,MAAM,OAAA,cAEX,CAFW,IAAIC,oBAAAA,kBAAkB,CAChC,AAAC,MAAM,UAAEX,MAAMO,KAAK,EAAC,mDAAmD,UAAER,YAAW,6EAA6E,CAAC,IADzJ,qBAAA;eAAA;oBAAA;sBAAA;IAEZ;IAEAoB,eAAeV,UAAU,GAAG;IAE5BT,MAAMY,uBAAuB,GAAGb;IAChCC,MAAMa,iBAAiB,GAAGH,IAAII,KAAK;IAEnC,MAAMJ;AACR;AASO,SAAS5B,gCAAgCmB,aAA4B;IAC1E,OAAQA,cAAcC,IAAI;QACxB,KAAK;QACL,KAAK;YACH,iEAAiE;YACjE,kEAAkE;YAClE,gEAAgE;YAChE,kCAAkC;YAClC;QACF,KAAK;YACH,0DAA0D;YAC1D;QACF,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACH;QACF,KAAK;YACH,IAAIa,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;gBACzChB,cAAciB,WAAW,GAAG;YAC9B;YACA;QACF;YACEjB;IACJ;AACF;AAEA,SAASmB,oCACPb,KAAa,EACbR,UAAkB,EAClBoB,cAAoC;IAEpC,MAAME,SAAS,AAAC,MAAM,UAAEd,OAAM,iEAAiE,WAAER,YAAW,CAAC,CAAC;IAE9G,MAAMuB,QAAQC,gCAAgCF;IAE9CF,eAAeK,UAAU,CAACC,KAAK,CAACH;IAEhC,MAAMd,kBAAkBW,eAAeX,eAAe;IACtD,IAAIA,iBAAiB;QACnBA,gBAAgBjB,eAAe,CAACmC,IAAI,CAAC;YACnC,0EAA0E;YAC1E,eAAe;YACfZ,OAAON,gBAAgBlB,sBAAsB,GACzC,IAAIqC,QAAQb,KAAK,GACjBc;YACJ7B;QACF;IACF;AACF;AAEO,SAASpC,mCACd4C,KAAa,EACbR,UAAkB,EAClB8B,cAAqB,EACrBV,cAAoC;IAEpC,MAAMX,kBAAkBW,eAAeX,eAAe;IACtDY,oCAAoCb,OAAOR,YAAYoB;IACvD,sFAAsF;IACtF,0FAA0F;IAC1F,sFAAsF;IACtF,oDAAoD;IACpD,IAAIX,iBAAiB;QACnB,IAAIA,gBAAgBhB,yBAAyB,KAAK,MAAM;YACtDgB,gBAAgBhB,yBAAyB,GAAGqC;QAC9C;IACF;AACF;AAEO,SAAS9C,sCACd+C,YAA0B;IAE1B,oFAAoF;IACpF,oDAAoD;IACpDA,aAAaC,cAAc,GAAG;AAChC;AAYO,SAASrE,4CACd6C,KAAa,EACbR,UAAkB,EAClB8B,cAAqB,EACrBV,cAAoC;IAEpC,MAAMa,kBAAkBb,eAAeK,UAAU,CAACS,MAAM;IACxD,IAAID,gBAAgBE,OAAO,KAAK,OAAO;QACrC,8FAA8F;QAC9F,mFAAmF;QACnF,wFAAwF;QACxF,4FAA4F;QAC5F,0BAA0B;QAC1Bd,oCAAoCb,OAAOR,YAAYoB;QACvD,sFAAsF;QACtF,0FAA0F;QAC1F,sFAAsF;QACtF,oDAAoD;QACpD,MAAMX,kBAAkBW,eAAeX,eAAe;QACtD,IAAIA,iBAAiB;YACnB,IAAIA,gBAAgBhB,yBAAyB,KAAK,MAAM;gBACtDgB,gBAAgBhB,yBAAyB,GAAGqC;YAC9C;QACF;IACF;IACA,MAAMN,gCACJ,AAAC,MAAM,UAAEhB,OAAM,iEAAiE,WAAER,YAAW,CAAC,CAAC;AAEnG;AASO,SAASb,uBAAuBsB,eAAqC;IAC1E,IAAIA,gBAAgBhB,yBAAyB,EAAE;QAC7C,gDAAgD;QAChD,oDAAoD;QACpD2C,QAAQb,KAAK,CAACd,gBAAgBhB,yBAAyB;IACzD;AACF;AAGO,MAAMR,yCACXD;AASK,SAASvB;UAAW6D,MAAM,EAAEd,KAAK,EAAiB,GAAhC;IACvB,MAAMY,iBAAiBiB,8BAAAA,oBAAoB,CAACC,QAAQ;IACpD,MAAM7B,kBACJW,kBAAkBA,eAAejB,IAAI,KAAK,kBACtCiB,eAAeX,eAAe,GAC9B;IACN9B,qBAAqB6B,OAAOc,QAAQb;AACtC;AAEO,SAAS9B,qBACd6B,KAAa,EACbR,UAAkB,EAClBS,eAA4C;IAE5C8B;IACA,IAAI9B,iBAAiB;QACnBA,gBAAgBjB,eAAe,CAACmC,IAAI,CAAC;YACnC,0EAA0E;YAC1E,eAAe;YACfZ,OAAON,gBAAgBlB,sBAAsB,GACzC,IAAIqC,QAAQb,KAAK,GACjBc;YACJ7B;QACF;IACF;IAEAX,OAAAA,OAAK,CAACC,iBAAiB,CAACkD,qBAAqBhC,OAAOR;AACtD;AAEA,SAASwC,qBAAqBhC,KAAa,EAAER,UAAkB;IAC7D,OACG,AAAD,MAAO,UAAEQ,OAAM,iEAAiE,WAAER,YAAW,EAAE,CAAC,GAChG,EAAC,+EAA+E,CAAC,GACjF,CAAC,iFAAiF,CAAC;AAEvF;AAEO,SAASzB,kBAAkBoC,GAAY;IAC5C,IACE,OAAOA,QAAQ,YACfA,QAAQ,QACR,OAAQA,IAAY8B,OAAO,KAAK,UAChC;QACA,OAAOC,wBAAyB/B,IAAY8B,OAAO;IACrD;IACA,OAAO;AACT;AAEA,SAASC,wBAAwBpB,MAAc;IAC7C,OACEA,OAAOqB,QAAQ,CACb,sEAEFrB,OAAOqB,QAAQ,CACb;AAGN;AAEA,IAAID,wBAAwBF,qBAAqB,OAAO,YAAY,OAAO;IACzE,MAAM,OAAA,cAEL,CAFK,IAAIZ,MACR,2FADI,qBAAA;eAAA;oBAAA;sBAAA;IAEN;AACF;AAEA,MAAMgB,6BAA6B;AAEnC,SAASpB,gCAAgCiB,OAAe;IACtD,MAAMlB,QAAQ,OAAA,cAAkB,CAAlB,IAAIK,MAAMa,UAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAiB;IAC7BlB,MAAcsB,MAAM,GAAGD;IACzB,OAAOrB;AACT;AAMO,SAAS/C,4BACd+C,KAAc;IAEd,OACE,OAAOA,UAAU,YACjBA,UAAU,QACTA,MAAcsB,MAAM,KAAKD,8BAC1B,UAAUrB,SACV,aAAaA,SACbA,iBAAiBK;AAErB;AAEO,SAAS/D,oBACd2B,eAAqC;IAErC,OAAOA,gBAAgBsD,MAAM,GAAG;AAClC;AAEO,SAAS/E,qBACdgF,aAAmC,EACnCC,aAAmC;IAEnC,oEAAoE;IACpE,0EAA0E;IAC1E,SAAS;IACTD,cAAcvD,eAAe,CAACmC,IAAI,IAAIqB,cAAcxD,eAAe;IACnE,OAAOuD,cAAcvD,eAAe;AACtC;AAEO,SAASnB,yBACdmB,eAAqC;IAErC,OAAOA,gBACJyD,MAAM,CACL,CAACC,SACC,OAAOA,OAAOnC,KAAK,KAAK,YAAYmC,OAAOnC,KAAK,CAAC+B,MAAM,GAAG,GAE7DK,GAAG,CAAC;YAAC,EAAEnD,UAAU,EAAEe,KAAK,EAAE;QACzBA,QAAQA,MACLqC,KAAK,CAAC,MACP,wEAAwE;QACxE,qEAAqE;QACrE,uDAAuD;SACtDC,KAAK,CAAC,GACNJ,MAAM,CAAC,CAACK;YACP,kDAAkD;YAClD,IAAIA,KAAKX,QAAQ,CAAC,uBAAuB;gBACvC,OAAO;YACT;YAEA,oDAAoD;YACpD,IAAIW,KAAKX,QAAQ,CAAC,mBAAmB;gBACnC,OAAO;YACT;YAEA,kDAAkD;YAClD,IAAIW,KAAKX,QAAQ,CAAC,YAAY;gBAC5B,OAAO;YACT;YAEA,OAAO;QACT,GACCY,IAAI,CAAC;QACR,OAAO,AAAC,0BAA0B,UAAEvD,YAAW,GAAG,IAAEe,CAAO,MAAPA;IACtD;AACJ;AAEA,SAASwB;IACP,IAAI,CAACnD,aAAa;QAChB,MAAM,OAAA,cAEL,CAFK,IAAIwC,MACR,AAAC,gIAAgI,CAAC,IAD9H,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;AACF;AAMO,SAASzD;IACd,MAAMsD,aAAa,IAAI+B;IACvB/B,WAAWC,KAAK,CAAC,OAAA,cAA0C,CAA1C,IAAI+B,cAAAA,iBAAiB,CAAC,sBAAtB,qBAAA;eAAA;oBAAA;sBAAA;IAAyC;IAC1D,OAAOhC,WAAWS,MAAM;AAC1B;AAOO,SAAShE,8BACdgC,aAA4B;IAE5B,OAAQA,cAAcC,IAAI;QACxB,KAAK;QACL,KAAK;YACH,MAAMsB,aAAa,IAAI+B;YAEvB,IAAItD,cAAcwD,WAAW,EAAE;gBAC7B,sEAAsE;gBACtE,sEAAsE;gBACtE,8DAA8D;gBAC9DxD,cAAcwD,WAAW,CAACC,UAAU,GAAGC,IAAI,CAAC;oBAC1CnC,WAAWC,KAAK;gBAClB;YACF,OAAO;gBACL,qEAAqE;gBACrE,qBAAqB;gBACrB,sEAAsE;gBACtE,sDAAsD;gBACtD,qEAAqE;gBACrE,iDAAiD;gBACjD,EAAE;gBACF,qDAAqD;gBACrD,oEAAoE;gBACpE,sEAAsE;gBACtE,sEAAsE;gBACtE,gCAAgC;gBAChC,MAAMmC,sBAAsBC,CAAAA,GAAAA,8BAAAA,sBAAsB,EAAC5D;gBACnD,IAAI2D,qBAAqB;oBACvBA,oBAAoBD,IAAI,CAAC,IACvBG,CAAAA,GAAAA,WAAAA,kBAAkB,EAAC,IAAMtC,WAAWC,KAAK;gBAE7C,OAAO;oBACLqC,CAAAA,GAAAA,WAAAA,kBAAkB,EAAC,IAAMtC,WAAWC,KAAK;gBAC3C;YACF;YAEA,OAAOD,WAAWS,MAAM;QAC1B,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACH,OAAOL;QACT;YACE3B;IACJ;AACF;AAEO,SAASpC,sBACdkC,UAAkB,EAClBoB,cAAoC;IAEpC,MAAMX,kBAAkBW,eAAeX,eAAe;IACtD,IAAIA,iBAAiB;QACnBA,gBAAgBjB,eAAe,CAACmC,IAAI,CAAC;YACnCZ,OAAON,gBAAgBlB,sBAAsB,GACzC,IAAIqC,QAAQb,KAAK,GACjBc;YACJ7B;QACF;IACF;AACF;AAEO,SAASd,sBAAsBc,UAAkB;IACtD,MAAMgE,YAAYC,0BAAAA,gBAAgB,CAAC3B,QAAQ;IAC3C,MAAMpC,gBAAgBmC,8BAAAA,oBAAoB,CAACC,QAAQ;IACnD,IAAI0B,aAAa9D,eAAe;QAC9B,OAAQA,cAAcC,IAAI;YACxB,KAAK;YACL,KAAK;gBAAa;oBAChB,MAAM+D,iBAAiBhE,cAAciE,mBAAmB;oBACxD,IAAID,kBAAkBA,eAAeE,IAAI,GAAG,GAAG;wBAC7C,wEAAwE;wBACxE,6DAA6D;wBAC7D,wDAAwD;wBACxD/E,OAAAA,OAAK,CAACgF,GAAG,CACPC,CAAAA,GAAAA,uBAAAA,kBAAkB,EAChBpE,cAAcqE,YAAY,EAC1BP,UAAUxD,KAAK,EACfR;oBAGN;oBACA;gBACF;YACA,KAAK;gBAAiB;oBACpB,MAAMkE,iBAAiBhE,cAAciE,mBAAmB;oBACxD,IAAID,kBAAkBA,eAAeE,IAAI,GAAG,GAAG;wBAC7C,OAAOzF,qBACLqF,UAAUxD,KAAK,EACfR,YACAE,cAAcO,eAAe;oBAEjC;oBACA;gBACF;YACA,KAAK;gBACH,MAAM,OAAA,cAEL,CAFK,IAAI+D,gBAAAA,cAAc,CACtB,AAAC,EAAE,EAAsFxE,OAApFA,YAAW,uEAAuE,sBAAa,+EAA+E,CAAC,KADhL,qBAAA;2BAAA;gCAAA;kCAAA;gBAEN;YACF,KAAK;YACL,KAAK;gBACH,MAAM,OAAA,cAEL,CAFK,IAAIwE,gBAAAA,cAAc,CACtB,AAAC,EAAE,SAAExE,YAAW,iEAAiE,UAAEA,YAAW,+EAA+E,CAAC,KAD1K,qBAAA;2BAAA;gCAAA;kCAAA;gBAEN;YACF,KAAK;YACL,KAAK;YACL,KAAK;gBACH;YACF;gBACEE;QACJ;IACF;AACF;AAEA,MAAMuE,mBAAmB;AAEzB,uFAAuF;AACvF,MAAMC,sBACJ;AAEF,2EAA2E;AAC3E,+EAA+E;AAC/E,4FAA4F;AAC5F,EAAE;AACF,mBAAmB;AACnB,8BAA8B;AAC9B,mDAAmD;AACnD,EAAE;AACF,yEAAyE;AACzE,8BAA8B;AAC9B,mCAAmC;AACnC,mDAAmD;AACnD,MAAMC,4DAA4D,IAAIC,OACpE,AAAC,uDAAuD,UAAEF,qBAAoB,yCAAyC,WAAEG,mBAAAA,yBAAyB,EAAC,cAAc,CAAC;AAGpK,MAAMC,mBAAmB,IAAIF,OAC3B,AAAC,UAAU,UAAEG,mBAAAA,sBAAsB,EAAC,QAAQ,CAAC;AAE/C,MAAMC,mBAAmB,IAAIJ,OAC3B,AAAC,UAAU,UAAEK,mBAAAA,sBAAsB,EAAC,QAAQ,CAAC;AAE/C,MAAMC,iBAAiB,IAAIN,OAAO,AAAC,UAAU,GAAuB,OAArBO,CAA6B,CAAC,iBAA9BA,oBAAoB;AAE5D,SAASrG,0BACdkF,SAAoB,EACpBoB,cAAsB,EACtBC,iBAAyC,EACzCrC,aAAmC;IAEnC,IAAIkC,eAAeI,IAAI,CAACF,iBAAiB;QACvC,kGAAkG;QAClG;IACF,OAAO,IAAIN,iBAAiBQ,IAAI,CAACF,iBAAiB;QAChDC,kBAAkB1F,kBAAkB,GAAG;QACvC;IACF,OAAO,IAAIqF,iBAAiBM,IAAI,CAACF,iBAAiB;QAChDC,kBAAkBzF,kBAAkB,GAAG;QACvC;IACF,OAAO,IACL+E,0DAA0DW,IAAI,CAC5DF,iBAEF;QACA,+GAA+G;QAC/G,sGAAsG;QACtG,wGAAwG;QACxGC,kBAAkBxF,iBAAiB,GAAG;QACtCwF,kBAAkB3F,oBAAoB,GAAG;QACzC;IACF,OAAO,IAAI+E,iBAAiBa,IAAI,CAACF,iBAAiB;QAChD,wFAAwF;QACxF,gBAAgB;QAChBC,kBAAkBxF,iBAAiB,GAAG;QACtC;IACF,OAAO,IAAImD,cAAcvD,yBAAyB,EAAE;QAClD,qDAAqD;QACrD4F,kBAAkBvF,aAAa,CAAC6B,IAAI,CAClCqB,cAAcvD,yBAAyB;QAEzC;IACF,OAAO;QACL,MAAMgD,UAAU,AAAC,OAAO,UAAEuB,UAAUxD,KAAK,EAAC,2NAA2N,CAAC;QACtQ,MAAMe,QAAQgE,qCAAqC9C,SAAS2C;QAC5DC,kBAAkBvF,aAAa,CAAC6B,IAAI,CAACJ;QACrC;IACF;AACF;AAEA;;;CAGC,GACD,SAASgE,qCACP9C,OAAe,EACf2C,cAAsB;IAEtB,MAAMI,aACJxE,QAAQC,GAAG,CAACC,QAAQ,gCAAK,gBAAgB7B,OAAAA,OAAK,CAACoG,iBAAiB,GAC5DpG,OAAAA,OAAK,CAACoG,iBAAiB,KACvB;IAEN,MAAMlE,QAAQ,OAAA,cAAkB,CAAlB,IAAIK,MAAMa,UAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAiB;IAC/BlB,MAAMR,KAAK,GAAGQ,MAAMmE,IAAI,GAAG,OAAOjD,UAAW+C,gDAAAA,aAAcJ,cAAa;IACxE,OAAO7D;AACT;AAEO,IAAK7D,eAAAA,WAAAA,GAAAA,SAAAA,YAAAA;;;;WAAAA;;AAML,SAASe,0BACduF,SAAoB,EACpBzC,KAAY;IAEZa,QAAQb,KAAK,CAACA;IAEd,IAAI,CAACyC,UAAU2B,GAAG,EAAE;QAClB,IAAI3B,UAAU4B,sBAAsB,EAAE;YACpCxD,QAAQb,KAAK,CACX,AAAC,iIAAiI,CAAkB,OAAhByC,UAAUxD,KAAK,qBAA4C,CAAC;QAEpM,OAAO;YACL4B,QAAQb,KAAK,CAAC,AAAC,wKACuDyC,UAAUxD,KAAK,EAAC;QAExF;IACF;AACF;AAEO,SAAS5B,yBACdoF,SAAoB,EACpB6B,OAAqB,EACrBR,iBAAyC,EACzCtC,aAAmC;IAEnC,IAAI8C,YAAAA,GAA+B;QACjC,IAAIR,kBAAkB3F,oBAAoB,EAAE;YAC1C,6DAA6D;YAC7D,gEAAgE;YAChE,qEAAqE;YACrE;QACF;QAEA,IAAIqD,cAActD,yBAAyB,EAAE;YAC3C,qEAAqE;YACrE,oEAAoE;YACpE,gEAAgE;YAChEhB,0BACEuF,WACAjB,cAActD,yBAAyB;YAEzC,MAAM,IAAIc,yBAAAA,qBAAqB;QACjC;QAEA,oEAAoE;QACpE,sEAAsE;QACtE,uEAAuE;QACvE,MAAMT,gBAAgBuF,kBAAkBvF,aAAa;QACrD,IAAIA,cAAcgD,MAAM,GAAG,GAAG;YAC5B,IAAK,IAAIgD,IAAI,GAAGA,IAAIhG,cAAcgD,MAAM,EAAEgD,IAAK;gBAC7CrH,0BAA0BuF,WAAWlE,aAAa,CAACgG,EAAE;YACvD;YAEA,MAAM,IAAIvF,yBAAAA,qBAAqB;QACjC;QAEA,sEAAsE;QACtE,wDAAwD;QACxD,yEAAyE;QACzE,wDAAwD;QACxD,IAAI8E,kBAAkBzF,kBAAkB,EAAE;YACxCwC,QAAQb,KAAK,CACX,AAAC,OAAO,UAAEyC,UAAUxD,KAAK,EAAC,8QAA8Q,CAAC;YAE3S,MAAM,IAAID,yBAAAA,qBAAqB;QACjC;QAEA,IAAIsF,YAAAA,GAAgC;YAClC,6EAA6E;YAC7E,iFAAiF;YACjF,2CAA2C;YAC3CzD,QAAQb,KAAK,CACX,AAAC,OAAO,UAAEyC,UAAUxD,KAAK,EAAC,wGAAwG,CAAC;YAErI,MAAM,IAAID,yBAAAA,qBAAqB;QACjC;IACF,OAAO;QACL,IACE8E,kBAAkBxF,iBAAiB,KAAK,SACxCwF,kBAAkB1F,kBAAkB,EACpC;YACAyC,QAAQb,KAAK,CACX,AAAC,OAAO,GAAkB,OAAhByC,UAAUxD,KAAK,wOAA+P,CAAC;YAE3R,MAAM,IAAID,yBAAAA,qBAAqB;QACjC;IACF;AACF;AAEO,SAASnC,uBACdgD,cAA2C,EAC3C2E,MAAkB;IAElB,IAAI3E,eAAeyC,mBAAmB,EAAE;QACtC,OAAOzC,eAAeyC,mBAAmB,CAACD,IAAI,CAAC,IAAMmC;IACvD;IACA,OAAOA;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3833, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/unstable-rethrow.server.ts"],"sourcesContent":["import { isHangingPromiseRejectionError } from '../../server/dynamic-rendering-utils'\nimport { isPostpone } from '../../server/lib/router-utils/is-postpone'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isNextRouterError } from './is-next-router-error'\nimport { isDynamicPostpone } from '../../server/app-render/dynamic-rendering'\nimport { isDynamicServerError } from './hooks-server-context'\n\nexport function unstable_rethrow(error: unknown): void {\n  if (\n    isNextRouterError(error) ||\n    isBailoutToCSRError(error) ||\n    isDynamicServerError(error) ||\n    isDynamicPostpone(error) ||\n    isPostpone(error) ||\n    isHangingPromiseRejectionError(error)\n  ) {\n    throw error\n  }\n\n  if (error instanceof Error && 'cause' in error) {\n    unstable_rethrow(error.cause)\n  }\n}\n"],"names":["unstable_rethrow","error","isNextRouterError","isBailoutToCSRError","isDynamicServerError","isDynamicPostpone","isPostpone","isHangingPromiseRejectionError","Error","cause"],"mappings":";;;+BAOgBA,oBAAAA;;;eAAAA;;;uCAP+B;4BACpB;8BACS;mCACF;kCACA;oCACG;AAE9B,SAASA,iBAAiBC,KAAc;IAC7C,IACEC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACD,UAClBE,CAAAA,GAAAA,cAAAA,mBAAmB,EAACF,UACpBG,CAAAA,GAAAA,oBAAAA,oBAAoB,EAACH,UACrBI,CAAAA,GAAAA,kBAAAA,iBAAiB,EAACJ,UAClBK,CAAAA,GAAAA,YAAAA,UAAU,EAACL,UACXM,CAAAA,GAAAA,uBAAAA,8BAA8B,EAACN,QAC/B;QACA,MAAMA;IACR;IAEA,IAAIA,iBAAiBO,SAAS,WAAWP,OAAO;QAC9CD,iBAAiBC,MAAMQ,KAAK;IAC9B;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3867, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/unstable-rethrow.ts"],"sourcesContent":["/**\n * This function should be used to rethrow internal Next.js errors so that they can be handled by the framework.\n * When wrapping an API that uses errors to interrupt control flow, you should use this function before you do any error handling.\n * This function will rethrow the error if it is a Next.js error so it can be handled, otherwise it will do nothing.\n *\n * Read more: [Next.js Docs: `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)\n */\nexport const unstable_rethrow =\n  typeof window === 'undefined'\n    ? (\n        require('./unstable-rethrow.server') as typeof import('./unstable-rethrow.server')\n      ).unstable_rethrow\n    : (\n        require('./unstable-rethrow.browser') as typeof import('./unstable-rethrow.browser')\n      ).unstable_rethrow\n"],"names":["unstable_rethrow","window","require"],"mappings":"AAAA;;;;;;CAMC;;;+BACYA,oBAAAA;;;eAAAA;;;AAAN,MAAMA,mBACX,OAAOC,WAAW,cAEZC,QAAQ,qKACRF,gBAAgB,GAEhBE,QAAQ,sKACRF,gBAAgB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3894, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/navigation.react-server.ts"],"sourcesContent":["/** @internal */\nclass ReadonlyURLSearchParamsError extends Error {\n  constructor() {\n    super(\n      'Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams'\n    )\n  }\n}\n\nclass ReadonlyURLSearchParams extends URLSearchParams {\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  append() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  delete() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  set() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  sort() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n}\n\nexport function unstable_isUnrecognizedActionError(): boolean {\n  throw new Error(\n    '`unstable_isUnrecognizedActionError` can only be used on the client.'\n  )\n}\n\nexport { redirect, permanentRedirect } from './redirect'\nexport { RedirectType } from './redirect-error'\nexport { notFound } from './not-found'\nexport { forbidden } from './forbidden'\nexport { unauthorized } from './unauthorized'\nexport { unstable_rethrow } from './unstable-rethrow'\nexport { ReadonlyURLSearchParams }\n"],"names":["ReadonlyURLSearchParams","RedirectType","forbidden","notFound","permanentRedirect","redirect","unauthorized","unstable_isUnrecognizedActionError","unstable_rethrow","ReadonlyURLSearchParamsError","Error","constructor","URLSearchParams","append","delete","set","sort"],"mappings":"AAAA,cAAc;;;;;;;;;;;;;;;;;;;;;IAwCLA,uBAAuB,EAAA;eAAvBA;;IALAC,YAAY,EAAA;eAAZA,eAAAA,YAAY;;IAEZC,SAAS,EAAA;eAATA,WAAAA,SAAS;;IADTC,QAAQ,EAAA;eAARA,UAAAA,QAAQ;;IAFEC,iBAAiB,EAAA;eAAjBA,UAAAA,iBAAiB;;IAA3BC,QAAQ,EAAA;eAARA,UAAAA,QAAQ;;IAIRC,YAAY,EAAA;eAAZA,cAAAA,YAAY;;IAVLC,kCAAkC,EAAA;eAAlCA;;IAWPC,gBAAgB,EAAA;eAAhBA,iBAAAA,gBAAgB;;;0BALmB;+BACf;0BACJ;2BACC;8BACG;iCACI;AAtCjC,MAAMC,qCAAqCC;IACzCC,aAAc;QACZ,KAAK,CACH;IAEJ;AACF;AAEA,MAAMX,gCAAgCY;IACpC,wKAAwK,GACxKC,SAAS;QACP,MAAM,IAAIJ;IACZ;IACA,wKAAwK,GACxKK,SAAS;QACP,MAAM,IAAIL;IACZ;IACA,wKAAwK,GACxKM,MAAM;QACJ,MAAM,IAAIN;IACZ;IACA,wKAAwK,GACxKO,OAAO;QACL,MAAM,IAAIP;IACZ;AACF;AAEO,SAASF;IACd,MAAM,OAAA,cAEL,CAFK,IAAIG,MACR,yEADI,qBAAA;eAAA;oBAAA;sBAAA;IAEN;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3986, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/shared/lib/server-inserted-html.shared-runtime.tsx"],"sourcesContent":["'use client'\n\nimport React, { useContext } from 'react'\n\nexport type ServerInsertedHTMLHook = (callbacks: () => React.ReactNode) => void\n\n// Use `React.createContext` to avoid errors from the RSC checks because\n// it can't be imported directly in Server Components:\n//\n//   import { createContext } from 'react'\n//\n// More info: https://github.com/vercel/next.js/pull/40686\nexport const ServerInsertedHTMLContext =\n  React.createContext<ServerInsertedHTMLHook | null>(null as any)\n\nexport function useServerInsertedHTML(callback: () => React.ReactNode): void {\n  const addInsertedServerHTMLCallback = useContext(ServerInsertedHTMLContext)\n  // Should have no effects on client where there's no flush effects provider\n  if (addInsertedServerHTMLCallback) {\n    addInsertedServerHTMLCallback(callback)\n  }\n}\n"],"names":["ServerInsertedHTMLContext","useServerInsertedHTML","React","createContext","callback","addInsertedServerHTMLCallback","useContext"],"mappings":";;;;;;;;;;;;;;IAYaA,yBAAyB,EAAA;eAAzBA;;IAGGC,qBAAqB,EAAA;eAArBA;;;;iEAbkB;AAU3B,MAAMD,4BAAAA,WAAAA,GACXE,OAAAA,OAAK,CAACC,aAAa,CAAgC;AAE9C,SAASF,sBAAsBG,QAA+B;IACnE,MAAMC,gCAAgCC,CAAAA,GAAAA,OAAAA,UAAU,EAACN;IACjD,2EAA2E;IAC3E,IAAIK,+BAA+B;QACjCA,8BAA8BD;IAChC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4021, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/unrecognized-action-error.ts"],"sourcesContent":["export class UnrecognizedActionError extends Error {\n  constructor(...args: ConstructorParameters<typeof Error>) {\n    super(...args)\n    this.name = 'UnrecognizedActionError'\n  }\n}\n\n/**\n * Check whether a server action call failed because the server action was not recognized by the server.\n * This can happen if the client and the server are not from the same deployment.\n *\n * Example usage:\n * ```ts\n * try {\n *   await myServerAction();\n * } catch (err) {\n *   if (unstable_isUnrecognizedActionError(err)) {\n *     // The client is from a different deployment than the server.\n *     // Reloading the page will fix this mismatch.\n *     window.alert(\"Please refresh the page and try again\");\n *     return;\n *   }\n * }\n * ```\n * */\nexport function unstable_isUnrecognizedActionError(\n  error: unknown\n): error is UnrecognizedActionError {\n  return !!(\n    error &&\n    typeof error === 'object' &&\n    error instanceof UnrecognizedActionError\n  )\n}\n"],"names":["UnrecognizedActionError","unstable_isUnrecognizedActionError","Error","constructor","args","name","error"],"mappings":";;;;;;;;;;;;;;IAAaA,uBAAuB,EAAA;eAAvBA;;IAyBGC,kCAAkC,EAAA;eAAlCA;;;AAzBT,MAAMD,gCAAgCE;IAC3CC,YAAY,GAAGC,IAAyC,CAAE;QACxD,KAAK,IAAIA;QACT,IAAI,CAACC,IAAI,GAAG;IACd;AACF;AAoBO,SAASJ,mCACdK,KAAc;IAEd,OAAO,CAAC,CACNA,CAAAA,SACA,OAAOA,UAAU,YACjBA,iBAAiBN,uBAAsB;AAE3C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4062, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/bailout-to-client-rendering.ts"],"sourcesContent":["import { BailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { workAsyncStorage } from '../../server/app-render/work-async-storage.external'\nimport { workUnitAsyncStorage } from '../../server/app-render/work-unit-async-storage.external'\n\nexport function bailoutToClientRendering(reason: string): void | never {\n  const workStore = workAsyncStorage.getStore()\n\n  if (workStore?.forceStatic) return\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-runtime':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        throw new BailoutToCSRError(reason)\n      case 'request':\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n}\n"],"names":["bailoutToClientRendering","reason","workStore","workAsyncStorage","getStore","forceStatic","workUnitStore","workUnitAsyncStorage","type","BailoutToCSRError"],"mappings":";;;+BAIgBA,4BAAAA;;;eAAAA;;;8BAJkB;0CACD;8CACI;AAE9B,SAASA,yBAAyBC,MAAc;IACrD,MAAMC,YAAYC,0BAAAA,gBAAgB,CAACC,QAAQ;IAE3C,IAAIF,aAAAA,OAAAA,KAAAA,IAAAA,UAAWG,WAAW,EAAE;IAE5B,MAAMC,gBAAgBC,8BAAAA,oBAAoB,CAACH,QAAQ;IAEnD,IAAIE,eAAe;QACjB,OAAQA,cAAcE,IAAI;YACxB,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;gBACH,MAAM,OAAA,cAA6B,CAA7B,IAAIC,cAAAA,iBAAiB,CAACR,SAAtB,qBAAA;2BAAA;gCAAA;kCAAA;gBAA4B;YACpC,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;gBACH;YACF;gBACEK;QACJ;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4111, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/navigation.ts"],"sourcesContent":["import type { FlightRouterState } from '../../server/app-render/types'\nimport type { Params } from '../../server/request/params'\n\nimport { useContext, useMemo } from 'react'\nimport {\n  AppRouterContext,\n  LayoutRouterContext,\n  type AppRouterInstance,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport {\n  SearchParamsContext,\n  PathnameContext,\n  PathParamsContext,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport { getSegmentValue } from './router-reducer/reducers/get-segment-value'\nimport { PAGE_SEGMENT_KEY, DEFAULT_SEGMENT_KEY } from '../../shared/lib/segment'\nimport { ReadonlyURLSearchParams } from './navigation.react-server'\n\nconst useDynamicRouteParams =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/dynamic-rendering') as typeof import('../../server/app-render/dynamic-rendering')\n      ).useDynamicRouteParams\n    : undefined\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you *read* the current URL's search parameters.\n *\n * Learn more about [`URLSearchParams` on MDN](https://developer.mozilla.org/docs/Web/API/URLSearchParams)\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useSearchParams } from 'next/navigation'\n *\n * export default function Page() {\n *   const searchParams = useSearchParams()\n *   searchParams.get('foo') // returns 'bar' when ?foo=bar\n *   // ...\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSearchParams`](https://nextjs.org/docs/app/api-reference/functions/use-search-params)\n */\n// Client components API\nexport function useSearchParams(): ReadonlyURLSearchParams {\n  const searchParams = useContext(SearchParamsContext)\n\n  // In the case where this is `null`, the compat types added in\n  // `next-env.d.ts` will add a new overload that changes the return type to\n  // include `null`.\n  const readonlySearchParams = useMemo(() => {\n    if (!searchParams) {\n      // When the router is not ready in pages, we won't have the search params\n      // available.\n      return null\n    }\n\n    return new ReadonlyURLSearchParams(searchParams)\n  }, [searchParams]) as ReadonlyURLSearchParams\n\n  if (typeof window === 'undefined') {\n    // AsyncLocalStorage should not be included in the client bundle.\n    const { bailoutToClientRendering } =\n      require('./bailout-to-client-rendering') as typeof import('./bailout-to-client-rendering')\n    // TODO-APP: handle dynamic = 'force-static' here and on the client\n    bailoutToClientRendering('useSearchParams()')\n  }\n\n  return readonlySearchParams\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the current URL's pathname.\n *\n * @example\n * ```ts\n * \"use client\"\n * import { usePathname } from 'next/navigation'\n *\n * export default function Page() {\n *  const pathname = usePathname() // returns \"/dashboard\" on /dashboard?foo=bar\n *  // ...\n * }\n * ```\n *\n * Read more: [Next.js Docs: `usePathname`](https://nextjs.org/docs/app/api-reference/functions/use-pathname)\n */\n// Client components API\nexport function usePathname(): string {\n  useDynamicRouteParams?.('usePathname()')\n\n  // In the case where this is `null`, the compat types added in `next-env.d.ts`\n  // will add a new overload that changes the return type to include `null`.\n  return useContext(PathnameContext) as string\n}\n\n// Client components API\nexport {\n  ServerInsertedHTMLContext,\n  useServerInsertedHTML,\n} from '../../shared/lib/server-inserted-html.shared-runtime'\n\n/**\n *\n * This hook allows you to programmatically change routes inside [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components).\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useRouter } from 'next/navigation'\n *\n * export default function Page() {\n *  const router = useRouter()\n *  // ...\n *  router.push('/dashboard') // Navigate to /dashboard\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useRouter`](https://nextjs.org/docs/app/api-reference/functions/use-router)\n */\n// Client components API\nexport function useRouter(): AppRouterInstance {\n  const router = useContext(AppRouterContext)\n  if (router === null) {\n    throw new Error('invariant expected app router to be mounted')\n  }\n\n  return router\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read a route's dynamic params filled in by the current URL.\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useParams } from 'next/navigation'\n *\n * export default function Page() {\n *   // on /dashboard/[team] where pathname is /dashboard/nextjs\n *   const { team } = useParams() // team === \"nextjs\"\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useParams`](https://nextjs.org/docs/app/api-reference/functions/use-params)\n */\n// Client components API\nexport function useParams<T extends Params = Params>(): T {\n  useDynamicRouteParams?.('useParams()')\n\n  return useContext(PathParamsContext) as T\n}\n\n/** Get the canonical parameters from the current level to the leaf node. */\n// Client components API\nfunction getSelectedLayoutSegmentPath(\n  tree: FlightRouterState,\n  parallelRouteKey: string,\n  first = true,\n  segmentPath: string[] = []\n): string[] {\n  let node: FlightRouterState\n  if (first) {\n    // Use the provided parallel route key on the first parallel route\n    node = tree[1][parallelRouteKey]\n  } else {\n    // After first parallel route prefer children, if there's no children pick the first parallel route.\n    const parallelRoutes = tree[1]\n    node = parallelRoutes.children ?? Object.values(parallelRoutes)[0]\n  }\n\n  if (!node) return segmentPath\n  const segment = node[0]\n\n  let segmentValue = getSegmentValue(segment)\n\n  if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) {\n    return segmentPath\n  }\n\n  segmentPath.push(segmentValue)\n\n  return getSelectedLayoutSegmentPath(\n    node,\n    parallelRouteKey,\n    false,\n    segmentPath\n  )\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the active route segments **below** the Layout it is called from.\n *\n * @example\n * ```ts\n * 'use client'\n *\n * import { useSelectedLayoutSegments } from 'next/navigation'\n *\n * export default function ExampleClientComponent() {\n *   const segments = useSelectedLayoutSegments()\n *\n *   return (\n *     <ul>\n *       {segments.map((segment, index) => (\n *         <li key={index}>{segment}</li>\n *       ))}\n *     </ul>\n *   )\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSelectedLayoutSegments`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segments)\n */\n// Client components API\nexport function useSelectedLayoutSegments(\n  parallelRouteKey: string = 'children'\n): string[] {\n  useDynamicRouteParams?.('useSelectedLayoutSegments()')\n\n  const context = useContext(LayoutRouterContext)\n  // @ts-expect-error This only happens in `pages`. Type is overwritten in navigation.d.ts\n  if (!context) return null\n\n  return getSelectedLayoutSegmentPath(context.parentTree, parallelRouteKey)\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the active route segment **one level below** the Layout it is called from.\n *\n * @example\n * ```ts\n * 'use client'\n * import { useSelectedLayoutSegment } from 'next/navigation'\n *\n * export default function ExampleClientComponent() {\n *   const segment = useSelectedLayoutSegment()\n *\n *   return <p>Active segment: {segment}</p>\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSelectedLayoutSegment`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segment)\n */\n// Client components API\nexport function useSelectedLayoutSegment(\n  parallelRouteKey: string = 'children'\n): string | null {\n  useDynamicRouteParams?.('useSelectedLayoutSegment()')\n\n  const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey)\n\n  if (!selectedLayoutSegments || selectedLayoutSegments.length === 0) {\n    return null\n  }\n\n  const selectedLayoutSegment =\n    parallelRouteKey === 'children'\n      ? selectedLayoutSegments[0]\n      : selectedLayoutSegments[selectedLayoutSegments.length - 1]\n\n  // if the default slot is showing, we return null since it's not technically \"selected\" (it's a fallback)\n  // and returning an internal value like `__DEFAULT__` would be confusing.\n  return selectedLayoutSegment === DEFAULT_SEGMENT_KEY\n    ? null\n    : selectedLayoutSegment\n}\n\nexport { unstable_isUnrecognizedActionError } from './unrecognized-action-error'\n\n// Shared components APIs\nexport {\n  notFound,\n  forbidden,\n  unauthorized,\n  redirect,\n  permanentRedirect,\n  RedirectType,\n  ReadonlyURLSearchParams,\n  unstable_rethrow,\n} from './navigation.react-server'\n"],"names":["ReadonlyURLSearchParams","RedirectType","ServerInsertedHTMLContext","forbidden","notFound","permanentRedirect","redirect","unauthorized","unstable_isUnrecognizedActionError","unstable_rethrow","useParams","usePathname","useRouter","useSearchParams","useSelectedLayoutSegment","useSelectedLayoutSegments","useServerInsertedHTML","useDynamicRouteParams","window","require","undefined","searchParams","useContext","SearchParamsContext","readonlySearchParams","useMemo","bailoutToClientRendering","PathnameContext","router","AppRouterContext","Error","PathParamsContext","getSelectedLayoutSegmentPath","tree","parallelRouteKey","first","segmentPath","node","parallelRoutes","children","Object","values","segment","segmentValue","getSegmentValue","startsWith","PAGE_SEGMENT_KEY","push","context","LayoutRouterContext","parentTree","selectedLayoutSegments","length","selectedLayoutSegment","DEFAULT_SEGMENT_KEY"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4299, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/redirect-boundary.tsx"],"sourcesContent":["'use client'\nimport React, { useEffect } from 'react'\nimport type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'\nimport { useRouter } from './navigation'\nimport { getRedirectTypeFromError, getURLFromRedirectError } from './redirect'\nimport { RedirectType, isRedirectError } from './redirect-error'\n\ninterface RedirectBoundaryProps {\n  router: AppRouterInstance\n  children: React.ReactNode\n}\n\nfunction HandleRedirect({\n  redirect,\n  reset,\n  redirectType,\n}: {\n  redirect: string\n  redirectType: RedirectType\n  reset: () => void\n}) {\n  const router = useRouter()\n\n  useEffect(() => {\n    React.startTransition(() => {\n      if (redirectType === RedirectType.push) {\n        router.push(redirect, {})\n      } else {\n        router.replace(redirect, {})\n      }\n      reset()\n    })\n  }, [redirect, redirectType, reset, router])\n\n  return null\n}\n\nexport class RedirectErrorBoundary extends React.Component<\n  RedirectBoundaryProps,\n  { redirect: string | null; redirectType: RedirectType | null }\n> {\n  constructor(props: RedirectBoundaryProps) {\n    super(props)\n    this.state = { redirect: null, redirectType: null }\n  }\n\n  static getDerivedStateFromError(error: any) {\n    if (isRedirectError(error)) {\n      const url = getURLFromRedirectError(error)\n      const redirectType = getRedirectTypeFromError(error)\n      return { redirect: url, redirectType }\n    }\n    // Re-throw if error is not for redirect\n    throw error\n  }\n\n  // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\n  render(): React.ReactNode {\n    const { redirect, redirectType } = this.state\n    if (redirect !== null && redirectType !== null) {\n      return (\n        <HandleRedirect\n          redirect={redirect}\n          redirectType={redirectType}\n          reset={() => this.setState({ redirect: null })}\n        />\n      )\n    }\n\n    return this.props.children\n  }\n}\n\nexport function RedirectBoundary({ children }: { children: React.ReactNode }) {\n  const router = useRouter()\n  return (\n    <RedirectErrorBoundary router={router}>{children}</RedirectErrorBoundary>\n  )\n}\n"],"names":["RedirectBoundary","RedirectErrorBoundary","HandleRedirect","redirect","reset","redirectType","router","useRouter","useEffect","React","startTransition","RedirectType","push","replace","Component","getDerivedStateFromError","error","isRedirectError","url","getURLFromRedirectError","getRedirectTypeFromError","render","state","setState","props","children","constructor"],"mappings":";;;;;;;;;;;;;;IAyEgBA,gBAAgB,EAAA;eAAhBA;;IApCHC,qBAAqB,EAAA;eAArBA;;;;;iEApCoB;4BAEP;0BACwC;+BACpB;AAO9C,SAASC,eAAe,KAQvB;IARuB,IAAA,EACtBC,QAAQ,EACRC,KAAK,EACLC,YAAY,EAKb,GARuB;IAStB,MAAMC,SAASC,CAAAA,GAAAA,YAAAA,SAAS;IAExBC,CAAAA,GAAAA,OAAAA,SAAS,EAAC;QACRC,OAAAA,OAAK,CAACC,eAAe,CAAC;YACpB,IAAIL,iBAAiBM,eAAAA,YAAY,CAACC,IAAI,EAAE;gBACtCN,OAAOM,IAAI,CAACT,UAAU,CAAC;YACzB,OAAO;gBACLG,OAAOO,OAAO,CAACV,UAAU,CAAC;YAC5B;YACAC;QACF;IACF,GAAG;QAACD;QAAUE;QAAcD;QAAOE;KAAO;IAE1C,OAAO;AACT;AAEO,MAAML,8BAA8BQ,OAAAA,OAAK,CAACK,SAAS;IASxD,OAAOC,yBAAyBC,KAAU,EAAE;QAC1C,IAAIC,CAAAA,GAAAA,eAAAA,eAAe,EAACD,QAAQ;YAC1B,MAAME,MAAMC,CAAAA,GAAAA,UAAAA,uBAAuB,EAACH;YACpC,MAAMX,eAAee,CAAAA,GAAAA,UAAAA,wBAAwB,EAACJ;YAC9C,OAAO;gBAAEb,UAAUe;gBAAKb;YAAa;QACvC;QACA,wCAAwC;QACxC,MAAMW;IACR;IAEA,yIAAyI;IACzIK,SAA0B;QACxB,MAAM,EAAElB,QAAQ,EAAEE,YAAY,EAAE,GAAG,IAAI,CAACiB,KAAK;QAC7C,IAAInB,aAAa,QAAQE,iBAAiB,MAAM;YAC9C,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACH,gBAAAA;gBACCC,UAAUA;gBACVE,cAAcA;gBACdD,OAAO,IAAM,IAAI,CAACmB,QAAQ,CAAC;wBAAEpB,UAAU;oBAAK;;QAGlD;QAEA,OAAO,IAAI,CAACqB,KAAK,CAACC,QAAQ;IAC5B;IA7BAC,YAAYF,KAA4B,CAAE;QACxC,KAAK,CAACA;QACN,IAAI,CAACF,KAAK,GAAG;YAAEnB,UAAU;YAAME,cAAc;QAAK;IACpD;AA2BF;AAEO,SAASL,iBAAiB,KAA2C;IAA3C,IAAA,EAAEyB,QAAQ,EAAiC,GAA3C;IAC/B,MAAMnB,SAASC,CAAAA,GAAAA,YAAAA,SAAS;IACxB,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACN,uBAAAA;QAAsBK,QAAQA;kBAASmB;;AAE5C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4400, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/http-access-fallback/error-boundary.tsx"],"sourcesContent":["'use client'\n\n/**\n * HTTPAccessFallbackBoundary is a boundary that catches errors and renders a\n * fallback component for HTTP errors.\n *\n * It receives the status code, and determine if it should render fallbacks for few HTTP 4xx errors.\n *\n * e.g. 404\n * 404 represents not found, and the fallback component pair contains the component and its styles.\n *\n */\n\nimport React, { useContext } from 'react'\nimport { useUntrackedPathname } from '../navigation-untracked'\nimport {\n  HTTPAccessErrorStatus,\n  getAccessFallbackHTTPStatus,\n  getAccessFallbackErrorTypeByStatus,\n  isHTTPAccessFallbackError,\n} from './http-access-fallback'\nimport { warnOnce } from '../../../shared/lib/utils/warn-once'\nimport { MissingSlotContext } from '../../../shared/lib/app-router-context.shared-runtime'\n\ninterface HTTPAccessFallbackBoundaryProps {\n  notFound?: React.ReactNode\n  forbidden?: React.ReactNode\n  unauthorized?: React.ReactNode\n  children: React.ReactNode\n  missingSlots?: Set<string>\n}\n\ninterface HTTPAccessFallbackErrorBoundaryProps\n  extends HTTPAccessFallbackBoundaryProps {\n  pathname: string | null\n  missingSlots?: Set<string>\n}\n\ninterface HTTPAccessBoundaryState {\n  triggeredStatus: number | undefined\n  previousPathname: string | null\n}\n\nclass HTTPAccessFallbackErrorBoundary extends React.Component<\n  HTTPAccessFallbackErrorBoundaryProps,\n  HTTPAccessBoundaryState\n> {\n  constructor(props: HTTPAccessFallbackErrorBoundaryProps) {\n    super(props)\n    this.state = {\n      triggeredStatus: undefined,\n      previousPathname: props.pathname,\n    }\n  }\n\n  componentDidCatch(): void {\n    if (\n      process.env.NODE_ENV === 'development' &&\n      this.props.missingSlots &&\n      this.props.missingSlots.size > 0 &&\n      // A missing children slot is the typical not-found case, so no need to warn\n      !this.props.missingSlots.has('children')\n    ) {\n      let warningMessage =\n        'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.\\n' +\n        'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs\\n\\n'\n\n      const formattedSlots = Array.from(this.props.missingSlots)\n        .sort((a, b) => a.localeCompare(b))\n        .map((slot) => `@${slot}`)\n        .join(', ')\n\n      warningMessage += 'Missing slots: ' + formattedSlots\n\n      warnOnce(warningMessage)\n    }\n  }\n\n  static getDerivedStateFromError(error: any) {\n    if (isHTTPAccessFallbackError(error)) {\n      const httpStatus = getAccessFallbackHTTPStatus(error)\n      return {\n        triggeredStatus: httpStatus,\n      }\n    }\n    // Re-throw if error is not for 404\n    throw error\n  }\n\n  static getDerivedStateFromProps(\n    props: HTTPAccessFallbackErrorBoundaryProps,\n    state: HTTPAccessBoundaryState\n  ): HTTPAccessBoundaryState | null {\n    /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */\n    if (props.pathname !== state.previousPathname && state.triggeredStatus) {\n      return {\n        triggeredStatus: undefined,\n        previousPathname: props.pathname,\n      }\n    }\n    return {\n      triggeredStatus: state.triggeredStatus,\n      previousPathname: props.pathname,\n    }\n  }\n\n  render() {\n    const { notFound, forbidden, unauthorized, children } = this.props\n    const { triggeredStatus } = this.state\n    const errorComponents = {\n      [HTTPAccessErrorStatus.NOT_FOUND]: notFound,\n      [HTTPAccessErrorStatus.FORBIDDEN]: forbidden,\n      [HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized,\n    }\n\n    if (triggeredStatus) {\n      const isNotFound =\n        triggeredStatus === HTTPAccessErrorStatus.NOT_FOUND && notFound\n      const isForbidden =\n        triggeredStatus === HTTPAccessErrorStatus.FORBIDDEN && forbidden\n      const isUnauthorized =\n        triggeredStatus === HTTPAccessErrorStatus.UNAUTHORIZED && unauthorized\n\n      // If there's no matched boundary in this layer, keep throwing the error by rendering the children\n      if (!(isNotFound || isForbidden || isUnauthorized)) {\n        return children\n      }\n\n      return (\n        <>\n          <meta name=\"robots\" content=\"noindex\" />\n          {process.env.NODE_ENV === 'development' && (\n            <meta\n              name=\"boundary-next-error\"\n              content={getAccessFallbackErrorTypeByStatus(triggeredStatus)}\n            />\n          )}\n          {errorComponents[triggeredStatus]}\n        </>\n      )\n    }\n\n    return children\n  }\n}\n\nexport function HTTPAccessFallbackBoundary({\n  notFound,\n  forbidden,\n  unauthorized,\n  children,\n}: HTTPAccessFallbackBoundaryProps) {\n  // When we're rendering the missing params shell, this will return null. This\n  // is because we won't be rendering any not found boundaries or error\n  // boundaries for the missing params shell. When this runs on the client\n  // (where these error can occur), we will get the correct pathname.\n  const pathname = useUntrackedPathname()\n  const missingSlots = useContext(MissingSlotContext)\n  const hasErrorFallback = !!(notFound || forbidden || unauthorized)\n\n  if (hasErrorFallback) {\n    return (\n      <HTTPAccessFallbackErrorBoundary\n        pathname={pathname}\n        notFound={notFound}\n        forbidden={forbidden}\n        unauthorized={unauthorized}\n        missingSlots={missingSlots}\n      >\n        {children}\n      </HTTPAccessFallbackErrorBoundary>\n    )\n  }\n\n  return <>{children}</>\n}\n"],"names":["HTTPAccessFallbackBoundary","HTTPAccessFallbackErrorBoundary","React","Component","componentDidCatch","process","env","NODE_ENV","props","missingSlots","size","has","warningMessage","formattedSlots","Array","from","sort","a","b","localeCompare","map","slot","join","warnOnce","getDerivedStateFromError","error","isHTTPAccessFallbackError","httpStatus","getAccessFallbackHTTPStatus","triggeredStatus","getDerivedStateFromProps","state","pathname","previousPathname","undefined","render","notFound","forbidden","unauthorized","children","errorComponents","HTTPAccessErrorStatus","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","isNotFound","isForbidden","isUnauthorized","meta","name","content","getAccessFallbackErrorTypeByStatus","constructor","useUntrackedPathname","useContext","MissingSlotContext","hasErrorFallback"],"mappings":"AAyDMK,QAAQC,GAAG,CAACC,QAAQ;AAzD1B;;;;;+BAuJgBP,8BAAAA;;;eAAAA;;;;;iEA1IkB;qCACG;oCAM9B;0BACkB;+CACU;AAqBnC,MAAMC,wCAAwCC,OAAAA,OAAK,CAACC,SAAS;IAY3DC,oBAA0B;QACxB,wDAC2B,iBACzB,IAAI,CAACI,KAAK,CAACC,YAAY,IACvB,IAAI,CAACD,KAAK,CAACC,YAAY,CAACC,IAAI,GAAG,KAC/B,4EAA4E;QAC5E,CAAC,IAAI,CAACF,KAAK,CAACC,YAAY,CAACE,GAAG,CAAC,aAC7B;YACA,IAAIC,iBACF,4HACA;YAEF,MAAMC,iBAAiBC,MAAMC,IAAI,CAAC,IAAI,CAACP,KAAK,CAACC,YAAY,EACtDO,IAAI,CAAC,CAACC,GAAGC,IAAMD,EAAEE,aAAa,CAACD,IAC/BE,GAAG,CAAC,CAACC,OAAU,MAAGA,MAClBC,IAAI,CAAC;YAERV,kBAAkB,oBAAoBC;YAEtCU,CAAAA,GAAAA,UAAAA,QAAQ,EAACX;QACX;IACF;IAEA,OAAOY,yBAAyBC,KAAU,EAAE;QAC1C,IAAIC,CAAAA,GAAAA,oBAAAA,yBAAyB,EAACD,QAAQ;YACpC,MAAME,aAAaC,CAAAA,GAAAA,oBAAAA,2BAA2B,EAACH;YAC/C,OAAO;gBACLI,iBAAiBF;YACnB;QACF;QACA,mCAAmC;QACnC,MAAMF;IACR;IAEA,OAAOK,yBACLtB,KAA2C,EAC3CuB,KAA8B,EACE;QAChC;;;;;KAKC,GACD,IAAIvB,MAAMwB,QAAQ,KAAKD,MAAME,gBAAgB,IAAIF,MAAMF,eAAe,EAAE;YACtE,OAAO;gBACLA,iBAAiBK;gBACjBD,kBAAkBzB,MAAMwB,QAAQ;YAClC;QACF;QACA,OAAO;YACLH,iBAAiBE,MAAMF,eAAe;YACtCI,kBAAkBzB,MAAMwB,QAAQ;QAClC;IACF;IAEAG,SAAS;QACP,MAAM,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,YAAY,EAAEC,QAAQ,EAAE,GAAG,IAAI,CAAC/B,KAAK;QAClE,MAAM,EAAEqB,eAAe,EAAE,GAAG,IAAI,CAACE,KAAK;QACtC,MAAMS,kBAAkB;YACtB,CAACC,oBAAAA,qBAAqB,CAACC,SAAS,CAAC,EAAEN;YACnC,CAACK,oBAAAA,qBAAqB,CAACE,SAAS,CAAC,EAAEN;YACnC,CAACI,oBAAAA,qBAAqB,CAACG,YAAY,CAAC,EAAEN;QACxC;QAEA,IAAIT,iBAAiB;YACnB,MAAMgB,aACJhB,oBAAoBY,oBAAAA,qBAAqB,CAACC,SAAS,IAAIN;YACzD,MAAMU,cACJjB,oBAAoBY,oBAAAA,qBAAqB,CAACE,SAAS,IAAIN;YACzD,MAAMU,iBACJlB,oBAAoBY,oBAAAA,qBAAqB,CAACG,YAAY,IAAIN;YAE5D,kGAAkG;YAClG,IAAI,CAAEO,CAAAA,cAAcC,eAAeC,cAAa,GAAI;gBAClD,OAAOR;YACT;YAEA,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,IAAA,EAAA,YAAA,QAAA,EAAA;;kCACE,CAAA,GAAA,YAAA,GAAA,EAACS,QAAAA;wBAAKC,MAAK;wBAASC,SAAQ;;oBAC3B7C,QAAQC,GAAG,CAACC,QAAQ,gCAAK,iBAAA,WAAA,GACxB,CAAA,GAAA,YAAA,GAAA,EAACyC,QAAAA;wBACCC,MAAK;wBACLC,SAASC,CAAAA,GAAAA,oBAAAA,kCAAkC,EAACtB;;oBAG/CW,eAAe,CAACX,gBAAgB;;;QAGvC;QAEA,OAAOU;IACT;IArGAa,YAAY5C,KAA2C,CAAE;QACvD,KAAK,CAACA;QACN,IAAI,CAACuB,KAAK,GAAG;YACXF,iBAAiBK;YACjBD,kBAAkBzB,MAAMwB,QAAQ;QAClC;IACF;AAgGF;AAEO,SAAShC,2BAA2B,KAKT;IALS,IAAA,EACzCoC,QAAQ,EACRC,SAAS,EACTC,YAAY,EACZC,QAAQ,EACwB,GALS;IAMzC,6EAA6E;IAC7E,qEAAqE;IACrE,wEAAwE;IACxE,mEAAmE;IACnE,MAAMP,WAAWqB,CAAAA,GAAAA,qBAAAA,oBAAoB;IACrC,MAAM5C,eAAe6C,CAAAA,GAAAA,OAAAA,UAAU,EAACC,+BAAAA,kBAAkB;IAClD,MAAMC,mBAAmB,CAAC,CAAEpB,CAAAA,YAAYC,aAAaC,YAAW;IAEhE,IAAIkB,kBAAkB;QACpB,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACvD,iCAAAA;YACC+B,UAAUA;YACVI,UAAUA;YACVC,WAAWA;YACXC,cAAcA;YACd7B,cAAcA;sBAEb8B;;IAGP;IAEA,OAAA,WAAA,GAAO,CAAA,GAAA,YAAA,GAAA,EAAA,YAAA,QAAA,EAAA;kBAAGA;;AACZ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4530, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/router-reducer/create-router-cache-key.ts"],"sourcesContent":["import type { Segment } from '../../../server/app-render/types'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\nexport function createRouterCacheKey(\n  segment: Segment,\n  withoutSearchParameters: boolean = false\n) {\n  // if the segment is an array, it means it's a dynamic segment\n  // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.\n  if (Array.isArray(segment)) {\n    return `${segment[0]}|${segment[1]}|${segment[2]}`\n  }\n\n  // Page segments might have search parameters, ie __PAGE__?foo=bar\n  // When `withoutSearchParameters` is true, we only want to return the page segment\n  if (withoutSearchParameters && segment.startsWith(PAGE_SEGMENT_KEY)) {\n    return PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n"],"names":["createRouterCacheKey","segment","withoutSearchParameters","Array","isArray","startsWith","PAGE_SEGMENT_KEY"],"mappings":";;;+BAGgBA,wBAAAA;;;eAAAA;;;yBAFiB;AAE1B,SAASA,qBACdC,OAAgB,EAChBC,uBAAwC;IAAxCA,IAAAA,4BAAAA,KAAAA,GAAAA,0BAAmC;IAEnC,8DAA8D;IAC9D,uGAAuG;IACvG,IAAIC,MAAMC,OAAO,CAACH,UAAU;QAC1B,OAAUA,OAAO,CAAC,EAAE,GAAC,MAAGA,OAAO,CAAC,EAAE,GAAC,MAAGA,OAAO,CAAC,EAAE;IAClD;IAEA,kEAAkE;IAClE,kFAAkF;IAClF,IAAIC,2BAA2BD,QAAQI,UAAU,CAACC,SAAAA,gBAAgB,GAAG;QACnE,OAAOA,SAAAA,gBAAgB;IACzB;IAEA,OAAOL;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4565, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/shared/lib/page-path/ensure-leading-slash.ts"],"sourcesContent":["/**\n * For a given page path, this function ensures that there is a leading slash.\n * If there is not a leading slash, one is added, otherwise it is noop.\n */\nexport function ensureLeadingSlash(path: string) {\n  return path.startsWith('/') ? path : `/${path}`\n}\n"],"names":["ensureLeadingSlash","path","startsWith"],"mappings":"AAAA;;;CAGC;;;+BACeA,sBAAAA;;;eAAAA;;;AAAT,SAASA,mBAAmBC,IAAY;IAC7C,OAAOA,KAAKC,UAAU,CAAC,OAAOD,OAAQ,MAAGA;AAC3C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4584, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/shared/lib/router/utils/app-paths.ts"],"sourcesContent":["import { ensureLeadingSlash } from '../../page-path/ensure-leading-slash'\nimport { isGroupSegment } from '../../segment'\n\n/**\n * Normalizes an app route so it represents the actual request path. Essentially\n * performing the following transformations:\n *\n * - `/(dashboard)/user/[id]/page` to `/user/[id]`\n * - `/(dashboard)/account/page` to `/account`\n * - `/user/[id]/page` to `/user/[id]`\n * - `/account/page` to `/account`\n * - `/page` to `/`\n * - `/(dashboard)/user/[id]/route` to `/user/[id]`\n * - `/(dashboard)/account/route` to `/account`\n * - `/user/[id]/route` to `/user/[id]`\n * - `/account/route` to `/account`\n * - `/route` to `/`\n * - `/` to `/`\n *\n * @param route the app route to normalize\n * @returns the normalized pathname\n */\nexport function normalizeAppPath(route: string) {\n  return ensureLeadingSlash(\n    route.split('/').reduce((pathname, segment, index, segments) => {\n      // Empty segments are ignored.\n      if (!segment) {\n        return pathname\n      }\n\n      // Groups are ignored.\n      if (isGroupSegment(segment)) {\n        return pathname\n      }\n\n      // Parallel segments are ignored.\n      if (segment[0] === '@') {\n        return pathname\n      }\n\n      // The last segment (if it's a leaf) should be ignored.\n      if (\n        (segment === 'page' || segment === 'route') &&\n        index === segments.length - 1\n      ) {\n        return pathname\n      }\n\n      return `${pathname}/${segment}`\n    }, '')\n  )\n}\n\n/**\n * Strips the `.rsc` extension if it's in the pathname.\n * Since this function is used on full urls it checks `?` for searchParams handling.\n */\nexport function normalizeRscURL(url: string) {\n  return url.replace(\n    /\\.rsc($|\\?)/,\n    // $1 ensures `?` is preserved\n    '$1'\n  )\n}\n"],"names":["normalizeAppPath","normalizeRscURL","route","ensureLeadingSlash","split","reduce","pathname","segment","index","segments","isGroupSegment","length","url","replace"],"mappings":";;;;;;;;;;;;;;IAsBgBA,gBAAgB,EAAA;eAAhBA;;IAmCAC,eAAe,EAAA;eAAfA;;;oCAzDmB;yBACJ;AAqBxB,SAASD,iBAAiBE,KAAa;IAC5C,OAAOC,CAAAA,GAAAA,oBAAAA,kBAAkB,EACvBD,MAAME,KAAK,CAAC,KAAKC,MAAM,CAAC,CAACC,UAAUC,SAASC,OAAOC;QACjD,8BAA8B;QAC9B,IAAI,CAACF,SAAS;YACZ,OAAOD;QACT;QAEA,sBAAsB;QACtB,IAAII,CAAAA,GAAAA,SAAAA,cAAc,EAACH,UAAU;YAC3B,OAAOD;QACT;QAEA,iCAAiC;QACjC,IAAIC,OAAO,CAAC,EAAE,KAAK,KAAK;YACtB,OAAOD;QACT;QAEA,uDAAuD;QACvD,IACGC,CAAAA,YAAY,UAAUA,YAAY,OAAM,KACzCC,UAAUC,SAASE,MAAM,GAAG,GAC5B;YACA,OAAOL;QACT;QAEA,OAAUA,WAAS,MAAGC;IACxB,GAAG;AAEP;AAMO,SAASN,gBAAgBW,GAAW;IACzC,OAAOA,IAAIC,OAAO,CAChB,eACA,AACA,8BAD8B;AAGlC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4635, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/shared/lib/router/utils/interception-routes.ts"],"sourcesContent":["import { normalizeAppPath } from './app-paths'\n\n// order matters here, the first match will be used\nexport const INTERCEPTION_ROUTE_MARKERS = [\n  '(..)(..)',\n  '(.)',\n  '(..)',\n  '(...)',\n] as const\n\nexport function isInterceptionRouteAppPath(path: string): boolean {\n  // TODO-APP: add more serious validation\n  return (\n    path\n      .split('/')\n      .find((segment) =>\n        INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n      ) !== undefined\n  )\n}\n\nexport function extractInterceptionRouteInformation(path: string) {\n  let interceptingRoute: string | undefined,\n    marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined,\n    interceptedRoute: string | undefined\n\n  for (const segment of path.split('/')) {\n    marker = INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n    if (marker) {\n      ;[interceptingRoute, interceptedRoute] = path.split(marker, 2)\n      break\n    }\n  }\n\n  if (!interceptingRoute || !marker || !interceptedRoute) {\n    throw new Error(\n      `Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`\n    )\n  }\n\n  interceptingRoute = normalizeAppPath(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\n\n  switch (marker) {\n    case '(.)':\n      // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\n      if (interceptingRoute === '/') {\n        interceptedRoute = `/${interceptedRoute}`\n      } else {\n        interceptedRoute = interceptingRoute + '/' + interceptedRoute\n      }\n      break\n    case '(..)':\n      // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\n      if (interceptingRoute === '/') {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`\n        )\n      }\n      interceptedRoute = interceptingRoute\n        .split('/')\n        .slice(0, -1)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    case '(...)':\n      // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\n      interceptedRoute = '/' + interceptedRoute\n      break\n    case '(..)(..)':\n      // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\n\n      const splitInterceptingRoute = interceptingRoute.split('/')\n      if (splitInterceptingRoute.length <= 2) {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`\n        )\n      }\n\n      interceptedRoute = splitInterceptingRoute\n        .slice(0, -2)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    default:\n      throw new Error('Invariant: unexpected marker')\n  }\n\n  return { interceptingRoute, interceptedRoute }\n}\n"],"names":["INTERCEPTION_ROUTE_MARKERS","extractInterceptionRouteInformation","isInterceptionRouteAppPath","path","split","find","segment","m","startsWith","undefined","interceptingRoute","marker","interceptedRoute","Error","normalizeAppPath","slice","concat","join","splitInterceptingRoute","length"],"mappings":";;;;;;;;;;;;;;;IAGaA,0BAA0B,EAAA;eAA1BA;;IAkBGC,mCAAmC,EAAA;eAAnCA;;IAXAC,0BAA0B,EAAA;eAA1BA;;;0BAViB;AAG1B,MAAMF,6BAA6B;IACxC;IACA;IACA;IACA;CACD;AAEM,SAASE,2BAA2BC,IAAY;IACrD,wCAAwC;IACxC,OACEA,KACGC,KAAK,CAAC,KACNC,IAAI,CAAC,CAACC,UACLN,2BAA2BK,IAAI,CAAC,CAACE,IAAMD,QAAQE,UAAU,CAACD,SACtDE;AAEZ;AAEO,SAASR,oCAAoCE,IAAY;IAC9D,IAAIO,mBACFC,QACAC;IAEF,KAAK,MAAMN,WAAWH,KAAKC,KAAK,CAAC,KAAM;QACrCO,SAASX,2BAA2BK,IAAI,CAAC,CAACE,IAAMD,QAAQE,UAAU,CAACD;QACnE,IAAII,QAAQ;;YACT,CAACD,mBAAmBE,iBAAiB,GAAGT,KAAKC,KAAK,CAACO,QAAQ;YAC5D;QACF;IACF;IAEA,IAAI,CAACD,qBAAqB,CAACC,UAAU,CAACC,kBAAkB;QACtD,MAAM,OAAA,cAEL,CAFK,IAAIC,MACP,iCAA8BV,OAAK,sFADhC,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEAO,oBAAoBI,CAAAA,GAAAA,UAAAA,gBAAgB,EAACJ,mBAAmB,iDAAiD;;IAEzG,OAAQC;QACN,KAAK;YACH,oIAAoI;YACpI,IAAID,sBAAsB,KAAK;gBAC7BE,mBAAoB,MAAGA;YACzB,OAAO;gBACLA,mBAAmBF,oBAAoB,MAAME;YAC/C;YACA;QACF,KAAK;YACH,uHAAuH;YACvH,IAAIF,sBAAsB,KAAK;gBAC7B,MAAM,OAAA,cAEL,CAFK,IAAIG,MACP,iCAA8BV,OAAK,iEADhC,qBAAA;2BAAA;gCAAA;kCAAA;gBAEN;YACF;YACAS,mBAAmBF,kBAChBN,KAAK,CAAC,KACNW,KAAK,CAAC,GAAG,CAAC,GACVC,MAAM,CAACJ,kBACPK,IAAI,CAAC;YACR;QACF,KAAK;YACH,kIAAkI;YAClIL,mBAAmB,MAAMA;YACzB;QACF,KAAK;YACH,iIAAiI;YAEjI,MAAMM,yBAAyBR,kBAAkBN,KAAK,CAAC;YACvD,IAAIc,uBAAuBC,MAAM,IAAI,GAAG;gBACtC,MAAM,OAAA,cAEL,CAFK,IAAIN,MACP,iCAA8BV,OAAK,oEADhC,qBAAA;2BAAA;gCAAA;kCAAA;gBAEN;YACF;YAEAS,mBAAmBM,uBAChBH,KAAK,CAAC,GAAG,CAAC,GACVC,MAAM,CAACJ,kBACPK,IAAI,CAAC;YACR;QACF;YACE,MAAM,OAAA,cAAyC,CAAzC,IAAIJ,MAAM,iCAAV,qBAAA;uBAAA;4BAAA;8BAAA;YAAwC;IAClD;IAEA,OAAO;QAAEH;QAAmBE;IAAiB;AAC/C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4742, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/router-reducer/reducers/has-interception-route-in-current-tree.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../../server/app-render/types'\nimport { isInterceptionRouteAppPath } from '../../../../shared/lib/router/utils/interception-routes'\n\nexport function hasInterceptionRouteInCurrentTree([\n  segment,\n  parallelRoutes,\n]: FlightRouterState): boolean {\n  // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.\n  if (Array.isArray(segment) && (segment[2] === 'di' || segment[2] === 'ci')) {\n    return true\n  }\n\n  // If segment is not an array, apply the existing string-based check\n  if (typeof segment === 'string' && isInterceptionRouteAppPath(segment)) {\n    return true\n  }\n\n  // Iterate through parallelRoutes if they exist\n  if (parallelRoutes) {\n    for (const key in parallelRoutes) {\n      if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n"],"names":["hasInterceptionRouteInCurrentTree","segment","parallelRoutes","Array","isArray","isInterceptionRouteAppPath","key"],"mappings":";;;+BAGgBA,qCAAAA;;;eAAAA;;;oCAF2B;AAEpC,SAASA,kCAAkC,KAG9B;IAH8B,IAAA,CAChDC,SACAC,eACkB,GAH8B;IAIhD,wGAAwG;IACxG,IAAIC,MAAMC,OAAO,CAACH,YAAaA,CAAAA,OAAO,CAAC,EAAE,KAAK,QAAQA,OAAO,CAAC,EAAE,KAAK,IAAG,GAAI;QAC1E,OAAO;IACT;IAEA,oEAAoE;IACpE,IAAI,OAAOA,YAAY,YAAYI,CAAAA,GAAAA,oBAAAA,0BAA0B,EAACJ,UAAU;QACtE,OAAO;IACT;IAEA,+CAA+C;IAC/C,IAAIC,gBAAgB;QAClB,IAAK,MAAMI,OAAOJ,eAAgB;YAChC,IAAIF,kCAAkCE,cAAc,CAACI,IAAI,GAAG;gBAC1D,OAAO;YACT;QACF;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4783, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/bfcache.ts"],"sourcesContent":["import type { FlightRouterState } from '../../server/app-render/types'\nimport { useState } from 'react'\n\n// When the flag is disabled, only track the currently active tree\nconst MAX_BF_CACHE_ENTRIES = process.env.__NEXT_ROUTER_BF_CACHE ? 3 : 1\n\nexport type RouterBFCacheEntry = {\n  tree: FlightRouterState\n  stateKey: string\n  // The entries form a linked list, sorted in order of most recently active.\n  next: RouterBFCacheEntry | null\n}\n\n/**\n * Keeps track of the most recent N trees (FlightRouterStates) that were active\n * at a certain segment level. E.g. for a segment \"/a/b/[param]\", this hook\n * tracks the last N param values that the router rendered for N.\n *\n * The result of this hook precisely determines the number and order of\n * trees that are rendered in parallel at their segment level.\n *\n * The purpose of this cache is to we can preserve the React and DOM state of\n * some number of inactive trees, by rendering them in an <Activity> boundary.\n * That means it would not make sense for the the lifetime of the cache to be\n * any longer than the lifetime of the React tree; e.g. if the hook were\n * unmounted, then the React tree would be, too. So, we use React state to\n * manage it.\n *\n * Note that we don't store the RSC data for the cache entries in this hook —\n * the data for inactive segments is stored in the parent CacheNode, which\n * *does* have a longer lifetime than the React tree. This hook only determines\n * which of those trees should have their *state* preserved, by <Activity>.\n */\nexport function useRouterBFCache(\n  activeTree: FlightRouterState,\n  activeStateKey: string\n): RouterBFCacheEntry {\n  // The currently active entry. The entries form a linked list, sorted in\n  // order of most recently active. This allows us to reuse parts of the list\n  // without cloning, unless there's a reordering or removal.\n  // TODO: Once we start tracking back/forward history at each route level,\n  // we should use the history order instead. In other words, when traversing\n  // to an existing entry as a result of a popstate event, we should maintain\n  // the existing order instead of moving it to the front of the list. I think\n  // an initial implementation of this could be to pass an incrementing id\n  // to history.pushState/replaceState, then use that here for ordering.\n  const [prevActiveEntry, setPrevActiveEntry] = useState<RouterBFCacheEntry>(\n    () => {\n      const initialEntry: RouterBFCacheEntry = {\n        tree: activeTree,\n        stateKey: activeStateKey,\n        next: null,\n      }\n      return initialEntry\n    }\n  )\n\n  if (prevActiveEntry.tree === activeTree) {\n    // Fast path. The active tree hasn't changed, so we can reuse the\n    // existing state.\n    return prevActiveEntry\n  }\n\n  // The route tree changed. Note that this doesn't mean that the tree changed\n  // *at this level* — the change may be due to a child route. Either way, we\n  // need to either add or update the router tree in the bfcache.\n  //\n  // The rest of the code looks more complicated than it actually is because we\n  // can't mutate the state in place; we have to copy-on-write.\n\n  // Create a new entry for the active cache key. This is the head of the new\n  // linked list.\n  const newActiveEntry: RouterBFCacheEntry = {\n    tree: activeTree,\n    stateKey: activeStateKey,\n    next: null,\n  }\n\n  // We need to append the old list onto the new list. If the head of the new\n  // list was already present in the cache, then we'll need to clone everything\n  // that came before it. Then we can reuse the rest.\n  let n = 1\n  let oldEntry: RouterBFCacheEntry | null = prevActiveEntry\n  let clonedEntry: RouterBFCacheEntry = newActiveEntry\n  while (oldEntry !== null && n < MAX_BF_CACHE_ENTRIES) {\n    if (oldEntry.stateKey === activeStateKey) {\n      // Fast path. This entry in the old list that corresponds to the key that\n      // is now active. We've already placed a clone of this entry at the front\n      // of the new list. We can reuse the rest of the old list without cloning.\n      // NOTE: We don't need to worry about eviction in this case because we\n      // haven't increased the size of the cache, and we assume the max size\n      // is constant across renders. If we were to change it to a dynamic limit,\n      // then the implementation would need to account for that.\n      clonedEntry.next = oldEntry.next\n      break\n    } else {\n      // Clone the entry and append it to the list.\n      n++\n      const entry: RouterBFCacheEntry = {\n        tree: oldEntry.tree,\n        stateKey: oldEntry.stateKey,\n        next: null,\n      }\n      clonedEntry.next = entry\n      clonedEntry = entry\n    }\n    oldEntry = oldEntry.next\n  }\n\n  setPrevActiveEntry(newActiveEntry)\n  return newActiveEntry\n}\n"],"names":["useRouterBFCache","MAX_BF_CACHE_ENTRIES","process","env","__NEXT_ROUTER_BF_CACHE","activeTree","activeStateKey","prevActiveEntry","setPrevActiveEntry","useState","initialEntry","tree","stateKey","next","newActiveEntry","n","oldEntry","clonedEntry","entry"],"mappings":"AAI6BE,QAAQC,GAAG,CAACC,sBAAsB;;;;;+BA6B/CJ,oBAAAA;;;eAAAA;;;uBAhCS;AAEzB,kEAAkE;AAClE,MAAMC,6DAA4D,0BAAI;AA6B/D,SAASD,iBACdK,UAA6B,EAC7BC,cAAsB;IAEtB,wEAAwE;IACxE,2EAA2E;IAC3E,2DAA2D;IAC3D,yEAAyE;IACzE,2EAA2E;IAC3E,2EAA2E;IAC3E,4EAA4E;IAC5E,wEAAwE;IACxE,sEAAsE;IACtE,MAAM,CAACC,iBAAiBC,mBAAmB,GAAGC,CAAAA,GAAAA,OAAAA,QAAQ,EACpD;QACE,MAAMC,eAAmC;YACvCC,MAAMN;YACNO,UAAUN;YACVO,MAAM;QACR;QACA,OAAOH;IACT;IAGF,IAAIH,gBAAgBI,IAAI,KAAKN,YAAY;QACvC,iEAAiE;QACjE,kBAAkB;QAClB,OAAOE;IACT;IAEA,4EAA4E;IAC5E,2EAA2E;IAC3E,+DAA+D;IAC/D,EAAE;IACF,6EAA6E;IAC7E,6DAA6D;IAE7D,2EAA2E;IAC3E,eAAe;IACf,MAAMO,iBAAqC;QACzCH,MAAMN;QACNO,UAAUN;QACVO,MAAM;IACR;IAEA,2EAA2E;IAC3E,6EAA6E;IAC7E,mDAAmD;IACnD,IAAIE,IAAI;IACR,IAAIC,WAAsCT;IAC1C,IAAIU,cAAkCH;IACtC,MAAOE,aAAa,QAAQD,IAAId,qBAAsB;QACpD,IAAIe,SAASJ,QAAQ,KAAKN,gBAAgB;YACxC,yEAAyE;YACzE,yEAAyE;YACzE,0EAA0E;YAC1E,sEAAsE;YACtE,sEAAsE;YACtE,0EAA0E;YAC1E,0DAA0D;YAC1DW,YAAYJ,IAAI,GAAGG,SAASH,IAAI;YAChC;QACF,OAAO;YACL,6CAA6C;YAC7CE;YACA,MAAMG,QAA4B;gBAChCP,MAAMK,SAASL,IAAI;gBACnBC,UAAUI,SAASJ,QAAQ;gBAC3BC,MAAM;YACR;YACAI,YAAYJ,IAAI,GAAGK;YACnBD,cAAcC;QAChB;QACAF,WAAWA,SAASH,IAAI;IAC1B;IAEAL,mBAAmBM;IACnB,OAAOA;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4877, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/next-devtools/userspace/app/segment-explorer-node.tsx"],"sourcesContent":["'use client'\n\nimport type { ReactNode } from 'react'\nimport {\n  useState,\n  createContext,\n  useContext,\n  use,\n  useMemo,\n  useCallback,\n} from 'react'\nimport { useLayoutEffect } from 'react'\nimport { dispatcher } from 'next/dist/compiled/next-devtools'\nimport { notFound } from '../../../client/components/not-found'\n\nexport type SegmentBoundaryType =\n  | 'not-found'\n  | 'error'\n  | 'loading'\n  | 'global-error'\n\nexport const SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE =\n  'NEXT_DEVTOOLS_SIMULATED_ERROR'\n\nexport type SegmentNodeState = {\n  type: string\n  pagePath: string\n  boundaryType: string | null\n  setBoundaryType: (type: SegmentBoundaryType | null) => void\n}\n\nfunction SegmentTrieNode({\n  type,\n  pagePath,\n}: {\n  type: string\n  pagePath: string\n}): React.ReactNode {\n  const { boundaryType, setBoundaryType } = useSegmentState()\n  const nodeState: SegmentNodeState = useMemo(() => {\n    return {\n      type,\n      pagePath,\n      boundaryType,\n      setBoundaryType,\n    }\n  }, [type, pagePath, boundaryType, setBoundaryType])\n\n  // Use `useLayoutEffect` to ensure the state is updated during suspense.\n  // `useEffect` won't work as the state is preserved during suspense.\n  useLayoutEffect(() => {\n    dispatcher.segmentExplorerNodeAdd(nodeState)\n    return () => {\n      dispatcher.segmentExplorerNodeRemove(nodeState)\n    }\n  }, [nodeState])\n\n  return null\n}\n\nfunction NotFoundSegmentNode(): React.ReactNode {\n  notFound()\n}\n\nfunction ErrorSegmentNode(): React.ReactNode {\n  throw new Error(SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE)\n}\n\nconst forever = new Promise(() => {})\nfunction LoadingSegmentNode(): React.ReactNode {\n  use(forever)\n  return null\n}\n\nexport function SegmentViewStateNode({ page }: { page: string }) {\n  useLayoutEffect(() => {\n    dispatcher.segmentExplorerUpdateRouteState(page)\n    return () => {\n      dispatcher.segmentExplorerUpdateRouteState('')\n    }\n  }, [page])\n  return null\n}\n\nexport function SegmentBoundaryTriggerNode() {\n  const { boundaryType } = useSegmentState()\n  let segmentNode: React.ReactNode = null\n  if (boundaryType === 'loading') {\n    segmentNode = <LoadingSegmentNode />\n  } else if (boundaryType === 'not-found') {\n    segmentNode = <NotFoundSegmentNode />\n  } else if (boundaryType === 'error') {\n    segmentNode = <ErrorSegmentNode />\n  }\n  return segmentNode\n}\n\nexport function SegmentViewNode({\n  type,\n  pagePath,\n  children,\n}: {\n  type: string\n  pagePath: string\n  children?: ReactNode\n}): React.ReactNode {\n  const segmentNode = (\n    <SegmentTrieNode key={type} type={type} pagePath={pagePath} />\n  )\n\n  return (\n    <>\n      {segmentNode}\n      {children}\n    </>\n  )\n}\n\nconst SegmentStateContext = createContext<{\n  boundaryType: SegmentBoundaryType | null\n  setBoundaryType: (type: SegmentBoundaryType | null) => void\n}>({\n  boundaryType: null,\n  setBoundaryType: () => {},\n})\n\nexport function SegmentStateProvider({ children }: { children: ReactNode }) {\n  const [boundaryType, setBoundaryType] = useState<SegmentBoundaryType | null>(\n    null\n  )\n\n  const [errorBoundaryKey, setErrorBoundaryKey] = useState(0)\n  const reloadBoundary = useCallback(\n    () => setErrorBoundaryKey((prev) => prev + 1),\n    []\n  )\n\n  const setBoundaryTypeAndReload = useCallback(\n    (type: SegmentBoundaryType | null) => {\n      if (type === null) {\n        reloadBoundary()\n      }\n      setBoundaryType(type)\n    },\n    [reloadBoundary]\n  )\n\n  return (\n    <SegmentStateContext.Provider\n      key={errorBoundaryKey}\n      value={{\n        boundaryType,\n        setBoundaryType: setBoundaryTypeAndReload,\n      }}\n    >\n      {children}\n    </SegmentStateContext.Provider>\n  )\n}\n\nexport function useSegmentState() {\n  return useContext(SegmentStateContext)\n}\n"],"names":["SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE","SegmentBoundaryTriggerNode","SegmentStateProvider","SegmentViewNode","SegmentViewStateNode","useSegmentState","SegmentTrieNode","type","pagePath","boundaryType","setBoundaryType","nodeState","useMemo","useLayoutEffect","dispatcher","segmentExplorerNodeAdd","segmentExplorerNodeRemove","NotFoundSegmentNode","notFound","ErrorSegmentNode","Error","forever","Promise","LoadingSegmentNode","use","page","segmentExplorerUpdateRouteState","segmentNode","children","SegmentStateContext","createContext","useState","errorBoundaryKey","setErrorBoundaryKey","reloadBoundary","useCallback","prev","setBoundaryTypeAndReload","Provider","value","useContext"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5038, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/layout-router.tsx"],"sourcesContent":["'use client'\n\nimport type {\n  CacheNode,\n  LazyCacheNode,\n  LoadingModuleData,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../server/app-render/types'\nimport type { ErrorComponent } from './error-boundary'\nimport {\n  ACTION_SERVER_PATCH,\n  type FocusAndScrollRef,\n} from './router-reducer/router-reducer-types'\n\nimport React, {\n  useContext,\n  use,\n  startTransition,\n  Suspense,\n  useDeferredValue,\n  type JSX,\n} from 'react'\nimport ReactDOM from 'react-dom'\nimport {\n  LayoutRouterContext,\n  GlobalLayoutRouterContext,\n  TemplateContext,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport { fetchServerResponse } from './router-reducer/fetch-server-response'\nimport { unresolvedThenable } from './unresolved-thenable'\nimport { ErrorBoundary } from './error-boundary'\nimport { matchSegment } from './match-segments'\nimport { disableSmoothScrollDuringRouteTransition } from '../../shared/lib/router/utils/disable-smooth-scroll'\nimport { RedirectBoundary } from './redirect-boundary'\nimport { HTTPAccessFallbackBoundary } from './http-access-fallback/error-boundary'\nimport { createRouterCacheKey } from './router-reducer/create-router-cache-key'\nimport { hasInterceptionRouteInCurrentTree } from './router-reducer/reducers/has-interception-route-in-current-tree'\nimport { dispatchAppRouterAction } from './use-action-queue'\nimport { useRouterBFCache, type RouterBFCacheEntry } from './bfcache'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\n\nconst Activity = process.env.__NEXT_ROUTER_BF_CACHE\n  ? (require('react') as typeof import('react')).unstable_Activity\n  : null!\n\n/**\n * Add refetch marker to router state at the point of the current layout segment.\n * This ensures the response returned is not further down than the current layout segment.\n */\nfunction walkAddRefetch(\n  segmentPathToWalk: FlightSegmentPath | undefined,\n  treeToRecreate: FlightRouterState\n): FlightRouterState {\n  if (segmentPathToWalk) {\n    const [segment, parallelRouteKey] = segmentPathToWalk\n    const isLast = segmentPathToWalk.length === 2\n\n    if (matchSegment(treeToRecreate[0], segment)) {\n      if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {\n        if (isLast) {\n          const subTree = walkAddRefetch(\n            undefined,\n            treeToRecreate[1][parallelRouteKey]\n          )\n          return [\n            treeToRecreate[0],\n            {\n              ...treeToRecreate[1],\n              [parallelRouteKey]: [\n                subTree[0],\n                subTree[1],\n                subTree[2],\n                'refetch',\n              ],\n            },\n          ]\n        }\n\n        return [\n          treeToRecreate[0],\n          {\n            ...treeToRecreate[1],\n            [parallelRouteKey]: walkAddRefetch(\n              segmentPathToWalk.slice(2),\n              treeToRecreate[1][parallelRouteKey]\n            ),\n          },\n        ]\n      }\n    }\n  }\n\n  return treeToRecreate\n}\n\nconst __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = (\n  ReactDOM as any\n).__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE\n\n// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available\n/**\n * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning\n */\nfunction findDOMNode(\n  instance: React.ReactInstance | null | undefined\n): Element | Text | null {\n  // Tree-shake for server bundle\n  if (typeof window === 'undefined') return null\n\n  // __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode is null during module init.\n  // We need to lazily reference it.\n  const internal_reactDOMfindDOMNode =\n    __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode\n  return internal_reactDOMfindDOMNode(instance)\n}\n\nconst rectProperties = [\n  'bottom',\n  'height',\n  'left',\n  'right',\n  'top',\n  'width',\n  'x',\n  'y',\n] as const\n/**\n * Check if a HTMLElement is hidden or fixed/sticky position\n */\nfunction shouldSkipElement(element: HTMLElement) {\n  // we ignore fixed or sticky positioned elements since they'll likely pass the \"in-viewport\" check\n  // and will result in a situation we bail on scroll because of something like a fixed nav,\n  // even though the actual page content is offscreen\n  if (['sticky', 'fixed'].includes(getComputedStyle(element).position)) {\n    if (process.env.NODE_ENV === 'development') {\n      console.warn(\n        'Skipping auto-scroll behavior due to `position: sticky` or `position: fixed` on element:',\n        element\n      )\n    }\n    return true\n  }\n\n  // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`\n  // because `offsetParent` doesn't consider document/body\n  const rect = element.getBoundingClientRect()\n  return rectProperties.every((item) => rect[item] === 0)\n}\n\n/**\n * Check if the top corner of the HTMLElement is in the viewport.\n */\nfunction topOfElementInViewport(element: HTMLElement, viewportHeight: number) {\n  const rect = element.getBoundingClientRect()\n  return rect.top >= 0 && rect.top <= viewportHeight\n}\n\n/**\n * Find the DOM node for a hash fragment.\n * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.\n * If the hash fragment is an id, the page has to scroll to the element with that id.\n * If the hash fragment is a name, the page has to scroll to the first element with that name.\n */\nfunction getHashFragmentDomNode(hashFragment: string) {\n  // If the hash fragment is `top` the page has to scroll to the top of the page.\n  if (hashFragment === 'top') {\n    return document.body\n  }\n\n  // If the hash fragment is an id, the page has to scroll to the element with that id.\n  return (\n    document.getElementById(hashFragment) ??\n    // If the hash fragment is a name, the page has to scroll to the first element with that name.\n    document.getElementsByName(hashFragment)[0]\n  )\n}\ninterface ScrollAndFocusHandlerProps {\n  focusAndScrollRef: FocusAndScrollRef\n  children: React.ReactNode\n  segmentPath: FlightSegmentPath\n}\nclass InnerScrollAndFocusHandler extends React.Component<ScrollAndFocusHandlerProps> {\n  handlePotentialScroll = () => {\n    // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\n    const { focusAndScrollRef, segmentPath } = this.props\n\n    if (focusAndScrollRef.apply) {\n      // segmentPaths is an array of segment paths that should be scrolled to\n      // if the current segment path is not in the array, the scroll is not applied\n      // unless the array is empty, in which case the scroll is always applied\n      if (\n        focusAndScrollRef.segmentPaths.length !== 0 &&\n        !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath) =>\n          segmentPath.every((segment, index) =>\n            matchSegment(segment, scrollRefSegmentPath[index])\n          )\n        )\n      ) {\n        return\n      }\n\n      let domNode:\n        | ReturnType<typeof getHashFragmentDomNode>\n        | ReturnType<typeof findDOMNode> = null\n      const hashFragment = focusAndScrollRef.hashFragment\n\n      if (hashFragment) {\n        domNode = getHashFragmentDomNode(hashFragment)\n      }\n\n      // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.\n      // This already caused a bug where the first child was a <link/> in head.\n      if (!domNode) {\n        domNode = findDOMNode(this)\n      }\n\n      // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.\n      if (!(domNode instanceof Element)) {\n        return\n      }\n\n      // Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.\n      // If the element is skipped, try to select the next sibling and try again.\n      while (!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (domNode.parentElement?.localName === 'head') {\n            // TODO: We enter this state when metadata was rendered as part of the page or via Next.js.\n            // This is always a bug in Next.js and caused by React hoisting metadata.\n            // We need to replace `findDOMNode` in favor of Fragment Refs (when available) so that we can skip over metadata.\n          }\n        }\n\n        // No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.\n        if (domNode.nextElementSibling === null) {\n          return\n        }\n        domNode = domNode.nextElementSibling\n      }\n\n      // State is mutated to ensure that the focus and scroll is applied only once.\n      focusAndScrollRef.apply = false\n      focusAndScrollRef.hashFragment = null\n      focusAndScrollRef.segmentPaths = []\n\n      disableSmoothScrollDuringRouteTransition(\n        () => {\n          // In case of hash scroll, we only need to scroll the element into view\n          if (hashFragment) {\n            ;(domNode as HTMLElement).scrollIntoView()\n\n            return\n          }\n          // Store the current viewport height because reading `clientHeight` causes a reflow,\n          // and it won't change during this function.\n          const htmlElement = document.documentElement\n          const viewportHeight = htmlElement.clientHeight\n\n          // If the element's top edge is already in the viewport, exit early.\n          if (topOfElementInViewport(domNode as HTMLElement, viewportHeight)) {\n            return\n          }\n\n          // Otherwise, try scrolling go the top of the document to be backward compatible with pages\n          // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)\n          // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left\n          // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically\n          htmlElement.scrollTop = 0\n\n          // Scroll to domNode if domNode is not in viewport when scrolled to top of document\n          if (!topOfElementInViewport(domNode as HTMLElement, viewportHeight)) {\n            // Scroll into view doesn't scroll horizontally by default when not needed\n            ;(domNode as HTMLElement).scrollIntoView()\n          }\n        },\n        {\n          // We will force layout by querying domNode position\n          dontForceLayout: true,\n          onlyHashChange: focusAndScrollRef.onlyHashChange,\n        }\n      )\n\n      // Mutate after scrolling so that it can be read by `disableSmoothScrollDuringRouteTransition`\n      focusAndScrollRef.onlyHashChange = false\n\n      // Set focus on the element\n      domNode.focus()\n    }\n  }\n\n  componentDidMount() {\n    this.handlePotentialScroll()\n  }\n\n  componentDidUpdate() {\n    // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.\n    if (this.props.focusAndScrollRef.apply) {\n      this.handlePotentialScroll()\n    }\n  }\n\n  render() {\n    return this.props.children\n  }\n}\n\nfunction ScrollAndFocusHandler({\n  segmentPath,\n  children,\n}: {\n  segmentPath: FlightSegmentPath\n  children: React.ReactNode\n}) {\n  const context = useContext(GlobalLayoutRouterContext)\n  if (!context) {\n    throw new Error('invariant global layout router not mounted')\n  }\n\n  return (\n    <InnerScrollAndFocusHandler\n      segmentPath={segmentPath}\n      focusAndScrollRef={context.focusAndScrollRef}\n    >\n      {children}\n    </InnerScrollAndFocusHandler>\n  )\n}\n\n/**\n * InnerLayoutRouter handles rendering the provided segment based on the cache.\n */\nfunction InnerLayoutRouter({\n  tree,\n  segmentPath,\n  cacheNode,\n  url,\n}: {\n  tree: FlightRouterState\n  segmentPath: FlightSegmentPath\n  cacheNode: CacheNode\n  url: string\n}) {\n  const context = useContext(GlobalLayoutRouterContext)\n  if (!context) {\n    throw new Error('invariant global layout router not mounted')\n  }\n\n  const { tree: fullTree } = context\n\n  // `rsc` represents the renderable node for this segment.\n\n  // If this segment has a `prefetchRsc`, it's the statically prefetched data.\n  // We should use that on initial render instead of `rsc`. Then we'll switch\n  // to `rsc` when the dynamic response streams in.\n  //\n  // If no prefetch data is available, then we go straight to rendering `rsc`.\n  const resolvedPrefetchRsc =\n    cacheNode.prefetchRsc !== null ? cacheNode.prefetchRsc : cacheNode.rsc\n\n  // We use `useDeferredValue` to handle switching between the prefetched and\n  // final values. The second argument is returned on initial render, then it\n  // re-renders with the first argument.\n  const rsc: any = useDeferredValue(cacheNode.rsc, resolvedPrefetchRsc)\n\n  // `rsc` is either a React node or a promise for a React node, except we\n  // special case `null` to represent that this segment's data is missing. If\n  // it's a promise, we need to unwrap it so we can determine whether or not the\n  // data is missing.\n  const resolvedRsc: React.ReactNode =\n    typeof rsc === 'object' && rsc !== null && typeof rsc.then === 'function'\n      ? use(rsc)\n      : rsc\n\n  if (!resolvedRsc) {\n    // The data for this segment is not available, and there's no pending\n    // navigation that will be able to fulfill it. We need to fetch more from\n    // the server and patch the cache.\n\n    // Check if there's already a pending request.\n    let lazyData = cacheNode.lazyData\n    if (lazyData === null) {\n      /**\n       * Router state with refetch marker added\n       */\n      // TODO-APP: remove ''\n      const refetchTree = walkAddRefetch(['', ...segmentPath], fullTree)\n      const includeNextUrl = hasInterceptionRouteInCurrentTree(fullTree)\n      const navigatedAt = Date.now()\n      cacheNode.lazyData = lazyData = fetchServerResponse(\n        new URL(url, location.origin),\n        {\n          flightRouterState: refetchTree,\n          nextUrl: includeNextUrl ? context.nextUrl : null,\n        }\n      ).then((serverResponse) => {\n        startTransition(() => {\n          dispatchAppRouterAction({\n            type: ACTION_SERVER_PATCH,\n            previousTree: fullTree,\n            serverResponse,\n            navigatedAt,\n          })\n        })\n\n        return serverResponse\n      })\n\n      // Suspend while waiting for lazyData to resolve\n      use(lazyData)\n    }\n    // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.\n    // A falsey `resolvedRsc` indicates missing data -- we should not commit that branch, and we need to wait for the data to arrive.\n    use(unresolvedThenable) as never\n  }\n\n  // If we get to this point, then we know we have something we can render.\n  const subtree = (\n    // The layout router context narrows down tree and childNodes at each level.\n    <LayoutRouterContext.Provider\n      value={{\n        parentTree: tree,\n        parentCacheNode: cacheNode,\n        parentSegmentPath: segmentPath,\n\n        // TODO-APP: overriding of url for parallel routes\n        url: url,\n      }}\n    >\n      {resolvedRsc}\n    </LayoutRouterContext.Provider>\n  )\n  // Ensure root layout is not wrapped in a div as the root layout renders `<html>`\n  return subtree\n}\n\n/**\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\n * If no loading property is provided it renders the children without a suspense boundary.\n */\nfunction LoadingBoundary({\n  loading,\n  children,\n}: {\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n  children: React.ReactNode\n}): JSX.Element {\n  // If loading is a promise, unwrap it. This happens in cases where we haven't\n  // yet received the loading data from the server — which includes whether or\n  // not this layout has a loading component at all.\n  //\n  // It's OK to suspend here instead of inside the fallback because this\n  // promise will resolve simultaneously with the data for the segment itself.\n  // So it will never suspend for longer than it would have if we didn't use\n  // a Suspense fallback at all.\n  let loadingModuleData\n  if (\n    typeof loading === 'object' &&\n    loading !== null &&\n    typeof (loading as any).then === 'function'\n  ) {\n    const promiseForLoading = loading as Promise<LoadingModuleData>\n    loadingModuleData = use(promiseForLoading)\n  } else {\n    loadingModuleData = loading as LoadingModuleData\n  }\n\n  if (loadingModuleData) {\n    const loadingRsc = loadingModuleData[0]\n    const loadingStyles = loadingModuleData[1]\n    const loadingScripts = loadingModuleData[2]\n    return (\n      <Suspense\n        fallback={\n          <>\n            {loadingStyles}\n            {loadingScripts}\n            {loadingRsc}\n          </>\n        }\n      >\n        {children}\n      </Suspense>\n    )\n  }\n\n  return <>{children}</>\n}\n\n/**\n * OuterLayoutRouter handles the current segment as well as <Offscreen> rendering of other segments.\n * It can be rendered next to each other with a different `parallelRouterKey`, allowing for Parallel routes.\n */\nexport default function OuterLayoutRouter({\n  parallelRouterKey,\n  error,\n  errorStyles,\n  errorScripts,\n  templateStyles,\n  templateScripts,\n  template,\n  notFound,\n  forbidden,\n  unauthorized,\n  segmentViewBoundaries,\n}: {\n  parallelRouterKey: string\n  error: ErrorComponent | undefined\n  errorStyles: React.ReactNode | undefined\n  errorScripts: React.ReactNode | undefined\n  templateStyles: React.ReactNode | undefined\n  templateScripts: React.ReactNode | undefined\n  template: React.ReactNode\n  notFound: React.ReactNode | undefined\n  forbidden: React.ReactNode | undefined\n  unauthorized: React.ReactNode | undefined\n  segmentViewBoundaries?: React.ReactNode\n}) {\n  const context = useContext(LayoutRouterContext)\n  if (!context) {\n    throw new Error('invariant expected layout router to be mounted')\n  }\n\n  const { parentTree, parentCacheNode, parentSegmentPath, url } = context\n\n  // Get the CacheNode for this segment by reading it from the parent segment's\n  // child map.\n  const parentParallelRoutes = parentCacheNode.parallelRoutes\n  let segmentMap = parentParallelRoutes.get(parallelRouterKey)\n  // If the parallel router cache node does not exist yet, create it.\n  // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n  if (!segmentMap) {\n    segmentMap = new Map()\n    parentParallelRoutes.set(parallelRouterKey, segmentMap)\n  }\n  const parentTreeSegment = parentTree[0]\n  const segmentPath =\n    parentSegmentPath === null\n      ? // TODO: The root segment value is currently omitted from the segment\n        // path. This has led to a bunch of special cases scattered throughout\n        // the code. We should clean this up.\n        [parallelRouterKey]\n      : parentSegmentPath.concat([parentTreeSegment, parallelRouterKey])\n\n  // The \"state\" key of a segment is the one passed to React — it represents the\n  // identity of the UI tree. Whenever the state key changes, the tree is\n  // recreated and the state is reset. In the App Router model, search params do\n  // not cause state to be lost, so two segments with the same segment path but\n  // different search params should have the same state key.\n  //\n  // The \"cache\" key of a segment, however, *does* include the search params, if\n  // it's possible that the segment accessed the search params on the server.\n  // (This only applies to page segments; layout segments cannot access search\n  // params on the server.)\n  const activeTree = parentTree[1][parallelRouterKey]\n  const activeSegment = activeTree[0]\n  const activeStateKey = createRouterCacheKey(activeSegment, true) // no search params\n\n  // At each level of the route tree, not only do we render the currently\n  // active segment — we also render the last N segments that were active at\n  // this level inside a hidden <Activity> boundary, to preserve their state\n  // if or when the user navigates to them again.\n  //\n  // bfcacheEntry is a linked list of FlightRouterStates.\n  let bfcacheEntry: RouterBFCacheEntry | null = useRouterBFCache(\n    activeTree,\n    activeStateKey\n  )\n  let children: Array<React.ReactNode> = []\n  do {\n    const tree = bfcacheEntry.tree\n    const stateKey = bfcacheEntry.stateKey\n    const segment = tree[0]\n    const cacheKey = createRouterCacheKey(segment)\n\n    // Read segment path from the parallel router cache node.\n    let cacheNode = segmentMap.get(cacheKey)\n    if (cacheNode === undefined) {\n      // When data is not available during rendering client-side we need to fetch\n      // it from the server.\n      const newLazyCacheNode: LazyCacheNode = {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n        navigatedAt: -1,\n      }\n\n      // Flight data fetch kicked off during render and put into the cache.\n      cacheNode = newLazyCacheNode\n      segmentMap.set(cacheKey, newLazyCacheNode)\n    }\n\n    /*\n    - Error boundary\n      - Only renders error boundary if error component is provided.\n      - Rendered for each segment to ensure they have their own error state.\n      - When gracefully degrade for bots, skip rendering error boundary.\n    - Loading boundary\n      - Only renders suspense boundary if loading components is provided.\n      - Rendered for each segment to ensure they have their own loading state.\n      - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\n  */\n\n    let segmentBoundaryTriggerNode: React.ReactNode = null\n    let segmentViewStateNode: React.ReactNode = null\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      process.env.__NEXT_DEVTOOL_SEGMENT_EXPLORER\n    ) {\n      const { SegmentBoundaryTriggerNode, SegmentViewStateNode } =\n        require('../../next-devtools/userspace/app/segment-explorer-node') as typeof import('../../next-devtools/userspace/app/segment-explorer-node')\n\n      const pagePrefix = normalizeAppPath(url)\n      segmentViewStateNode = (\n        <SegmentViewStateNode key={pagePrefix} page={pagePrefix} />\n      )\n\n      segmentBoundaryTriggerNode = (\n        <>\n          <SegmentBoundaryTriggerNode />\n        </>\n      )\n    }\n\n    // TODO: The loading module data for a segment is stored on the parent, then\n    // applied to each of that parent segment's parallel route slots. In the\n    // simple case where there's only one parallel route (the `children` slot),\n    // this is no different from if the loading module data where stored on the\n    // child directly. But I'm not sure this actually makes sense when there are\n    // multiple parallel routes. It's not a huge issue because you always have\n    // the option to define a narrower loading boundary for a particular slot. But\n    // this sort of smells like an implementation accident to me.\n    const loadingModuleData = parentCacheNode.loading\n    let child = (\n      <TemplateContext.Provider\n        key={stateKey}\n        value={\n          <ScrollAndFocusHandler segmentPath={segmentPath}>\n            <ErrorBoundary\n              errorComponent={error}\n              errorStyles={errorStyles}\n              errorScripts={errorScripts}\n            >\n              <LoadingBoundary loading={loadingModuleData}>\n                <HTTPAccessFallbackBoundary\n                  notFound={notFound}\n                  forbidden={forbidden}\n                  unauthorized={unauthorized}\n                >\n                  <RedirectBoundary>\n                    <InnerLayoutRouter\n                      url={url}\n                      tree={tree}\n                      cacheNode={cacheNode}\n                      segmentPath={segmentPath}\n                    />\n                    {segmentBoundaryTriggerNode}\n                  </RedirectBoundary>\n                </HTTPAccessFallbackBoundary>\n              </LoadingBoundary>\n            </ErrorBoundary>\n            {segmentViewStateNode}\n          </ScrollAndFocusHandler>\n        }\n      >\n        {templateStyles}\n        {templateScripts}\n        {template}\n      </TemplateContext.Provider>\n    )\n\n    if (process.env.NODE_ENV !== 'production') {\n      const { SegmentStateProvider } =\n        require('../../next-devtools/userspace/app/segment-explorer-node') as typeof import('../../next-devtools/userspace/app/segment-explorer-node')\n\n      child = (\n        <SegmentStateProvider key={stateKey}>\n          {child}\n          {segmentViewBoundaries}\n        </SegmentStateProvider>\n      )\n    }\n\n    if (process.env.__NEXT_ROUTER_BF_CACHE) {\n      child = (\n        <Activity\n          key={stateKey}\n          mode={stateKey === activeStateKey ? 'visible' : 'hidden'}\n        >\n          {child}\n        </Activity>\n      )\n    }\n\n    children.push(child)\n\n    bfcacheEntry = bfcacheEntry.next\n  } while (bfcacheEntry !== null)\n\n  return children\n}\n"],"names":["OuterLayoutRouter","Activity","process","env","__NEXT_ROUTER_BF_CACHE","require","unstable_Activity","walkAddRefetch","segmentPathToWalk","treeToRecreate","segment","parallelRouteKey","isLast","length","matchSegment","hasOwnProperty","subTree","undefined","slice","__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE","ReactDOM","findDOMNode","instance","window","internal_reactDOMfindDOMNode","rectProperties","shouldSkipElement","element","includes","getComputedStyle","position","NODE_ENV","console","warn","rect","getBoundingClientRect","every","item","topOfElementInViewport","viewportHeight","top","getHashFragmentDomNode","hashFragment","document","body","getElementById","getElementsByName","InnerScrollAndFocusHandler","React","Component","componentDidMount","handlePotentialScroll","componentDidUpdate","props","focusAndScrollRef","apply","render","children","segmentPath","segmentPaths","some","scrollRefSegmentPath","index","domNode","Element","HTMLElement","parentElement","localName","nextElementSibling","disableSmoothScrollDuringRouteTransition","scrollIntoView","htmlElement","documentElement","clientHeight","scrollTop","dontForceLayout","onlyHashChange","focus","ScrollAndFocusHandler","context","useContext","GlobalLayoutRouterContext","Error","InnerLayoutRouter","tree","cacheNode","url","fullTree","resolvedPrefetchRsc","prefetchRsc","rsc","useDeferredValue","resolvedRsc","then","use","lazyData","refetchTree","includeNextUrl","hasInterceptionRouteInCurrentTree","navigatedAt","Date","now","fetchServerResponse","URL","location","origin","flightRouterState","nextUrl","serverResponse","startTransition","dispatchAppRouterAction","type","ACTION_SERVER_PATCH","previousTree","unresolvedThenable","subtree","LayoutRouterContext","Provider","value","parentTree","parentCacheNode","parentSegmentPath","LoadingBoundary","loading","loadingModuleData","promiseForLoading","loadingRsc","loadingStyles","loadingScripts","Suspense","fallback","parallelRouterKey","error","errorStyles","errorScripts","templateStyles","templateScripts","template","notFound","forbidden","unauthorized","segmentViewBoundaries","parentParallelRoutes","parallelRoutes","segmentMap","get","Map","set","parentTreeSegment","concat","activeTree","activeSegment","activeStateKey","createRouterCacheKey","bfcacheEntry","useRouterBFCache","stateKey","cacheKey","newLazyCacheNode","head","prefetchHead","segmentBoundaryTriggerNode","segmentViewStateNode","__NEXT_DEVTOOL_SEGMENT_EXPLORER","SegmentBoundaryTriggerNode","SegmentViewStateNode","pagePrefix","normalizeAppPath","page","child","TemplateContext","ErrorBoundary","errorComponent","HTTPAccessFallbackBoundary","RedirectBoundary","SegmentStateProvider","mode","push","next"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5573, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/render-from-template-context.tsx"],"sourcesContent":["'use client'\n\nimport React, { useContext, type JSX } from 'react'\nimport { TemplateContext } from '../../shared/lib/app-router-context.shared-runtime'\n\nexport default function RenderFromTemplateContext(): JSX.Element {\n  const children = useContext(TemplateContext)\n  return <>{children}</>\n}\n"],"names":["RenderFromTemplateContext","children","useContext","TemplateContext"],"mappings":";;;+BAKA,WAAA;;;eAAwBA;;;;;iEAHoB;+CACZ;AAEjB,SAASA;IACtB,MAAMC,WAAWC,CAAAA,GAAAA,OAAAA,UAAU,EAACC,+BAAAA,eAAe;IAC3C,OAAA,WAAA,GAAO,CAAA,GAAA,YAAA,GAAA,EAAA,YAAA,QAAA,EAAA;kBAAGF;;AACZ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5603, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/server/web/spec-extension/adapters/reflect.ts"],"sourcesContent":["export class ReflectAdapter {\n  static get<T extends object>(\n    target: T,\n    prop: string | symbol,\n    receiver: unknown\n  ): any {\n    const value = Reflect.get(target, prop, receiver)\n    if (typeof value === 'function') {\n      return value.bind(target)\n    }\n\n    return value\n  }\n\n  static set<T extends object>(\n    target: T,\n    prop: string | symbol,\n    value: any,\n    receiver: any\n  ): boolean {\n    return Reflect.set(target, prop, value, receiver)\n  }\n\n  static has<T extends object>(target: T, prop: string | symbol): boolean {\n    return Reflect.has(target, prop)\n  }\n\n  static deleteProperty<T extends object>(\n    target: T,\n    prop: string | symbol\n  ): boolean {\n    return Reflect.deleteProperty(target, prop)\n  }\n}\n"],"names":["ReflectAdapter","get","target","prop","receiver","value","Reflect","bind","set","has","deleteProperty"],"mappings":";;;+BAAaA,kBAAAA;;;eAAAA;;;AAAN,MAAMA;IACX,OAAOC,IACLC,MAAS,EACTC,IAAqB,EACrBC,QAAiB,EACZ;QACL,MAAMC,QAAQC,QAAQL,GAAG,CAACC,QAAQC,MAAMC;QACxC,IAAI,OAAOC,UAAU,YAAY;YAC/B,OAAOA,MAAME,IAAI,CAACL;QACpB;QAEA,OAAOG;IACT;IAEA,OAAOG,IACLN,MAAS,EACTC,IAAqB,EACrBE,KAAU,EACVD,QAAa,EACJ;QACT,OAAOE,QAAQE,GAAG,CAACN,QAAQC,MAAME,OAAOD;IAC1C;IAEA,OAAOK,IAAsBP,MAAS,EAAEC,IAAqB,EAAW;QACtE,OAAOG,QAAQG,GAAG,CAACP,QAAQC;IAC7B;IAEA,OAAOO,eACLR,MAAS,EACTC,IAAqB,EACZ;QACT,OAAOG,QAAQI,cAAc,CAACR,QAAQC;IACxC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5634, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/shared/lib/utils/reflect-utils.ts"],"sourcesContent":["// This regex will have fast negatives meaning valid identifiers may not pass\n// this test. However this is only used during static generation to provide hints\n// about why a page bailed out of some or all prerendering and we can use bracket notation\n// for example while `ಠ_ಠ` is a valid identifier it's ok to print `searchParams['ಠ_ಠ']`\n// even if this would have been fine too `searchParams.ಠ_ಠ`\nconst isDefinitelyAValidIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/\n\nexport function describeStringPropertyAccess(target: string, prop: string) {\n  if (isDefinitelyAValidIdentifier.test(prop)) {\n    return `\\`${target}.${prop}\\``\n  }\n  return `\\`${target}[${JSON.stringify(prop)}]\\``\n}\n\nexport function describeHasCheckingStringProperty(\n  target: string,\n  prop: string\n) {\n  const stringifiedProp = JSON.stringify(prop)\n  return `\\`Reflect.has(${target}, ${stringifiedProp})\\`, \\`${stringifiedProp} in ${target}\\`, or similar`\n}\n\nexport const wellKnownProperties = new Set([\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toString',\n  'valueOf',\n  'toLocaleString',\n\n  // Promise prototype\n  // fallthrough\n  'then',\n  'catch',\n  'finally',\n\n  // React Promise extension\n  // fallthrough\n  'status',\n\n  // React introspection\n  'displayName',\n  '_debugInfo',\n\n  // Common tested properties\n  // fallthrough\n  'toJSON',\n  '$$typeof',\n  '__esModule',\n])\n"],"names":["describeHasCheckingStringProperty","describeStringPropertyAccess","wellKnownProperties","isDefinitelyAValidIdentifier","target","prop","test","JSON","stringify","stringifiedProp","Set"],"mappings":"AAAA,6EAA6E;AAC7E,iFAAiF;AACjF,0FAA0F;AAC1F,uFAAuF;AACvF,2DAA2D;;;;;;;;;;;;;;;;IAU3CA,iCAAiC,EAAA;eAAjCA;;IAPAC,4BAA4B,EAAA;eAA5BA;;IAeHC,mBAAmB,EAAA;eAAnBA;;;AAjBb,MAAMC,+BAA+B;AAE9B,SAASF,6BAA6BG,MAAc,EAAEC,IAAY;IACvE,IAAIF,6BAA6BG,IAAI,CAACD,OAAO;QAC3C,OAAQ,MAAID,SAAO,MAAGC,OAAK;IAC7B;IACA,OAAQ,MAAID,SAAO,MAAGG,KAAKC,SAAS,CAACH,QAAM;AAC7C;AAEO,SAASL,kCACdI,MAAc,EACdC,IAAY;IAEZ,MAAMI,kBAAkBF,KAAKC,SAAS,CAACH;IACvC,OAAQ,kBAAgBD,SAAO,OAAIK,kBAAgB,UAASA,kBAAgB,SAAML,SAAO;AAC3F;AAEO,MAAMF,sBAAsB,IAAIQ,IAAI;IACzC;IACA;IACA;IACA;IACA;IACA;IAEA,oBAAoB;IACpB,cAAc;IACd;IACA;IACA;IAEA,0BAA0B;IAC1B,cAAc;IACd;IAEA,sBAAsB;IACtB;IACA;IAEA,2BAA2B;IAC3B,cAAc;IACd;IACA;IACA;CACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5703, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/request/search-params.browser.dev.ts"],"sourcesContent":["import type { SearchParams } from '../../server/request/search-params'\n\nimport { ReflectAdapter } from '../../server/web/spec-extension/adapters/reflect'\nimport {\n  describeStringPropertyAccess,\n  describeHasCheckingStringProperty,\n  wellKnownProperties,\n} from '../../shared/lib/utils/reflect-utils'\n\ninterface CacheLifetime {}\nconst CachedSearchParams = new WeakMap<CacheLifetime, Promise<SearchParams>>()\n\nfunction makeUntrackedExoticSearchParamsWithDevWarnings(\n  underlyingSearchParams: SearchParams\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const proxiedProperties = new Set<string>()\n  const unproxiedProperties: Array<string> = []\n\n  const promise = Promise.resolve(underlyingSearchParams)\n\n  Object.keys(underlyingSearchParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n      unproxiedProperties.push(prop)\n    } else {\n      proxiedProperties.add(prop)\n      ;(promise as any)[prop] = underlyingSearchParams[prop]\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeStringPropertyAccess('searchParams', prop)\n          warnForSyncAccess(expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return Reflect.set(target, prop, value, receiver)\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeHasCheckingStringProperty(\n            'searchParams',\n            prop\n          )\n          warnForSyncAccess(expression)\n        }\n      }\n      return Reflect.has(target, prop)\n    },\n    ownKeys(target) {\n      warnForSyncSpread()\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedSearchParams.set(underlyingSearchParams, proxiedPromise)\n  return proxiedPromise\n}\n\n// Similar to `makeUntrackedExoticSearchParamsWithDevWarnings`, but just logging\n// the sync access without actually defining the search params on the promise.\nfunction makeUntrackedSearchParamsWithDevWarnings(\n  underlyingSearchParams: SearchParams\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const proxiedProperties = new Set<string>()\n  const unproxiedProperties: Array<string> = []\n  const promise = Promise.resolve(underlyingSearchParams)\n\n  Object.keys(underlyingSearchParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n      unproxiedProperties.push(prop)\n    } else {\n      proxiedProperties.add(prop)\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeStringPropertyAccess('searchParams', prop)\n          warnForSyncAccess(expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return Reflect.set(target, prop, value, receiver)\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeHasCheckingStringProperty(\n            'searchParams',\n            prop\n          )\n          warnForSyncAccess(expression)\n        }\n      }\n      return Reflect.has(target, prop)\n    },\n    ownKeys(target) {\n      warnForSyncSpread()\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedSearchParams.set(underlyingSearchParams, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction warnForSyncAccess(expression: string) {\n  console.error(\n    `A searchParam property was accessed directly with ${expression}. ` +\n      `\\`searchParams\\` should be unwrapped with \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction warnForSyncSpread() {\n  console.error(\n    `The keys of \\`searchParams\\` were accessed directly. ` +\n      `\\`searchParams\\` should be unwrapped with \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nexport function createRenderSearchParamsFromClient(\n  underlyingSearchParams: SearchParams\n): Promise<SearchParams> {\n  if (process.env.__NEXT_CACHE_COMPONENTS) {\n    return makeUntrackedSearchParamsWithDevWarnings(underlyingSearchParams)\n  }\n\n  return makeUntrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams)\n}\n"],"names":["createRenderSearchParamsFromClient","CachedSearchParams","WeakMap","makeUntrackedExoticSearchParamsWithDevWarnings","underlyingSearchParams","cachedSearchParams","get","proxiedProperties","Set","unproxiedProperties","promise","Promise","resolve","Object","keys","forEach","prop","wellKnownProperties","has","push","add","proxiedPromise","Proxy","target","receiver","Reflect","expression","describeStringPropertyAccess","warnForSyncAccess","ReflectAdapter","set","value","delete","describeHasCheckingStringProperty","ownKeys","warnForSyncSpread","makeUntrackedSearchParamsWithDevWarnings","console","error","process","env","__NEXT_CACHE_COMPONENTS"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5850, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/request/search-params.browser.ts"],"sourcesContent":["export const createRenderSearchParamsFromClient =\n  process.env.NODE_ENV === 'development'\n    ? (\n        require('./search-params.browser.dev') as typeof import('./search-params.browser.dev')\n      ).createRenderSearchParamsFromClient\n    : (\n        require('./search-params.browser.prod') as typeof import('./search-params.browser.prod')\n      ).createRenderSearchParamsFromClient\n"],"names":["createRenderSearchParamsFromClient","process","env","NODE_ENV","require"],"mappings":"AACEC,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;+BADdH,sCAAAA;;;eAAAA;;;AAAN,MAAMA,4EAGLI,QAAQ,oKACRJ,kCAAkC,GAElCI,QAAQ,gCACRJ,kCAAkC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5873, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/request/params.browser.dev.ts"],"sourcesContent":["import type { Params } from '../../server/request/params'\n\nimport { ReflectAdapter } from '../../server/web/spec-extension/adapters/reflect'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport {\n  describeStringPropertyAccess,\n  wellKnownProperties,\n} from '../../shared/lib/utils/reflect-utils'\n\ninterface CacheLifetime {}\nconst CachedParams = new WeakMap<CacheLifetime, Promise<Params>>()\n\nfunction makeDynamicallyTrackedExoticParamsWithDevWarnings(\n  underlyingParams: Params\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingParams)\n\n  const proxiedProperties = new Set<string>()\n  const unproxiedProperties: Array<string> = []\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      proxiedProperties.add(prop)\n      ;(promise as any)[prop] = underlyingParams[prop]\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          // We are accessing a property that was proxied to the promise instance\n          proxiedProperties.has(prop)\n        ) {\n          const expression = describeStringPropertyAccess('params', prop)\n          warnForSyncAccess(expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return ReflectAdapter.set(target, prop, value, receiver)\n    },\n    ownKeys(target) {\n      warnForEnumeration(unproxiedProperties)\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedParams.set(underlyingParams, proxiedPromise)\n  return proxiedPromise\n}\n\n// Similar to `makeDynamicallyTrackedExoticParamsWithDevWarnings`, but just\n// logging the sync access without actually defining the params on the promise.\nfunction makeDynamicallyTrackedParamsWithDevWarnings(\n  underlyingParams: Params\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingParams)\n\n  const proxiedProperties = new Set<string>()\n  const unproxiedProperties: Array<string> = []\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      proxiedProperties.add(prop)\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          // We are accessing a property that was proxied to the promise instance\n          proxiedProperties.has(prop)\n        ) {\n          const expression = describeStringPropertyAccess('params', prop)\n          warnForSyncAccess(expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return ReflectAdapter.set(target, prop, value, receiver)\n    },\n    ownKeys(target) {\n      warnForEnumeration(unproxiedProperties)\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedParams.set(underlyingParams, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction warnForSyncAccess(expression: string) {\n  console.error(\n    `A param property was accessed directly with ${expression}. \\`params\\` is now a Promise and should be unwrapped with \\`React.use()\\` before accessing properties of the underlying params object. In this version of Next.js direct access to param properties is still supported to facilitate migration but in a future version you will be required to unwrap \\`params\\` with \\`React.use()\\`.`\n  )\n}\n\nfunction warnForEnumeration(missingProperties: Array<string>) {\n  if (missingProperties.length) {\n    const describedMissingProperties =\n      describeListOfPropertyNames(missingProperties)\n    console.error(\n      `params are being enumerated incompletely missing these properties: ${describedMissingProperties}. ` +\n        `\\`params\\` should be unwrapped with \\`React.use()\\` before using its value. ` +\n        `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n    )\n  } else {\n    console.error(\n      `params are being enumerated. ` +\n        `\\`params\\` should be unwrapped with \\`React.use()\\` before using its value. ` +\n        `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n    )\n  }\n}\n\nfunction describeListOfPropertyNames(properties: Array<string>) {\n  switch (properties.length) {\n    case 0:\n      throw new InvariantError(\n        'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'\n      )\n    case 1:\n      return `\\`${properties[0]}\\``\n    case 2:\n      return `\\`${properties[0]}\\` and \\`${properties[1]}\\``\n    default: {\n      let description = ''\n      for (let i = 0; i < properties.length - 1; i++) {\n        description += `\\`${properties[i]}\\`, `\n      }\n      description += `, and \\`${properties[properties.length - 1]}\\``\n      return description\n    }\n  }\n}\n\nexport function createRenderParamsFromClient(\n  clientParams: Params\n): Promise<Params> {\n  if (process.env.__NEXT_CACHE_COMPONENTS) {\n    return makeDynamicallyTrackedParamsWithDevWarnings(clientParams)\n  }\n\n  return makeDynamicallyTrackedExoticParamsWithDevWarnings(clientParams)\n}\n"],"names":["createRenderParamsFromClient","CachedParams","WeakMap","makeDynamicallyTrackedExoticParamsWithDevWarnings","underlyingParams","cachedParams","get","promise","Promise","resolve","proxiedProperties","Set","unproxiedProperties","Object","keys","forEach","prop","wellKnownProperties","has","add","proxiedPromise","Proxy","target","receiver","expression","describeStringPropertyAccess","warnForSyncAccess","ReflectAdapter","set","value","delete","ownKeys","warnForEnumeration","Reflect","makeDynamicallyTrackedParamsWithDevWarnings","console","error","missingProperties","length","describedMissingProperties","describeListOfPropertyNames","properties","InvariantError","description","i","clientParams","process","env","__NEXT_CACHE_COMPONENTS"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6027, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/request/params.browser.ts"],"sourcesContent":["export const createRenderParamsFromClient =\n  process.env.NODE_ENV === 'development'\n    ? (require('./params.browser.dev') as typeof import('./params.browser.dev'))\n        .createRenderParamsFromClient\n    : (\n        require('./params.browser.prod') as typeof import('./params.browser.prod')\n      ).createRenderParamsFromClient\n"],"names":["createRenderParamsFromClient","process","env","NODE_ENV","require"],"mappings":"AACEC,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;+BADdH,gCAAAA;;;eAAAA;;;AAAN,MAAMA,sEAENI,QAAQ,6JACNJ,4BAA4B,GAE7BI,QAAQ,yBACRJ,4BAA4B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6050, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/server/create-deduped-by-callsite-server-error-logger.ts"],"sourcesContent":["import * as React from 'react'\n\nconst errorRef: { current: null | Error } = { current: null }\n\n// React.cache is currently only available in canary/experimental React channels.\nconst cache =\n  typeof React.cache === 'function'\n    ? React.cache\n    : (fn: (key: unknown) => void) => fn\n\n// When Cache Components is enabled, we record these as errors so that they\n// are captured by the dev overlay as it's more critical to fix these\n// when enabled.\nconst logErrorOrWarn = process.env.__NEXT_CACHE_COMPONENTS\n  ? console.error\n  : console.warn\n\n// We don't want to dedupe across requests.\n// The developer might've just attempted to fix the warning so we should warn again if it still happens.\nconst flushCurrentErrorIfNew = cache(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key\n  (key: unknown) => {\n    try {\n      logErrorOrWarn(errorRef.current)\n    } finally {\n      errorRef.current = null\n    }\n  }\n)\n\n/**\n * Creates a function that logs an error message that is deduped by the userland\n * callsite.\n * This requires no indirection between the call of this function and the userland\n * callsite i.e. there's only a single library frame above this.\n * Do not use on the Client where sourcemaps and ignore listing might be enabled.\n * Only use that for warnings need a fix independent of the callstack.\n *\n * @param getMessage\n * @returns\n */\nexport function createDedupedByCallsiteServerErrorLoggerDev<Args extends any[]>(\n  getMessage: (...args: Args) => Error\n) {\n  return function logDedupedError(...args: Args) {\n    const message = getMessage(...args)\n\n    if (process.env.NODE_ENV !== 'production') {\n      const callStackFrames = new Error().stack?.split('\\n')\n      if (callStackFrames === undefined || callStackFrames.length < 4) {\n        logErrorOrWarn(message)\n      } else {\n        // Error:\n        //   logDedupedError\n        //   asyncApiBeingAccessedSynchronously\n        //   <userland callsite>\n        // TODO: This breaks if sourcemaps with ignore lists are enabled.\n        const key = callStackFrames[4]\n        errorRef.current = message\n        flushCurrentErrorIfNew(key)\n      }\n    } else {\n      logErrorOrWarn(message)\n    }\n  }\n}\n"],"names":["createDedupedByCallsiteServerErrorLoggerDev","errorRef","current","cache","React","fn","logErrorOrWarn","process","env","__NEXT_CACHE_COMPONENTS","console","error","warn","flushCurrentErrorIfNew","key","getMessage","logDedupedError","args","message","NODE_ENV","callStackFrames","Error","stack","split","undefined","length"],"mappings":"AAauBO,QAAQC,GAAG,CAACC,uBAAuB;;;;;+BA4B1CT,+CAAAA;;;eAAAA;;;+DAzCO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEvB,MAAMC,WAAsC;IAAEC,SAAS;AAAK;AAE5D,iFAAiF;AACjF,MAAMC,QACJ,OAAOC,OAAMD,KAAK,KAAK,aACnBC,OAAMD,KAAK,GACX,CAACE,KAA+BA;AAEtC,2EAA2E;AAC3E,qEAAqE;AACrE,gBAAgB;AAChB,MAAMC,uDACFI,QAAQC,KAAK,aACbD,QAAQE,IAAI;AAEhB,2CAA2C;AAC3C,wGAAwG;AACxG,MAAMC,yBAAyBV,MAC7B,AACA,CAACW,yEADyE;IAExE,IAAI;QACFR,eAAeL,SAASC,OAAO;IACjC,SAAU;QACRD,SAASC,OAAO,GAAG;IACrB;AACF;AAcK,SAASF,4CACde,UAAoC;IAEpC,OAAO,SAASC;;YAAmBC,uBAAH,KAAa;;QAC3C,MAAMC,UAAUH,cAAcE;QAE9B,IAAIV,QAAQC,GAAG,CAACW,QAAQ,KAAK,WAAc;gBACjB;YAAxB,MAAMC,kBAAAA,CAAkB,SAAA,IAAIC,QAAQC,KAAK,KAAA,OAAA,KAAA,IAAjB,OAAmBC,KAAK,CAAC;YACjD,IAAIH,oBAAoBI,aAAaJ,gBAAgBK,MAAM,GAAG,GAAG;gBAC/DnB,eAAeY;YACjB,OAAO;gBACL,SAAS;gBACT,oBAAoB;gBACpB,uCAAuC;gBACvC,wBAAwB;gBACxB,iEAAiE;gBACjE,MAAMJ,MAAMM,eAAe,CAAC,EAAE;gBAC9BnB,SAASC,OAAO,GAAGgB;gBACnBL,uBAAuBC;YACzB;QACF,OAAO;;IAGT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6150, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/server/app-render/after-task-async-storage-instance.ts"],"sourcesContent":["import type { AfterTaskAsyncStorage } from './after-task-async-storage.external'\nimport { createAsyncLocalStorage } from './async-local-storage'\n\nexport const afterTaskAsyncStorageInstance: AfterTaskAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["afterTaskAsyncStorageInstance","createAsyncLocalStorage"],"mappings":";;;+BAGaA,iCAAAA;;;eAAAA;;;mCAF2B;AAEjC,MAAMA,gCACXC,CAAAA,GAAAA,mBAAAA,uBAAuB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6165, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/server/app-render/after-task-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\n\n// Share the instance module in the next-shared layer\nimport { afterTaskAsyncStorageInstance as afterTaskAsyncStorage } from './after-task-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nimport type { WorkUnitStore } from './work-unit-async-storage.external'\n\nexport interface AfterTaskStore {\n  /** The phase in which the topmost `after` was called.\n   *\n   * NOTE: Can be undefined when running `generateStaticParams`,\n   * where we only have a `workStore`, no `workUnitStore`.\n   */\n  readonly rootTaskSpawnPhase: WorkUnitStore['phase'] | undefined\n}\n\nexport type AfterTaskAsyncStorage = AsyncLocalStorage<AfterTaskStore>\n\nexport { afterTaskAsyncStorage }\n"],"names":["afterTaskAsyncStorage"],"mappings":";;;+BAiBSA,yBAAAA;;;eAAAA,+BAAAA,6BAAqB;;;+CAdyC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6179, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/server/request/utils.ts"],"sourcesContent":["import { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { afterTaskAsyncStorage } from '../app-render/after-task-async-storage.external'\nimport type { WorkStore } from '../app-render/work-async-storage.external'\n\nexport function throwWithStaticGenerationBailoutError(\n  route: string,\n  expression: string\n): never {\n  throw new StaticGenBailoutError(\n    `Route ${route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n  )\n}\n\nexport function throwWithStaticGenerationBailoutErrorWithDynamicError(\n  route: string,\n  expression: string\n): never {\n  throw new StaticGenBailoutError(\n    `Route ${route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n  )\n}\n\nexport function throwForSearchParamsAccessInUseCache(\n  workStore: WorkStore,\n  constructorOpt: Function\n): never {\n  const error = new Error(\n    `Route ${workStore.route} used \"searchParams\" inside \"use cache\". Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await \"searchParams\" outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n  )\n\n  Error.captureStackTrace(error, constructorOpt)\n  workStore.invalidDynamicUsageError ??= error\n\n  throw error\n}\n\nexport function isRequestAPICallableInsideAfter() {\n  const afterTaskStore = afterTaskAsyncStorage.getStore()\n  return afterTaskStore?.rootTaskSpawnPhase === 'action'\n}\n"],"names":["isRequestAPICallableInsideAfter","throwForSearchParamsAccessInUseCache","throwWithStaticGenerationBailoutError","throwWithStaticGenerationBailoutErrorWithDynamicError","route","expression","StaticGenBailoutError","workStore","constructorOpt","error","Error","captureStackTrace","invalidDynamicUsageError","afterTaskStore","afterTaskAsyncStorage","getStore","rootTaskSpawnPhase"],"mappings":";;;;;;;;;;;;;;;;IAoCgBA,+BAA+B,EAAA;eAA/BA;;IAdAC,oCAAoC,EAAA;eAApCA;;IAlBAC,qCAAqC,EAAA;eAArCA;;IASAC,qDAAqD,EAAA;eAArDA;;;yCAbsB;+CACA;AAG/B,SAASD,sCACdE,KAAa,EACbC,UAAkB;IAElB,MAAM,OAAA,cAEL,CAFK,IAAIC,yBAAAA,qBAAqB,CAC7B,AAAC,MAAM,UAAEF,OAAM,iDAAiD,WAAEC,YAAW,0HAA0H,CAAC,KADpM,qBAAA;eAAA;oBAAA;sBAAA;IAEN;AACF;AAEO,SAASF,sDACdC,KAAa,EACbC,UAAkB;IAElB,MAAM,OAAA,cAEL,CAFK,IAAIC,yBAAAA,qBAAqB,CAC7B,AAAC,MAAM,UAAEF,OAAM,4EAA4E,UAAEC,YAAW,0HAA0H,CAAC,KAD/N,qBAAA;eAAA;oBAAA;sBAAA;IAEN;AACF;AAEO,SAASJ,qCACdM,SAAoB,EACpBC,cAAwB;QAOxBD;IALA,MAAME,QAAQ,OAAA,cAEb,CAFa,IAAIC,MAChB,AAAC,MAAM,UAAEH,UAAUH,KAAK,EAAC,uXAAuX,CAAC,KADrY,qBAAA;eAAA;oBAAA;sBAAA;IAEd;IAEAM,MAAMC,iBAAiB,CAACF,OAAOD;;8KACrBI,wBAAwB,GAAKH;IAEvC,MAAMA;AACR;AAEO,SAAST;IACd,MAAMa,iBAAiBC,+BAAAA,qBAAqB,CAACC,QAAQ;IACrD,OAAOF,CAAAA,kBAAAA,OAAAA,KAAAA,IAAAA,eAAgBG,kBAAkB,MAAK;AAChD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6244, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/server/request/search-params.ts"],"sourcesContent":["import type { WorkStore } from '../app-render/work-async-storage.external'\n\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\nimport {\n  throwToInterruptStaticGeneration,\n  postponeWithTracking,\n  trackDynamicDataInDynamicRender,\n  annotateDynamicAccess,\n  trackSynchronousRequestDataAccessInDev,\n  delayUntilRuntimeStage,\n} from '../app-render/dynamic-rendering'\n\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStoreLegacy,\n  type PrerenderStorePPR,\n  type PrerenderStoreModern,\n  type PrerenderStoreModernRuntime,\n  type StaticPrerenderStore,\n  throwInvariantForMissingStore,\n} from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport {\n  describeStringPropertyAccess,\n  describeHasCheckingStringProperty,\n  wellKnownProperties,\n} from '../../shared/lib/utils/reflect-utils'\nimport {\n  throwWithStaticGenerationBailoutErrorWithDynamicError,\n  throwForSearchParamsAccessInUseCache,\n} from './utils'\n\nexport type SearchParams = { [key: string]: string | string[] | undefined }\n\n/**\n * In this version of Next.js the `params` prop passed to Layouts, Pages, and other Segments is a Promise.\n * However to facilitate migration to this new Promise type you can currently still access params directly on the Promise instance passed to these Segments.\n * The `UnsafeUnwrappedSearchParams` type is available if you need to temporarily access the underlying params without first awaiting or `use`ing the Promise.\n *\n * In a future version of Next.js the `params` prop will be a plain Promise and this type will be removed.\n *\n * Typically instances of `params` can be updated automatically to be treated as a Promise by a codemod published alongside this Next.js version however if you\n * have not yet run the codemod of the codemod cannot detect certain instances of `params` usage you should first try to refactor your code to await `params`.\n *\n * If refactoring is not possible but you still want to be able to access params directly without typescript errors you can cast the params Promise to this type\n *\n * ```tsx\n * type Props = { searchParams: Promise<{ foo: string }> }\n *\n * export default async function Page(props: Props) {\n *  const { searchParams } = (props.searchParams as unknown as UnsafeUnwrappedSearchParams<typeof props.searchParams>)\n *  return ...\n * }\n * ```\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedSearchParams<P> =\n  P extends Promise<infer U> ? Omit<U, 'then' | 'status' | 'value'> : never\n\nexport function createSearchParamsFromClient(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore\n): Promise<SearchParams> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderSearchParams(workStore, workUnitStore)\n      case 'prerender-runtime':\n        throw new InvariantError(\n          'createSearchParamsFromClient should not be called in a runtime prerender.'\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createSearchParamsFromClient should not be called in cache contexts.'\n        )\n      case 'request':\n        return createRenderSearchParams(underlyingSearchParams, workStore)\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\nexport const createServerSearchParamsForMetadata =\n  createServerSearchParamsForServerPage\n\nexport function createServerSearchParamsForServerPage(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore\n): Promise<SearchParams> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderSearchParams(workStore, workUnitStore)\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createServerSearchParamsForServerPage should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        return createRuntimePrerenderSearchParams(\n          underlyingSearchParams,\n          workUnitStore\n        )\n      case 'request':\n        return createRenderSearchParams(underlyingSearchParams, workStore)\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nexport function createPrerenderSearchParamsForClientPage(\n  workStore: WorkStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  }\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n        // We're prerendering in a mode that aborts (cacheComponents) and should stall\n        // the promise to ensure the RSC side is considered dynamic\n        return makeHangingPromise(\n          workUnitStore.renderSignal,\n          workStore.route,\n          '`searchParams`'\n        )\n      case 'prerender-runtime':\n        throw new InvariantError(\n          'createPrerenderSearchParamsForClientPage should not be called in a runtime prerender.'\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createPrerenderSearchParamsForClientPage should not be called in cache contexts.'\n        )\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'request':\n        return Promise.resolve({})\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nfunction createStaticPrerenderSearchParams(\n  workStore: WorkStore,\n  prerenderStore: StaticPrerenderStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  }\n\n  switch (prerenderStore.type) {\n    case 'prerender':\n    case 'prerender-client':\n      // We are in a cacheComponents (PPR or otherwise) prerender\n      return makeHangingSearchParams(workStore, prerenderStore)\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n      // We are in a legacy static generation and need to interrupt the\n      // prerender when search params are accessed.\n      return makeErroringExoticSearchParams(workStore, prerenderStore)\n    default:\n      return prerenderStore satisfies never\n  }\n}\n\nfunction createRuntimePrerenderSearchParams(\n  underlyingSearchParams: SearchParams,\n  workUnitStore: PrerenderStoreModernRuntime\n): Promise<SearchParams> {\n  return delayUntilRuntimeStage(\n    workUnitStore,\n    process.env.__NEXT_CACHE_COMPONENTS\n      ? makeUntrackedSearchParams(underlyingSearchParams)\n      : makeUntrackedExoticSearchParams(underlyingSearchParams)\n  )\n}\n\nfunction createRenderSearchParams(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      // Semantically we only need the dev tracking when running in `next dev`\n      // but since you would never use next dev with production NODE_ENV we use this\n      // as a proxy so we can statically exclude this code from production builds.\n      if (process.env.__NEXT_CACHE_COMPONENTS) {\n        return makeUntrackedSearchParamsWithDevWarnings(\n          underlyingSearchParams,\n          workStore\n        )\n      }\n\n      return makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(\n        underlyingSearchParams,\n        workStore\n      )\n    } else {\n      if (process.env.__NEXT_CACHE_COMPONENTS) {\n        return makeUntrackedSearchParams(underlyingSearchParams)\n      }\n\n      return makeUntrackedExoticSearchParams(underlyingSearchParams)\n    }\n  }\n}\n\ninterface CacheLifetime {}\nconst CachedSearchParams = new WeakMap<CacheLifetime, Promise<SearchParams>>()\n\nconst CachedSearchParamsForUseCache = new WeakMap<\n  CacheLifetime,\n  Promise<SearchParams>\n>()\n\nfunction makeHangingSearchParams(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStoreModern\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(prerenderStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = makeHangingPromise<SearchParams>(\n    prerenderStore.renderSignal,\n    workStore.route,\n    '`searchParams`'\n  )\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it.\n        // We know it isn't a dynamic access because it can only be something\n        // that was previously written to the promise and thus not an underlying searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      switch (prop) {\n        case 'then': {\n          const expression =\n            '`await searchParams`, `searchParams.then`, or similar'\n          annotateDynamicAccess(expression, prerenderStore)\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n        case 'status': {\n          const expression =\n            '`use(searchParams)`, `searchParams.status`, or similar'\n          annotateDynamicAccess(expression, prerenderStore)\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n\n        default: {\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n      }\n    },\n  })\n\n  CachedSearchParams.set(prerenderStore, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction makeErroringExoticSearchParams(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStoreLegacy | PrerenderStorePPR\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(workStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const underlyingSearchParams = {}\n  // For search params we don't construct a ReactPromise because we want to interrupt\n  // rendering on any property access that was not set from outside and so we only want\n  // to have properties like value and status if React sets them.\n  const promise = Promise.resolve(underlyingSearchParams)\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it.\n        // We know it isn't a dynamic access because it can only be something\n        // that was previously written to the promise and thus not an underlying searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      switch (prop) {\n        case 'then': {\n          const expression =\n            '`await searchParams`, `searchParams.then`, or similar'\n          if (workStore.dynamicShouldError) {\n            throwWithStaticGenerationBailoutErrorWithDynamicError(\n              workStore.route,\n              expression\n            )\n          } else if (prerenderStore.type === 'prerender-ppr') {\n            // PPR Prerender (no cacheComponents)\n            postponeWithTracking(\n              workStore.route,\n              expression,\n              prerenderStore.dynamicTracking\n            )\n          } else {\n            // Legacy Prerender\n            throwToInterruptStaticGeneration(\n              expression,\n              workStore,\n              prerenderStore\n            )\n          }\n          return\n        }\n        case 'status': {\n          const expression =\n            '`use(searchParams)`, `searchParams.status`, or similar'\n          if (workStore.dynamicShouldError) {\n            throwWithStaticGenerationBailoutErrorWithDynamicError(\n              workStore.route,\n              expression\n            )\n          } else if (prerenderStore.type === 'prerender-ppr') {\n            // PPR Prerender (no cacheComponents)\n            postponeWithTracking(\n              workStore.route,\n              expression,\n              prerenderStore.dynamicTracking\n            )\n          } else {\n            // Legacy Prerender\n            throwToInterruptStaticGeneration(\n              expression,\n              workStore,\n              prerenderStore\n            )\n          }\n          return\n        }\n        default: {\n          if (typeof prop === 'string' && !wellKnownProperties.has(prop)) {\n            const expression = describeStringPropertyAccess(\n              'searchParams',\n              prop\n            )\n            if (workStore.dynamicShouldError) {\n              throwWithStaticGenerationBailoutErrorWithDynamicError(\n                workStore.route,\n                expression\n              )\n            } else if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no cacheComponents)\n              postponeWithTracking(\n                workStore.route,\n                expression,\n                prerenderStore.dynamicTracking\n              )\n            } else {\n              // Legacy Prerender\n              throwToInterruptStaticGeneration(\n                expression,\n                workStore,\n                prerenderStore\n              )\n            }\n          }\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n      }\n    },\n    has(target, prop) {\n      // We don't expect key checking to be used except for testing the existence of\n      // searchParams so we make all has tests trigger dynamic. this means that `promise.then`\n      // can resolve to the then function on the Promise prototype but 'then' in promise will assume\n      // you are testing whether the searchParams has a 'then' property.\n      if (typeof prop === 'string') {\n        const expression = describeHasCheckingStringProperty(\n          'searchParams',\n          prop\n        )\n        if (workStore.dynamicShouldError) {\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            workStore.route,\n            expression\n          )\n        } else if (prerenderStore.type === 'prerender-ppr') {\n          // PPR Prerender (no cacheComponents)\n          postponeWithTracking(\n            workStore.route,\n            expression,\n            prerenderStore.dynamicTracking\n          )\n        } else {\n          // Legacy Prerender\n          throwToInterruptStaticGeneration(\n            expression,\n            workStore,\n            prerenderStore\n          )\n        }\n        return false\n      }\n      return ReflectAdapter.has(target, prop)\n    },\n    ownKeys() {\n      const expression =\n        '`{...searchParams}`, `Object.keys(searchParams)`, or similar'\n      if (workStore.dynamicShouldError) {\n        throwWithStaticGenerationBailoutErrorWithDynamicError(\n          workStore.route,\n          expression\n        )\n      } else if (prerenderStore.type === 'prerender-ppr') {\n        // PPR Prerender (no cacheComponents)\n        postponeWithTracking(\n          workStore.route,\n          expression,\n          prerenderStore.dynamicTracking\n        )\n      } else {\n        // Legacy Prerender\n        throwToInterruptStaticGeneration(expression, workStore, prerenderStore)\n      }\n    },\n  })\n\n  CachedSearchParams.set(workStore, proxiedPromise)\n  return proxiedPromise\n}\n\n/**\n * This is a variation of `makeErroringExoticSearchParams` that always throws an\n * error on access, because accessing searchParams inside of `\"use cache\"` is\n * not allowed.\n */\nexport function makeErroringSearchParamsForUseCache(\n  workStore: WorkStore\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParamsForUseCache.get(workStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = Promise.resolve({})\n\n  const proxiedPromise = new Proxy(promise, {\n    get: function get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it. We know it\n        // isn't a dynamic access because it can only be something that was\n        // previously written to the promise and thus not an underlying\n        // searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      if (\n        typeof prop === 'string' &&\n        (prop === 'then' || !wellKnownProperties.has(prop))\n      ) {\n        throwForSearchParamsAccessInUseCache(workStore, get)\n      }\n\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    has: function has(target, prop) {\n      // We don't expect key checking to be used except for testing the existence of\n      // searchParams so we make all has tests throw an error. this means that `promise.then`\n      // can resolve to the then function on the Promise prototype but 'then' in promise will assume\n      // you are testing whether the searchParams has a 'then' property.\n      if (\n        typeof prop === 'string' &&\n        (prop === 'then' || !wellKnownProperties.has(prop))\n      ) {\n        throwForSearchParamsAccessInUseCache(workStore, has)\n      }\n\n      return ReflectAdapter.has(target, prop)\n    },\n    ownKeys: function ownKeys() {\n      throwForSearchParamsAccessInUseCache(workStore, ownKeys)\n    },\n  })\n\n  CachedSearchParamsForUseCache.set(workStore, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction makeUntrackedExoticSearchParams(\n  underlyingSearchParams: SearchParams\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  // We don't use makeResolvedReactPromise here because searchParams\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingSearchParams)\n  CachedSearchParams.set(underlyingSearchParams, promise)\n\n  Object.keys(underlyingSearchParams).forEach((prop) => {\n    if (!wellKnownProperties.has(prop)) {\n      Object.defineProperty(promise, prop, {\n        get() {\n          const workUnitStore = workUnitAsyncStorage.getStore()\n          if (workUnitStore) {\n            trackDynamicDataInDynamicRender(workUnitStore)\n          }\n          return underlyingSearchParams[prop]\n        },\n        set(value) {\n          Object.defineProperty(promise, prop, {\n            value,\n            writable: true,\n            enumerable: true,\n          })\n        },\n        enumerable: true,\n        configurable: true,\n      })\n    }\n  })\n\n  return promise\n}\n\nfunction makeUntrackedSearchParams(\n  underlyingSearchParams: SearchParams\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = Promise.resolve(underlyingSearchParams)\n  CachedSearchParams.set(underlyingSearchParams, promise)\n\n  return promise\n}\n\nfunction makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(\n  underlyingSearchParams: SearchParams,\n  store: WorkStore\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const proxiedProperties = new Set<string>()\n  const unproxiedProperties: Array<string> = []\n\n  // We have an unfortunate sequence of events that requires this initialization logic. We want to instrument the underlying\n  // searchParams object to detect if you are accessing values in dev. This is used for warnings and for things like the static prerender\n  // indicator. However when we pass this proxy to our Promise.resolve() below the VM checks if the resolved value is a promise by looking\n  // at the `.then` property. To our dynamic tracking logic this is indistinguishable from a `then` searchParam and so we would normally trigger\n  // dynamic tracking. However we know that this .then is not real dynamic access, it's just how thenables resolve in sequence. So we introduce\n  // this initialization concept so we omit the dynamic check until after we've constructed our resolved promise.\n  let promiseInitialized = false\n  const proxiedUnderlying = new Proxy(underlyingSearchParams, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string' && promiseInitialized) {\n        if (store.dynamicShouldError) {\n          const expression = describeStringPropertyAccess('searchParams', prop)\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            store.route,\n            expression\n          )\n        }\n        const workUnitStore = workUnitAsyncStorage.getStore()\n        if (workUnitStore) {\n          trackDynamicDataInDynamicRender(workUnitStore)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (store.dynamicShouldError) {\n          const expression = describeHasCheckingStringProperty(\n            'searchParams',\n            prop\n          )\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            store.route,\n            expression\n          )\n        }\n      }\n      return Reflect.has(target, prop)\n    },\n    ownKeys(target) {\n      if (store.dynamicShouldError) {\n        const expression =\n          '`{...searchParams}`, `Object.keys(searchParams)`, or similar'\n        throwWithStaticGenerationBailoutErrorWithDynamicError(\n          store.route,\n          expression\n        )\n      }\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  // We don't use makeResolvedReactPromise here because searchParams\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = makeDevtoolsIOAwarePromise(underlyingSearchParams)\n  promise.then(() => {\n    promiseInitialized = true\n  })\n\n  Object.keys(underlyingSearchParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n      unproxiedProperties.push(prop)\n    } else {\n      proxiedProperties.add(prop)\n      Object.defineProperty(promise, prop, {\n        get() {\n          return proxiedUnderlying[prop]\n        },\n        set(newValue) {\n          Object.defineProperty(promise, prop, {\n            value: newValue,\n            writable: true,\n            enumerable: true,\n          })\n        },\n        enumerable: true,\n        configurable: true,\n      })\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (prop === 'then' && store.dynamicShouldError) {\n        const expression = '`searchParams.then`'\n        throwWithStaticGenerationBailoutErrorWithDynamicError(\n          store.route,\n          expression\n        )\n      }\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeStringPropertyAccess('searchParams', prop)\n          syncIODev(store.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return Reflect.set(target, prop, value, receiver)\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeHasCheckingStringProperty(\n            'searchParams',\n            prop\n          )\n          syncIODev(store.route, expression)\n        }\n      }\n      return Reflect.has(target, prop)\n    },\n    ownKeys(target) {\n      const expression = '`Object.keys(searchParams)` or similar'\n      syncIODev(store.route, expression, unproxiedProperties)\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedSearchParams.set(underlyingSearchParams, proxiedPromise)\n  return proxiedPromise\n}\n\n// Similar to `makeDynamicallyTrackedExoticSearchParamsWithDevWarnings`, but\n// just logging the sync access without actually defining the search params on\n// the promise.\nfunction makeUntrackedSearchParamsWithDevWarnings(\n  underlyingSearchParams: SearchParams,\n  store: WorkStore\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const proxiedProperties = new Set<string>()\n  const unproxiedProperties: Array<string> = []\n  const promise = makeDevtoolsIOAwarePromise(underlyingSearchParams)\n\n  Object.keys(underlyingSearchParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n      unproxiedProperties.push(prop)\n    } else {\n      proxiedProperties.add(prop)\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeStringPropertyAccess('searchParams', prop)\n          warnForSyncAccess(store.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return Reflect.set(target, prop, value, receiver)\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeHasCheckingStringProperty(\n            'searchParams',\n            prop\n          )\n          warnForSyncAccess(store.route, expression)\n        }\n      }\n      return Reflect.has(target, prop)\n    },\n    ownKeys(target) {\n      const expression = '`Object.keys(searchParams)` or similar'\n      warnForIncompleteEnumeration(store.route, expression, unproxiedProperties)\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedSearchParams.set(underlyingSearchParams, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction syncIODev(\n  route: string | undefined,\n  expression: string,\n  missingProperties?: Array<string>\n) {\n  // In all cases we warn normally\n  if (missingProperties && missingProperties.length > 0) {\n    warnForIncompleteEnumeration(route, expression, missingProperties)\n  } else {\n    warnForSyncAccess(route, expression)\n  }\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'request':\n        if (workUnitStore.prerenderPhase === true) {\n          // When we're rendering dynamically in dev, we need to advance out of\n          // the Prerender environment when we read Request data synchronously.\n          trackSynchronousRequestDataAccessInDev(workUnitStore)\n        }\n        break\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-runtime':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createSearchAccessError\n)\n\nconst warnForIncompleteEnumeration =\n  createDedupedByCallsiteServerErrorLoggerDev(createIncompleteEnumerationError)\n\nfunction createSearchAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`searchParams\\` should be awaited before using its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction createIncompleteEnumerationError(\n  route: string | undefined,\n  expression: string,\n  missingProperties: Array<string>\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`searchParams\\` should be awaited before using its properties. ` +\n      `The following properties were not available through enumeration ` +\n      `because they conflict with builtin or well-known property names: ` +\n      `${describeListOfPropertyNames(missingProperties)}. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction describeListOfPropertyNames(properties: Array<string>) {\n  switch (properties.length) {\n    case 0:\n      throw new InvariantError(\n        'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'\n      )\n    case 1:\n      return `\\`${properties[0]}\\``\n    case 2:\n      return `\\`${properties[0]}\\` and \\`${properties[1]}\\``\n    default: {\n      let description = ''\n      for (let i = 0; i < properties.length - 1; i++) {\n        description += `\\`${properties[i]}\\`, `\n      }\n      description += `, and \\`${properties[properties.length - 1]}\\``\n      return description\n    }\n  }\n}\n"],"names":["createPrerenderSearchParamsForClientPage","createSearchParamsFromClient","createServerSearchParamsForMetadata","createServerSearchParamsForServerPage","makeErroringSearchParamsForUseCache","underlyingSearchParams","workStore","workUnitStore","workUnitAsyncStorage","getStore","type","createStaticPrerenderSearchParams","InvariantError","createRenderSearchParams","throwInvariantForMissingStore","createRuntimePrerenderSearchParams","forceStatic","Promise","resolve","makeHangingPromise","renderSignal","route","prerenderStore","makeHangingSearchParams","makeErroringExoticSearchParams","delayUntilRuntimeStage","process","env","__NEXT_CACHE_COMPONENTS","makeUntrackedSearchParams","makeUntrackedExoticSearchParams","NODE_ENV","makeUntrackedSearchParamsWithDevWarnings","makeDynamicallyTrackedExoticSearchParamsWithDevWarnings","CachedSearchParams","WeakMap","CachedSearchParamsForUseCache","cachedSearchParams","get","promise","proxiedPromise","Proxy","target","prop","receiver","Object","hasOwn","ReflectAdapter","expression","annotateDynamicAccess","set","dynamicShouldError","throwWithStaticGenerationBailoutErrorWithDynamicError","postponeWithTracking","dynamicTracking","throwToInterruptStaticGeneration","wellKnownProperties","has","describeStringPropertyAccess","describeHasCheckingStringProperty","ownKeys","throwForSearchParamsAccessInUseCache","keys","forEach","defineProperty","trackDynamicDataInDynamicRender","value","writable","enumerable","configurable","store","proxiedProperties","Set","unproxiedProperties","promiseInitialized","proxiedUnderlying","Reflect","makeDevtoolsIOAwarePromise","then","push","add","newValue","syncIODev","delete","warnForSyncAccess","warnForIncompleteEnumeration","missingProperties","length","prerenderPhase","trackSynchronousRequestDataAccessInDev","createDedupedByCallsiteServerErrorLoggerDev","createSearchAccessError","createIncompleteEnumerationError","prefix","Error","describeListOfPropertyNames","properties","description","i"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6895, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/server/app-render/dynamic-access-async-storage-instance.ts"],"sourcesContent":["import { createAsyncLocalStorage } from './async-local-storage'\nimport type { DynamicAccessStorage } from './dynamic-access-async-storage.external'\n\nexport const dynamicAccessAsyncStorageInstance: DynamicAccessStorage =\n  createAsyncLocalStorage()\n"],"names":["dynamicAccessAsyncStorageInstance","createAsyncLocalStorage"],"mappings":";;;+BAGaA,qCAAAA;;;eAAAA;;;mCAH2B;AAGjC,MAAMA,oCACXC,CAAAA,GAAAA,mBAAAA,uBAAuB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6910, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/server/app-render/dynamic-access-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\n\n// Share the instance module in the next-shared layer\nimport { dynamicAccessAsyncStorageInstance } from './dynamic-access-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\n\nexport interface DynamicAccessAsyncStore {\n  readonly abortController: AbortController\n}\n\nexport type DynamicAccessStorage = AsyncLocalStorage<DynamicAccessAsyncStore>\nexport { dynamicAccessAsyncStorageInstance as dynamicAccessAsyncStorage }\n"],"names":["dynamicAccessAsyncStorage","dynamicAccessAsyncStorageInstance"],"mappings":";;;+BAU8CA,6BAAAA;;;eAArCC,mCAAAA,iCAAiC;;;mDAPQ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6924, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/server/request/params.ts"],"sourcesContent":["import {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport type { FallbackRouteParams } from './fallback-params'\n\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\nimport {\n  throwToInterruptStaticGeneration,\n  postponeWithTracking,\n  trackSynchronousRequestDataAccessInDev,\n  delayUntilRuntimeStage,\n} from '../app-render/dynamic-rendering'\n\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStorePPR,\n  type PrerenderStoreLegacy,\n  type StaticPrerenderStoreModern,\n  type StaticPrerenderStore,\n  throwInvariantForMissingStore,\n  type PrerenderStoreModernRuntime,\n} from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport {\n  describeStringPropertyAccess,\n  wellKnownProperties,\n} from '../../shared/lib/utils/reflect-utils'\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { dynamicAccessAsyncStorage } from '../app-render/dynamic-access-async-storage.external'\n\nexport type ParamValue = string | Array<string> | undefined\nexport type Params = Record<string, ParamValue>\n\n/**\n * In this version of Next.js the `params` prop passed to Layouts, Pages, and other Segments is a Promise.\n * However to facilitate migration to this new Promise type you can currently still access params directly on the Promise instance passed to these Segments.\n * The `UnsafeUnwrappedParams` type is available if you need to temporarily access the underlying params without first awaiting or `use`ing the Promise.\n *\n * In a future version of Next.js the `params` prop will be a plain Promise and this type will be removed.\n *\n * Typically instances of `params` can be updated automatically to be treated as a Promise by a codemod published alongside this Next.js version however if you\n * have not yet run the codemod of the codemod cannot detect certain instances of `params` usage you should first try to refactor your code to await `params`.\n *\n * If refactoring is not possible but you still want to be able to access params directly without typescript errors you can cast the params Promise to this type\n *\n * ```tsx\n * type Props = { params: Promise<{ id: string }>}\n *\n * export default async function Layout(props: Props) {\n *  const directParams = (props.params as unknown as UnsafeUnwrappedParams<typeof props.params>)\n *  return ...\n * }\n * ```\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedParams<P> =\n  P extends Promise<infer U> ? Omit<U, 'then' | 'status' | 'value'> : never\n\nexport function createParamsFromClient(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderParams(\n          underlyingParams,\n          workStore,\n          workUnitStore\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createParamsFromClient should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        throw new InvariantError(\n          'createParamsFromClient should not be called in a runtime prerender.'\n        )\n      case 'request':\n        if (process.env.NODE_ENV === 'development') {\n          // Semantically we only need the dev tracking when running in `next dev`\n          // but since you would never use next dev with production NODE_ENV we use this\n          // as a proxy so we can statically exclude this code from production builds.\n          const devFallbackParams = workUnitStore.devFallbackParams\n          return createRenderParamsInDev(\n            underlyingParams,\n            devFallbackParams,\n            workStore\n          )\n        } else {\n          return createRenderParamsInProd(underlyingParams)\n        }\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\nexport type CreateServerParamsForMetadata = typeof createServerParamsForMetadata\nexport const createServerParamsForMetadata = createServerParamsForServerSegment\n\n// routes always runs in RSC context so it is equivalent to a Server Page Component\nexport function createServerParamsForRoute(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderParams(\n          underlyingParams,\n          workStore,\n          workUnitStore\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createServerParamsForRoute should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        return createRuntimePrerenderParams(underlyingParams, workUnitStore)\n      case 'request':\n        if (process.env.NODE_ENV === 'development') {\n          // Semantically we only need the dev tracking when running in `next dev`\n          // but since you would never use next dev with production NODE_ENV we use this\n          // as a proxy so we can statically exclude this code from production builds.\n          const devFallbackParams = workUnitStore.devFallbackParams\n          return createRenderParamsInDev(\n            underlyingParams,\n            devFallbackParams,\n            workStore\n          )\n        } else {\n          return createRenderParamsInProd(underlyingParams)\n        }\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nexport function createServerParamsForServerSegment(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderParams(\n          underlyingParams,\n          workStore,\n          workUnitStore\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createServerParamsForServerSegment should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        return createRuntimePrerenderParams(underlyingParams, workUnitStore)\n      case 'request':\n        if (process.env.NODE_ENV === 'development') {\n          // Semantically we only need the dev tracking when running in `next dev`\n          // but since you would never use next dev with production NODE_ENV we use this\n          // as a proxy so we can statically exclude this code from production builds.\n          const devFallbackParams = workUnitStore.devFallbackParams\n          return createRenderParamsInDev(\n            underlyingParams,\n            devFallbackParams,\n            workStore\n          )\n        } else {\n          return createRenderParamsInProd(underlyingParams)\n        }\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nexport function createPrerenderParamsForClientSegment(\n  underlyingParams: Params\n): Promise<Params> {\n  const workStore = workAsyncStorage.getStore()\n  if (!workStore) {\n    throw new InvariantError(\n      'Missing workStore in createPrerenderParamsForClientSegment'\n    )\n  }\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        if (fallbackParams) {\n          for (let key in underlyingParams) {\n            if (fallbackParams.has(key)) {\n              // This params object has one or more fallback params, so we need\n              // to consider the awaiting of this params object \"dynamic\". Since\n              // we are in cacheComponents mode we encode this as a promise that never\n              // resolves.\n              return makeHangingPromise(\n                workUnitStore.renderSignal,\n                workStore.route,\n                '`params`'\n              )\n            }\n          }\n        }\n        break\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createPrerenderParamsForClientSegment should not be called in cache contexts.'\n        )\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'prerender-runtime':\n      case 'request':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  // We're prerendering in a mode that does not abort. We resolve the promise without\n  // any tracking because we're just transporting a value from server to client where the tracking\n  // will be applied.\n  return Promise.resolve(underlyingParams)\n}\n\nfunction createStaticPrerenderParams(\n  underlyingParams: Params,\n  workStore: WorkStore,\n  prerenderStore: StaticPrerenderStore\n): Promise<Params> {\n  switch (prerenderStore.type) {\n    case 'prerender':\n    case 'prerender-client': {\n      const fallbackParams = prerenderStore.fallbackRouteParams\n      if (fallbackParams) {\n        for (const key in underlyingParams) {\n          if (fallbackParams.has(key)) {\n            // This params object has one or more fallback params, so we need\n            // to consider the awaiting of this params object \"dynamic\". Since\n            // we are in cacheComponents mode we encode this as a promise that never\n            // resolves.\n            return makeHangingParams(\n              underlyingParams,\n              workStore,\n              prerenderStore\n            )\n          }\n        }\n      }\n      break\n    }\n    case 'prerender-ppr': {\n      const fallbackParams = prerenderStore.fallbackRouteParams\n      if (fallbackParams) {\n        for (const key in underlyingParams) {\n          if (fallbackParams.has(key)) {\n            return makeErroringExoticParams(\n              underlyingParams,\n              fallbackParams,\n              workStore,\n              prerenderStore\n            )\n          }\n        }\n      }\n      break\n    }\n    case 'prerender-legacy':\n      break\n    default:\n      prerenderStore satisfies never\n  }\n\n  if (process.env.__NEXT_CACHE_COMPONENTS) {\n    return makeUntrackedParams(underlyingParams)\n  } else {\n    return makeUntrackedExoticParams(underlyingParams)\n  }\n}\n\nfunction createRuntimePrerenderParams(\n  underlyingParams: Params,\n  workUnitStore: PrerenderStoreModernRuntime\n): Promise<Params> {\n  return delayUntilRuntimeStage(\n    workUnitStore,\n    process.env.__NEXT_CACHE_COMPONENTS\n      ? makeUntrackedParams(underlyingParams)\n      : makeUntrackedExoticParams(underlyingParams)\n  )\n}\n\nfunction createRenderParamsInProd(underlyingParams: Params): Promise<Params> {\n  if (process.env.__NEXT_CACHE_COMPONENTS) {\n    return makeUntrackedParams(underlyingParams)\n  }\n\n  return makeUntrackedExoticParams(underlyingParams)\n}\n\nfunction createRenderParamsInDev(\n  underlyingParams: Params,\n  devFallbackParams: FallbackRouteParams | null | undefined,\n  workStore: WorkStore\n): Promise<Params> {\n  let hasFallbackParams = false\n  if (devFallbackParams) {\n    for (let key in underlyingParams) {\n      if (devFallbackParams.has(key)) {\n        hasFallbackParams = true\n        break\n      }\n    }\n  }\n  if (process.env.__NEXT_CACHE_COMPONENTS) {\n    return makeDynamicallyTrackedParamsWithDevWarnings(\n      underlyingParams,\n      hasFallbackParams,\n      workStore\n    )\n  }\n\n  return makeDynamicallyTrackedExoticParamsWithDevWarnings(\n    underlyingParams,\n    hasFallbackParams,\n    workStore\n  )\n}\n\ninterface CacheLifetime {}\nconst CachedParams = new WeakMap<CacheLifetime, Promise<Params>>()\n\nconst fallbackParamsProxyHandler: ProxyHandler<Promise<Params>> = {\n  get: function get(target, prop, receiver) {\n    if (prop === 'then' || prop === 'catch' || prop === 'finally') {\n      const originalMethod = ReflectAdapter.get(target, prop, receiver)\n\n      return {\n        [prop]: (...args: unknown[]) => {\n          const store = dynamicAccessAsyncStorage.getStore()\n\n          if (store) {\n            store.abortController.abort(\n              new Error(`Accessed fallback \\`params\\` during prerendering.`)\n            )\n          }\n\n          return new Proxy(\n            originalMethod.apply(target, args),\n            fallbackParamsProxyHandler\n          )\n        },\n      }[prop]\n    }\n\n    return ReflectAdapter.get(target, prop, receiver)\n  },\n}\n\nfunction makeHangingParams(\n  underlyingParams: Params,\n  workStore: WorkStore,\n  prerenderStore: StaticPrerenderStoreModern\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = new Proxy(\n    makeHangingPromise<Params>(\n      prerenderStore.renderSignal,\n      workStore.route,\n      '`params`'\n    ),\n    fallbackParamsProxyHandler\n  )\n\n  CachedParams.set(underlyingParams, promise)\n\n  return promise\n}\n\nfunction makeErroringExoticParams(\n  underlyingParams: Params,\n  fallbackParams: FallbackRouteParams,\n  workStore: WorkStore,\n  prerenderStore: PrerenderStorePPR | PrerenderStoreLegacy\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const augmentedUnderlying = { ...underlyingParams }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(augmentedUnderlying)\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      if (fallbackParams.has(prop)) {\n        Object.defineProperty(augmentedUnderlying, prop, {\n          get() {\n            const expression = describeStringPropertyAccess('params', prop)\n            // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n            // for params is only dynamic when we're generating a fallback shell\n            // and even when `dynamic = \"error\"` we still support generating dynamic\n            // fallback shells\n            // TODO remove this comment when cacheComponents is the default since there\n            // will be no `dynamic = \"error\"`\n            if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no cacheComponents)\n              postponeWithTracking(\n                workStore.route,\n                expression,\n                prerenderStore.dynamicTracking\n              )\n            } else {\n              // Legacy Prerender\n              throwToInterruptStaticGeneration(\n                expression,\n                workStore,\n                prerenderStore\n              )\n            }\n          },\n          enumerable: true,\n        })\n        Object.defineProperty(promise, prop, {\n          get() {\n            const expression = describeStringPropertyAccess('params', prop)\n            // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n            // for params is only dynamic when we're generating a fallback shell\n            // and even when `dynamic = \"error\"` we still support generating dynamic\n            // fallback shells\n            // TODO remove this comment when cacheComponents is the default since there\n            // will be no `dynamic = \"error\"`\n            if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no cacheComponents)\n              postponeWithTracking(\n                workStore.route,\n                expression,\n                prerenderStore.dynamicTracking\n              )\n            } else {\n              // Legacy Prerender\n              throwToInterruptStaticGeneration(\n                expression,\n                workStore,\n                prerenderStore\n              )\n            }\n          },\n          set(newValue) {\n            Object.defineProperty(promise, prop, {\n              value: newValue,\n              writable: true,\n              enumerable: true,\n            })\n          },\n          enumerable: true,\n          configurable: true,\n        })\n      } else {\n        ;(promise as any)[prop] = underlyingParams[prop]\n      }\n    }\n  })\n\n  return promise\n}\n\nfunction makeUntrackedExoticParams(underlyingParams: Params): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingParams)\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      ;(promise as any)[prop] = underlyingParams[prop]\n    }\n  })\n\n  return promise\n}\n\nfunction makeUntrackedParams(underlyingParams: Params): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = Promise.resolve(underlyingParams)\n  CachedParams.set(underlyingParams, promise)\n\n  return promise\n}\n\nfunction makeDynamicallyTrackedExoticParamsWithDevWarnings(\n  underlyingParams: Params,\n  hasFallbackParams: boolean,\n  store: WorkStore\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = hasFallbackParams\n    ? makeDevtoolsIOAwarePromise(underlyingParams)\n    : // We don't want to force an environment transition when this params is not part of the fallback params set\n      Promise.resolve(underlyingParams)\n\n  const proxiedProperties = new Set<string>()\n  const unproxiedProperties: Array<string> = []\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n      unproxiedProperties.push(prop)\n    } else {\n      proxiedProperties.add(prop)\n      ;(promise as any)[prop] = underlyingParams[prop]\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          // We are accessing a property that was proxied to the promise instance\n          proxiedProperties.has(prop)\n        ) {\n          const expression = describeStringPropertyAccess('params', prop)\n          syncIODev(store.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return ReflectAdapter.set(target, prop, value, receiver)\n    },\n    ownKeys(target) {\n      const expression = '`...params` or similar expression'\n      syncIODev(store.route, expression, unproxiedProperties)\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedParams.set(underlyingParams, proxiedPromise)\n  return proxiedPromise\n}\n\n// Similar to `makeDynamicallyTrackedExoticParamsWithDevWarnings`, but just\n// logging the sync access without actually defining the params on the promise.\nfunction makeDynamicallyTrackedParamsWithDevWarnings(\n  underlyingParams: Params,\n  hasFallbackParams: boolean,\n  store: WorkStore\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = hasFallbackParams\n    ? makeDevtoolsIOAwarePromise(underlyingParams)\n    : // We don't want to force an environment transition when this params is not part of the fallback params set\n      Promise.resolve(underlyingParams)\n\n  const proxiedProperties = new Set<string>()\n  const unproxiedProperties: Array<string> = []\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n      unproxiedProperties.push(prop)\n    } else {\n      proxiedProperties.add(prop)\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          // We are accessing a property that was proxied to the promise instance\n          proxiedProperties.has(prop)\n        ) {\n          const expression = describeStringPropertyAccess('params', prop)\n          warnForSyncAccess(store.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return ReflectAdapter.set(target, prop, value, receiver)\n    },\n    ownKeys(target) {\n      const expression = '`...params` or similar expression'\n      warnForIncompleteEnumeration(store.route, expression, unproxiedProperties)\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedParams.set(underlyingParams, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction syncIODev(\n  route: string | undefined,\n  expression: string,\n  missingProperties?: Array<string>\n) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'request':\n        if (workUnitStore.prerenderPhase === true) {\n          // When we're rendering dynamically in dev, we need to advance out of\n          // the Prerender environment when we read Request data synchronously.\n          trackSynchronousRequestDataAccessInDev(workUnitStore)\n        }\n        break\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-runtime':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  // In all cases we warn normally\n  if (missingProperties && missingProperties.length > 0) {\n    warnForIncompleteEnumeration(route, expression, missingProperties)\n  } else {\n    warnForSyncAccess(route, expression)\n  }\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createParamsAccessError\n)\n\nconst warnForIncompleteEnumeration =\n  createDedupedByCallsiteServerErrorLoggerDev(createIncompleteEnumerationError)\n\nfunction createParamsAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`params\\` should be awaited before using its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction createIncompleteEnumerationError(\n  route: string | undefined,\n  expression: string,\n  missingProperties: Array<string>\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`params\\` should be awaited before using its properties. ` +\n      `The following properties were not available through enumeration ` +\n      `because they conflict with builtin property names: ` +\n      `${describeListOfPropertyNames(missingProperties)}. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction describeListOfPropertyNames(properties: Array<string>) {\n  switch (properties.length) {\n    case 0:\n      throw new InvariantError(\n        'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'\n      )\n    case 1:\n      return `\\`${properties[0]}\\``\n    case 2:\n      return `\\`${properties[0]}\\` and \\`${properties[1]}\\``\n    default: {\n      let description = ''\n      for (let i = 0; i < properties.length - 1; i++) {\n        description += `\\`${properties[i]}\\`, `\n      }\n      description += `, and \\`${properties[properties.length - 1]}\\``\n      return description\n    }\n  }\n}\n"],"names":["createParamsFromClient","createPrerenderParamsForClientSegment","createServerParamsForMetadata","createServerParamsForRoute","createServerParamsForServerSegment","underlyingParams","workStore","workUnitStore","workUnitAsyncStorage","getStore","type","createStaticPrerenderParams","InvariantError","process","env","NODE_ENV","devFallbackParams","createRenderParamsInDev","createRenderParamsInProd","throwInvariantForMissingStore","createRuntimePrerenderParams","workAsyncStorage","fallbackParams","fallbackRouteParams","key","has","makeHangingPromise","renderSignal","route","Promise","resolve","prerenderStore","makeHangingParams","makeErroringExoticParams","__NEXT_CACHE_COMPONENTS","makeUntrackedParams","makeUntrackedExoticParams","delayUntilRuntimeStage","hasFallbackParams","makeDynamicallyTrackedParamsWithDevWarnings","makeDynamicallyTrackedExoticParamsWithDevWarnings","CachedParams","WeakMap","fallbackParamsProxyHandler","get","target","prop","receiver","originalMethod","ReflectAdapter","args","store","dynamicAccessAsyncStorage","abortController","abort","Error","Proxy","apply","cachedParams","promise","set","augmentedUnderlying","Object","keys","forEach","wellKnownProperties","defineProperty","expression","describeStringPropertyAccess","postponeWithTracking","dynamicTracking","throwToInterruptStaticGeneration","enumerable","newValue","value","writable","configurable","makeDevtoolsIOAwarePromise","proxiedProperties","Set","unproxiedProperties","push","add","proxiedPromise","syncIODev","delete","ownKeys","Reflect","warnForSyncAccess","warnForIncompleteEnumeration","missingProperties","prerenderPhase","trackSynchronousRequestDataAccessInDev","length","createDedupedByCallsiteServerErrorLoggerDev","createParamsAccessError","createIncompleteEnumerationError","prefix","describeListOfPropertyNames","properties","description","i"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7494, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/client-page.tsx"],"sourcesContent":["'use client'\n\nimport type { ParsedUrlQuery } from 'querystring'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport type { Params } from '../../server/request/params'\n\n/**\n * When the Page is a client component we send the params and searchParams to this client wrapper\n * where they are turned into dynamically tracked values before being passed to the actual Page component.\n *\n * additionally we may send promises representing the params and searchParams. We don't ever use these passed\n * values but it can be necessary for the sender to send a Promise that doesn't resolve in certain situations.\n * It is up to the caller to decide if the promises are needed.\n */\nexport function ClientPageRoot({\n  Component,\n  searchParams,\n  params,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  promises,\n}: {\n  Component: React.ComponentType<any>\n  searchParams: ParsedUrlQuery\n  params: Params\n  promises?: Array<Promise<any>>\n}) {\n  if (typeof window === 'undefined') {\n    const { workAsyncStorage } =\n      require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n\n    let clientSearchParams: Promise<ParsedUrlQuery>\n    let clientParams: Promise<Params>\n    // We are going to instrument the searchParams prop with tracking for the\n    // appropriate context. We wrap differently in prerendering vs rendering\n    const store = workAsyncStorage.getStore()\n    if (!store) {\n      throw new InvariantError(\n        'Expected workStore to exist when handling searchParams in a client Page.'\n      )\n    }\n\n    const { createSearchParamsFromClient } =\n      require('../../server/request/search-params') as typeof import('../../server/request/search-params')\n    clientSearchParams = createSearchParamsFromClient(searchParams, store)\n\n    const { createParamsFromClient } =\n      require('../../server/request/params') as typeof import('../../server/request/params')\n    clientParams = createParamsFromClient(params, store)\n\n    return <Component params={clientParams} searchParams={clientSearchParams} />\n  } else {\n    const { createRenderSearchParamsFromClient } =\n      require('../request/search-params.browser') as typeof import('../request/search-params.browser')\n    const clientSearchParams = createRenderSearchParamsFromClient(searchParams)\n    const { createRenderParamsFromClient } =\n      require('../request/params.browser') as typeof import('../request/params.browser')\n    const clientParams = createRenderParamsFromClient(params)\n\n    return <Component params={clientParams} searchParams={clientSearchParams} />\n  }\n}\n"],"names":["ClientPageRoot","Component","searchParams","params","promises","window","workAsyncStorage","require","clientSearchParams","clientParams","store","getStore","InvariantError","createSearchParamsFromClient","createParamsFromClient","createRenderSearchParamsFromClient","createRenderParamsFromClient"],"mappings":";;;+BAegBA,kBAAAA;;;eAAAA;;;;gCAZe;AAYxB,SAASA,eAAe,KAW9B;IAX8B,IAAA,EAC7BC,SAAS,EACTC,YAAY,EACZC,MAAM,EACN,AACAC,QAAQ,EAMT,GAX8B,gDAIgC;IAQ7D,IAAI,OAAOC,WAAW,aAAa;QACjC,MAAM,EAAEC,gBAAgB,EAAE,GACxBC,QAAQ;QAEV,IAAIC;QACJ,IAAIC;QACJ,yEAAyE;QACzE,wEAAwE;QACxE,MAAMC,QAAQJ,iBAAiBK,QAAQ;QACvC,IAAI,CAACD,OAAO;YACV,MAAM,OAAA,cAEL,CAFK,IAAIE,gBAAAA,cAAc,CACtB,6EADI,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;QAEA,MAAM,EAAEC,4BAA4B,EAAE,GACpCN,QAAQ;QACVC,qBAAqBK,6BAA6BX,cAAcQ;QAEhE,MAAM,EAAEI,sBAAsB,EAAE,GAC9BP,QAAQ;QACVE,eAAeK,uBAAuBX,QAAQO;QAE9C,OAAA,WAAA,GAAO,CAAA,GAAA,YAAA,GAAA,EAACT,WAAAA;YAAUE,QAAQM;YAAcP,cAAcM;;IACxD,OAAO;QACL,MAAM,EAAEO,kCAAkC,EAAE,GAC1CR,QAAQ;QACV,MAAMC,qBAAqBO,mCAAmCb;QAC9D,MAAM,EAAEc,4BAA4B,EAAE,GACpCT,QAAQ;QACV,MAAME,eAAeO,6BAA6Bb;QAElD,OAAA,WAAA,GAAO,CAAA,GAAA,YAAA,GAAA,EAACF,WAAAA;YAAUE,QAAQM;YAAcP,cAAcM;;IACxD;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7551, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/client-segment.tsx"],"sourcesContent":["'use client'\n\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport type { Params } from '../../server/request/params'\n\n/**\n * When the Page is a client component we send the params to this client wrapper\n * where they are turned into dynamically tracked values before being passed to the actual Segment component.\n *\n * additionally we may send a promise representing params. We don't ever use this passed\n * value but it can be necessary for the sender to send a Promise that doesn't resolve in certain situations\n * such as when cacheComponents is enabled. It is up to the caller to decide if the promises are needed.\n */\nexport function ClientSegmentRoot({\n  Component,\n  slots,\n  params,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  promise,\n}: {\n  Component: React.ComponentType<any>\n  slots: { [key: string]: React.ReactNode }\n  params: Params\n  promise?: Promise<any>\n}) {\n  if (typeof window === 'undefined') {\n    const { workAsyncStorage } =\n      require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n\n    let clientParams: Promise<Params>\n    // We are going to instrument the searchParams prop with tracking for the\n    // appropriate context. We wrap differently in prerendering vs rendering\n    const store = workAsyncStorage.getStore()\n    if (!store) {\n      throw new InvariantError(\n        'Expected workStore to exist when handling params in a client segment such as a Layout or Template.'\n      )\n    }\n\n    const { createParamsFromClient } =\n      require('../../server/request/params') as typeof import('../../server/request/params')\n    clientParams = createParamsFromClient(params, store)\n\n    return <Component {...slots} params={clientParams} />\n  } else {\n    const { createRenderParamsFromClient } =\n      require('../request/params.browser') as typeof import('../request/params.browser')\n    const clientParams = createRenderParamsFromClient(params)\n    return <Component {...slots} params={clientParams} />\n  }\n}\n"],"names":["ClientSegmentRoot","Component","slots","params","promise","window","workAsyncStorage","require","clientParams","store","getStore","InvariantError","createParamsFromClient","createRenderParamsFromClient"],"mappings":";;;+BAcgBA,qBAAAA;;;eAAAA;;;;gCAZe;AAYxB,SAASA,kBAAkB,KAWjC;IAXiC,IAAA,EAChCC,SAAS,EACTC,KAAK,EACLC,MAAM,EAENC,AADA,OACO,EAMR,GAXiC,iDAI6B;IAQ7D,IAAI,OAAOC,WAAW,aAAa;QACjC,MAAM,EAAEC,gBAAgB,EAAE,GACxBC,QAAQ;QAEV,IAAIC;QACJ,yEAAyE;QACzE,wEAAwE;QACxE,MAAMC,QAAQH,iBAAiBI,QAAQ;QACvC,IAAI,CAACD,OAAO;YACV,MAAM,OAAA,cAEL,CAFK,IAAIE,gBAAAA,cAAc,CACtB,uGADI,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;QAEA,MAAM,EAAEC,sBAAsB,EAAE,GAC9BL,QAAQ;QACVC,eAAeI,uBAAuBT,QAAQM;QAE9C,OAAA,WAAA,GAAO,CAAA,GAAA,YAAA,GAAA,EAACR,WAAAA;YAAW,GAAGC,KAAK;YAAEC,QAAQK;;IACvC,OAAO;QACL,MAAM,EAAEK,4BAA4B,EAAE,GACpCN,QAAQ;QACV,MAAMC,eAAeK,6BAA6BV;QAClD,OAAA,WAAA,GAAO,CAAA,GAAA,YAAA,GAAA,EAACF,WAAAA;YAAW,GAAGC,KAAK;YAAEC,QAAQK;;IACvC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7603, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/lib/metadata/generate/icon-mark.tsx"],"sourcesContent":["'use client'\n\n// This is a client component that only renders during SSR,\n// but will be replaced during streaming with an icon insertion script tag.\n// We don't want it to be presented anywhere so it's only visible during streaming,\n// right after the icon meta tags so that browser can pick it up as soon as it's rendered.\n// Note: we don't just emit the script here because we only need the script if it's not in the head,\n// and we need it to be hoistable alongside the other metadata but sync scripts are not hoistable.\nexport const IconMark = () => {\n  if (typeof window !== 'undefined') {\n    return null\n  }\n  return <meta name=\"«nxt-icon»\" />\n}\n"],"names":["IconMark","window","meta","name"],"mappings":";;;+BAQaA,YAAAA;;;eAAAA;;;;AAAN,MAAMA,WAAW;IACtB,IAAI,OAAOC,WAAW,aAAa;QACjC,OAAO;IACT;IACA,OAAA,WAAA,GAAO,CAAA,GAAA,YAAA,GAAA,EAACC,QAAAA;QAAKC,MAAK;;AACpB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7625, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/client/components/metadata/async-metadata.tsx"],"sourcesContent":["'use client'\n\nimport { Suspense, use } from 'react'\nimport type { StreamingMetadataResolvedState } from './types'\n\nfunction MetadataOutlet({\n  promise,\n}: {\n  promise: Promise<StreamingMetadataResolvedState>\n}) {\n  const { error, digest } = use(promise)\n  if (error) {\n    if (digest) {\n      // The error will lose its original digest after passing from server layer to client layer；\n      // We recover the digest property here to override the React created one if original digest exists.\n      ;(error as any).digest = digest\n    }\n    throw error\n  }\n  return null\n}\n\nexport function AsyncMetadataOutlet({\n  promise,\n}: {\n  promise: Promise<StreamingMetadataResolvedState>\n}) {\n  return (\n    <Suspense fallback={null}>\n      <MetadataOutlet promise={promise} />\n    </Suspense>\n  )\n}\n"],"names":["AsyncMetadataOutlet","MetadataOutlet","promise","error","digest","use","Suspense","fallback"],"mappings":";;;+BAsBgBA,uBAAAA;;;eAAAA;;;;uBApBc;AAG9B,SAASC,eAAe,KAIvB;IAJuB,IAAA,EACtBC,OAAO,EAGR,GAJuB;IAKtB,MAAM,EAAEC,KAAK,EAAEC,MAAM,EAAE,GAAGC,CAAAA,GAAAA,OAAAA,GAAG,EAACH;IAC9B,IAAIC,OAAO;QACT,IAAIC,QAAQ;YACV,2FAA2F;YAC3F,mGAAmG;;YACjGD,MAAcC,MAAM,GAAGA;QAC3B;QACA,MAAMD;IACR;IACA,OAAO;AACT;AAEO,SAASH,oBAAoB,KAInC;IAJmC,IAAA,EAClCE,OAAO,EAGR,GAJmC;IAKlC,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACI,OAAAA,QAAQ,EAAA;QAACC,UAAU;kBAClB,WAAA,GAAA,CAAA,GAAA,YAAA,GAAA,EAACN,gBAAAA;YAAeC,SAASA;;;AAG/B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7670, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/CHIRAG%20PAUL/Desktop/MedSecureAI---Impactverse-Client1/node_modules/next/src/lib/framework/boundary-components.tsx"],"sourcesContent":["'use client'\n\nimport type { ReactNode } from 'react'\nimport {\n  METADATA_BOUNDARY_NAME,\n  VIEWPORT_BOUNDARY_NAME,\n  OUTLET_BOUNDARY_NAME,\n  ROOT_LAYOUT_BOUNDARY_NAME,\n} from './boundary-constants'\n\n// We use a namespace object to allow us to recover the name of the function\n// at runtime even when production bundling/minification is used.\nconst NameSpace = {\n  [METADATA_BOUNDARY_NAME]: function ({ children }: { children: ReactNode }) {\n    return children\n  },\n  [VIEWPORT_BOUNDARY_NAME]: function ({ children }: { children: ReactNode }) {\n    return children\n  },\n  [OUTLET_BOUNDARY_NAME]: function ({ children }: { children: ReactNode }) {\n    return children\n  },\n  [ROOT_LAYOUT_BOUNDARY_NAME]: function ({\n    children,\n  }: {\n    children: ReactNode\n  }) {\n    return children\n  },\n}\n\nexport const MetadataBoundary =\n  // We use slice(0) to trick the bundler into not inlining/minifying the function\n  // so it retains the name inferred from the namespace object\n  NameSpace[METADATA_BOUNDARY_NAME.slice(0) as typeof METADATA_BOUNDARY_NAME]\n\nexport const ViewportBoundary =\n  // We use slice(0) to trick the bundler into not inlining/minifying the function\n  // so it retains the name inferred from the namespace object\n  NameSpace[VIEWPORT_BOUNDARY_NAME.slice(0) as typeof VIEWPORT_BOUNDARY_NAME]\n\nexport const OutletBoundary =\n  // We use slice(0) to trick the bundler into not inlining/minifying the function\n  // so it retains the name inferred from the namespace object\n  NameSpace[OUTLET_BOUNDARY_NAME.slice(0) as typeof OUTLET_BOUNDARY_NAME]\n\nexport const RootLayoutBoundary =\n  // We use slice(0) to trick the bundler into not inlining/minifying the function\n  // so it retains the name inferred from the namespace object\n  NameSpace[\n    ROOT_LAYOUT_BOUNDARY_NAME.slice(0) as typeof ROOT_LAYOUT_BOUNDARY_NAME\n  ]\n"],"names":["MetadataBoundary","OutletBoundary","RootLayoutBoundary","ViewportBoundary","NameSpace","METADATA_BOUNDARY_NAME","children","VIEWPORT_BOUNDARY_NAME","OUTLET_BOUNDARY_NAME","ROOT_LAYOUT_BOUNDARY_NAME","slice"],"mappings":";;;;;;;;;;;;;;;;IA+BaA,gBAAgB,EAAA;eAAhBA;;IAUAC,cAAc,EAAA;eAAdA;;IAKAC,kBAAkB,EAAA;eAAlBA;;IAVAC,gBAAgB,EAAA;eAAhBA;;;mCA5BN;AAEP,4EAA4E;AAC5E,iEAAiE;AACjE,MAAMC,YAAY;IAChB,CAACC,mBAAAA,sBAAsB,CAAC,EAAE;cAAYC,QAAQ,EAA2B,GAArC;QAClC,OAAOA;IACT;IACA,CAACC,mBAAAA,sBAAsB,CAAC,EAAE;cAAYD,QAAQ,EAA2B,GAArC;QAClC,OAAOA;IACT;IACA,CAACE,mBAAAA,oBAAoB,CAAC,EAAE;cAAYF,QAAQ,EAA2B,GAArC;QAChC,OAAOA;IACT;IACA,CAACG,mBAAAA,yBAAyB,CAAC,EAAE;cAC3BH,QAAQ,EAGT,GAJsC;QAKrC,OAAOA;IACT;AACF;AAEO,MAAMN,mBACX,AACA,4DAA4D,oBADoB;AAEhFI,SAAS,CAACC,mBAAAA,sBAAsB,CAACK,KAAK,CAAC,GAAoC;AAEtE,MAAMP,mBACX,AACA,4DAA4D,oBADoB;AAEhFC,SAAS,CAACG,mBAAAA,sBAAsB,CAACG,KAAK,CAAC,GAAoC;AAEtE,MAAMT,iBACX,AACA,4DAA4D,oBADoB;AAEhFG,SAAS,CAACI,mBAAAA,oBAAoB,CAACE,KAAK,CAAC,GAAkC;AAElE,MAAMR,qBACX,AACA,4DAA4D,oBADoB;AAEhFE,SAAS,CACPK,mBAAAA,yBAAyB,CAACC,KAAK,CAAC,GACjC","ignoreList":[0],"debugId":null}}]
}